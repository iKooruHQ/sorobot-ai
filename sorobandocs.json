[{"pageContent":"WelcomeSoroban is a smart contracts platform designed to be sensible, built-to-scale, batteries-included, and developer-friendly.cautionSoroban is a preview release. Breaking changes may occur.While it works well with Stellar, a blockchain that shares its values of scale and sensibility, it doesn't depend on or require Stellar at all, and can be used by any transaction processor, including other blockchains, L2s, and permissioned ledgers.Currently, Soroban is a preview release that includes initial versions of the smart contracts environment, a Rust SDK, A CLI, and an RPC server. Developers can write and test contracts on their local machine or deploy them to a special test network dubbed Futurenet.What \"preview release\" means​We’re releasing this very early version of Soroban because we believe it’s important to share the development process, and we want Stellar ecosystem developers and smart contract developers from other ecosystems to have a chance to experiment and provide feedback.Please test it out, see what you can do, and let us know what you think. Keep in mind a lot will change between now and the production release, so expect your code to break, and prepare for updates to shift things. Experiment, but don't build to last just yet.How to leave feedback​Please feel free to file issues in the Soroban repos, or, if you prefer, to raise them in the soroban channels in the Stellar Developer Discord.Why it's called Soroban​The Japanese soroban is the smallest and simplest abacus. Its design is intentionally compact and minimalist, focused on doing the essentials — and doing them well. It set the global standard for abacuses and is still in practical use today. The name aligns with the goals of this platform because we, too, want to build something that focuses on doing the essentials well, that sets a global standard, and that proves useful far into the future.","metadata":{"source":"https://soroban.stellar.org/docs","title":"Welcome","contentLength":319}},{"pageContent":"SetupSoroban contracts are small programs written in the Rust programming language.To build and develop contracts you need only a couple prerequisites:A Rust toolchainAn editor that supports RustSoroban CLIInstall Rust​If you use macOS, Linux, or another Unix-like OS, the simplest method to install a Rust toolchain is to install rustup. Install rustup with the following command.curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | shIf you use Windows, or need an alternative method of installing Rust, check out: https://www.rust-lang.org/tools/installInstall the target​Install the wasm32-unknown-unknown target.rustup target add wasm32-unknown-unknownConfigure an Editor​Many editors have support for Rust. Visit the following link to find out how to configure your editor: https://www.rust-lang.org/toolsA popular editor is Visual Studio Code:Visual Studio Code editor.Rust Analyzer for Rust language support.CodeLLDB for step-through-debugging.Install the Soroban CLI​The Soroban CLI can execute Soroban contracts in the same environment the contract will execute on network, however in a local sandbox.Install the Soroban CLI using cargo install.cargo install --locked --version 0.9.4 soroban-cliinfoReport issues and share feedback about the Soroban CLI here.Usage​Run the soroban command and you should see output like below.soroban$ sorobanBuild, deploy, & interact with contracts; set identities to sign with; configure networks; generate keys; and more.Intro: https://soroban.stellar.orgCLI Reference: https://github.com/stellar/soroban-tools/tree/main/docs/soroban-cli-full-docs.mdUsage: soroban [OPTIONS] <COMMAND>Commands: contract Tools for smart contract developers config Read and update config events Watch the network for contract events lab Experiment with early features and expert tools version Print version information completion Print shell completion code for the specified shellOptions: --global Use global config -f, --filter-logs <FILTER_LOGS> Filter logs output. To turn on \"soroban_cli::log::footprint=debug\" or off \"=off\". Can also use env var `RUST_LOG` -q, --quiet Do not write logs to stderr including `INFO` -v, --verbose Log DEBUG events --very-verbose Log DEBUG and TRACE events --list List installed plugins. E.g. `soroban-hello` -h, --help Print help (see more with '--help') -V, --version Print versionTESTING_OPTIONS: --config-dir <CONFIG_DIR>infoProtip: You can use soroban completion to generate shell completion for bash, elvish, fish, powershell, and zsh. You should absolutely try it out. It will feel like a super power!!To enable autocomplete in the current bash shell, run:source <(soroban completion --shell bash)To enable autocomplete permanently in future bash shells, run:echo \"source <(soroban completion --shell bash)\" >> ~/.bashrcUsers of non-bash shells may need to adapt the above commands to suit their needs.","metadata":{"source":"https://soroban.stellar.org/docs/getting-started/setup","title":"Setup","contentLength":441}},{"pageContent":"1. Hello WorldOnce you've Setup your development environment, you're ready to create your first Soroban contract.Create New Project​Create a new Rust library using the cargo new command.cargo new --lib hello-sorobanOpen the Cargo.toml, it should look something like this:Cargo.toml[package]name = \"hello-soroban\"version = \"0.1.0\"edition = \"2021\"Configure the Library Type​Add the crate-type configuration, required for building contracts.[lib]crate-type = [\"cdylib\"]Import soroban-sdk and Features​Add the following sections to the Cargo.toml that will import the soroban-sdk, and configure a set of features explained below.cautionThe soroban-sdk is in early development. Report issues here.[dependencies]soroban-sdk = \"0.9.2\"[dev_dependencies]soroban-sdk = { version = \"0.9.2\", features = [\"testutils\"] }[features]testutils = [\"soroban-sdk/testutils\"]The features list includes a testutils feature, which will cause additional test utilities to be generated for calling the contract in tests.infoThe testutils test utilities are automatically enabled inside Rust unit tests inside the same crate as your contract. If you write tests from another crate, you'll need to require the testutils feature for those tests and enable the testutils feature when running your tests with cargo test --features testutils to be able to use those test utilities.Configure the release Profile​Configuring the release profile to optimize the contract build is critical. Soroban contracts have a maximum size of 256KB. Rust programs, even small ones, without these configurations almost always exceed this size.Add the following to your Cargo.toml and use the release profile when building.[profile.release]opt-level = \"z\"overflow-checks = truedebug = 0strip = \"symbols\"debug-assertions = falsepanic = \"abort\"codegen-units = 1lto = trueConfigure the release-with-logs Profile​Configuring a release-with-logs profile can be useful for if you need to build a .wasm that has logs enabled for printing debug logs when using the soroban-cli. Note that this is not necessary to access debug logs in tests or to use a step-through-debugger.Add the following to your Cargo.toml and use the release-with-logs profile when you need logs.[profile.release-with-logs]inherits = \"release\"debug-assertions = trueSee the logging example for more information about how to log.Wrapping it Up​The steps below should produce a Cargo.toml that looks like so.Cargo.toml[package]name = \"project-name\"version = \"0.1.0\"edition = \"2021\"[lib]crate-type = [\"cdylib\"][features]testutils = [\"soroban-sdk/testutils\"][dependencies]soroban-sdk = \"0.9.2\"[dev_dependencies]soroban-sdk = { version = \"0.9.2\", features = [\"testutils\"] }[profile.release]opt-level = \"z\"overflow-checks = truedebug = 0strip = \"symbols\"debug-assertions = falsepanic = \"abort\"codegen-units = 1lto = true[profile.release-with-logs]inherits = \"release\"debug-assertions = trueWrite a Contract​Once you've created a project, writing a contract involves writing Rust code in the projects lib.rs file.#![no_std]All contracts should begin with #![no_std] to ensure that the Rust standard library is not included in the build. The Rust standard library is large and not well suited to being deployed into small programs like those deployed to blockchains.use soroban_sdk::{contract, contractimpl, symbol_short, vec, Env, Symbol, Vec};The contract will need to import the types and macros that it needs from the soroban-sdk crate. Take a look at Create a Project to see how to setup a project.Many of the types available in typical Rust programs, such as std::vec::Vec, are not available, as there is no allocator and no heap memory in Soroban contracts. The soroban-sdk provides a variety of types like Vec, Map, Bytes, BytesN, Symbol, that all utilize the Soroban environment's memory and native capabilities. Primitive values like u128, i128, u64, i64, u32, i32, and bool can also be used. Floats and floating point math are not supported.Contract inputs must not be references.#[contract]pub struct Contract;#[contractimpl]impl Contract { pub fn hello(env: Env, to: Symbol) -> Vec<Symbol> { todo!() }}The #[contract] attribute designates the Contract struct as the type to which contract functions are associated. This implies that the struct will have contract functions implemented for it. Contract functions are defined within an impl block for the struct, which is annotated with #[contractimpl]. It is important to note that contract functions should have names with a maximum length of 32 characters. Additionally, if a function is intended to be invoked from outside the contract, it should be marked with the pub visibility modifier. It is common for the first argument of a contract function to be of type Env, allowing access to a copy of the Soroban environment, which is typically necessary for various operations within the contract.Putting those pieces together a simple contract will look like this.src/lib.rs#![no_std]use soroban_sdk::{contract, contractimpl, symbol_short, vec, Env, Symbol, Vec};#[contract]pub struct Contract;#[contractimpl]impl Contract { /// Say Hello to someone or something. /// Returns a length-2 vector/array containing 'Hello' and then the value passed as `to`. pub fn hello(env: Env, to: Symbol) -> Vec<Symbol> { vec![&env, symbol_short!(\"Hello\"), to] }}Testing​Writing tests for Soroban contracts involves writing Rust code using the test facilities and toolchain that you'd use for testing any Rust code.Given a simple contract like the contract demonstrated in the Write a Contract section, a simple test will look like this.src/lib.rssrc/test.rs#![no_std]use soroban_sdk::{contract, contractimpl, symbol_short, vec, Env, Symbol, Vec};#[contract]pub struct Contract;#[contractimpl]impl Contract { pub fn hello(env: Env, to: Symbol) -> Vec<Symbol> { vec![&env, symbol_short!(\"Hello\"), to] }}#[cfg(test)]mod test;use crate::{Contract, ContractClient};use soroban_sdk::{symbol_short, vec, Env};#[test]fn hello() { let env = Env::default(); let contract_id = env.register_contract(None, Contract); let client = ContractClient::new(&env, &contract_id); let words = client.hello(&symbol_short!(\"Dev\")); assert_eq!( words, vec![&env, symbol_short!(\"Hello\"), symbol_short!(\"Dev\"),] );}In any test the first thing that is always required is an Env, which is the Soroban environment that the contract will run inside of.let env = Env::default();The contract is registered with the environment using the contract type. Contracts can specify a fixed contract ID as the first argument, or provide None and one will be generated.let contract_id = env.register_contract(None, Contract);All public functions within an impl block that is annotated with the #[contractimpl] attribute have a corresponding function generated in a generated client type. The client type will be named the same as the contract type with Client appended. For example, in our contract the contract type is Contract, and the client is named ContractClient.let client = ContractClient::new(&env, &contract_id);let words = client.hello(&symbol_short!(\"Dev\"));The values returned by functions can be asserted on:assert_eq!( words, vec![&env, symbol_short!(\"Hello\"), symbol_short!(\"Dev\"),]);Run the Tests​Run cargo test and watch the contract run. You should see the following output:cargo testrunning 1 testtest test::test ... okTry changing the values in the test to see how it works.Build​To build a Soroban contract to deploy or run, use the soroban contract build command.soroban contract buildThis is a small wrapper around cargo build that sets the target to wasm32-unknown-unknown and the profile to release. You can think of it as a shortcut for the following command:cargo build --target wasm32-unknown-unknown --releaseA .wasm file will be outputted in the target directory. The .wasm file is the built contract.target/wasm32-unknown-unknown/release/hello_soroban.wasmThe .wasm file contains the logic of the contract, as well as the contract's specification / interface types, which can be imported into other contracts who wish to call it. This is the only artifact needed to deploy the contract, share the interface with others, or integration test against the contract.Optimize BuildsTo further optimize builds to be as small as possible, see Optimizing Builds.Run on Sandbox​If you have soroban-cli installed, you can run contracts in a local sandbox environment.The Soroban sandbox environment is the same Soroban environment that runs on Stellar networks, but it runs without nodes, and without the other features you find on a Stellar network.infoIt's also possible to run a contract on a fully featured local network. See the RPC Reference page for more details.Using the code we wrote in Write a Contract and the resulting .wasm file we built in Build, run the following command to invoke the hello function. Here we're setting the to argument to friend:soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/[project-name].wasm \\ --id 1 \\ -- \\ hello \\ --to friendThe following output should appear.[\"Hello\", \"friend\"]The -- double-dash is required!This is a general CLI pattern used by other commands like cargo run. Everything after the --, sometimes called slop, is passed to a child process. In this case, soroban contract invoke builds an implicit CLI on-the-fly for the hello method in your contract. It can do this because Soroban SDK embeds your contract's schema / interface types right in the .wasm file that gets deployed on-chain. You can also try:soroban contract invoke ... -- --helpandsoroban contract invoke ... -- hello --helpOptimizing Builds​Use soroban contract optimize to further minimize the size of the .wasm. First, re-install soroban-cli with the opt feature:cargo install --locked --version 0.9.1 soroban-cli --features optThen build an optimized .wasm file:soroban contract optimize \\ --wasm target/wasm32-unknown-unknown/release/hello_soroban.wasmThis will optimize and output a new hello_soroban.optimized.wasm file in the same location as the input .wasm.tipBuilding optimized contracts is only necessary when deploying to a network with fees or when analyzing and profiling a contract to get it as small as possible. If you're just starting out writing a contract, these steps are not necessary. See Build for details on how to build for development.Commit to version control​Now that everything's working, this is a great time to commit your code to version control. Even if you don't share your project with others, this will make it easier for you to see and understand your own changes throughout the rest of the tutorial.Go ahead and initialize hello-soroban as a git repository:git initYou'll need a .gitignore to tell git to ignore the target directory:echo target >> .gitignoreYou should also ignore the .soroban directory:echo .soroban >> .gitignoreNow you can make your initial commit:git add .git commit -m \"Initial commit: hello-soroban contract\"Summary​In this section, we wrote a simple contract that can be deployed to a Soroban network. We also learned how to run the contract locally using the Soroban sandbox environment.Next we'll add a new contract to this project, reorganizing the project as a multi-contract project using Cargo Workspaces. The new contract will show off a little bit of Soroban's storage capabilities.","metadata":{"source":"https://soroban.stellar.org/docs/getting-started/hello-world","title":"1. Hello World","contentLength":1795}},{"pageContent":"2. Storing DataNow that we've built a basic Hello World example to see the rough structure of Soroban contracts, we'll write a simple contract that stores and retrieves data. This will help you see the basics of Soroban's storage system. We'll also organize the two contracts as one combined project using a Cargo Workspace, which is a common pattern for Soroban projects.This is going to follow along with the increment example, which has a single function that increments an internal counter and returns the value. If you want to see a working example, try it in GitPod.This tutorial assumes that you've already completed the previous steps in Getting Started: Setup and Hello World.Setting up a multi-contract project​Many Soroban projects need more than one contract. Cargo makes this easy with workspaces, though it doesn't yet give a way to initialize a new project as a workspace (see #8365). Let's set it up manually.Rather than just a hello-soroban folder, we want a new soroban-tutorial folder with a contracts folder inside, into which we'll move the existing hello-soroban project. As a diff, we want this:-hello-soroban+soroban-tutorial/contracts/hello-sorobanSo change into the parent directory of hello-soroban and:mkdir -p soroban-tutorial/contractsmv hello-soroban soroban-tutorial/contractscd soroban-tutorialYou're going to want some Rust and Cargo stuff in different spots. From the new project root, run:rm contracts/hello-soroban/Cargo.lockmv contracts/hello-soroban/target .cp contracts/hello-soroban/Cargo.toml .Note that we copied the Cargo.toml file. That's because we're going to need some of it in the root and some of it in the subdirectory.In the root Cargo.toml:remove the [package], [lib], [features], and [dev_dependencies] sectionskeep the [release.*] stuffreplace the line [dependencies] with [workspace.dependencies]add a [workspace] sectionIn the project-specific Cargo.toml, keep roughly the opposite sections, and use the dependency versions as specified in the workspace root. It all ends up looking like this:Cargo.tomlcontracts/hello-soroban/Cargo.toml[workspace]resolver = \"2\"members = [ \"contracts/*\",][workspace.dependencies]soroban-sdk = \"0.9.2\"[profile.release]opt-level = \"z\"overflow-checks = truedebug = 0strip = \"symbols\"debug-assertions = falsepanic = \"abort\"codegen-units = 1lto = true[profile.release-with-logs]inherits = \"release\"debug-assertions = true[package]name = \"hello-soroban\"version = \"0.1.0\"edition = \"2021\"[lib]crate-type = [\"cdylib\"][dependencies]soroban-sdk = { workspace = true }[dev_dependencies]soroban-sdk = { workspace = true, features = [\"testutils\"] }[features]testutils = [\"soroban-sdk/testutils\"]Now make sure everything works:soroban contract buildEverything should build.cargo testAll tests should pass.Code​Rather than initializing this contract with cargo new, let's copy the hello-soroban project:cp -r contracts/hello-soroban contracts/incrementorYou'll need to update the Cargo.toml file to reflect the correct name:contracts/incrementor/Cargo.toml [package]-name = \"hello-soroban\"+name = \"incrementor\" version = \"0.1.0\" edition = \"2021\"And now in contracts/incrementor/src/lib.rs, we'll replace the contents with the following:contracts/incrementor/src/lib.rs#![no_std]use soroban_sdk::{contract, contractimpl, log, symbol_short, Env, Symbol};const COUNTER: Symbol = symbol_short!(\"COUNTER\");#[contract]pub struct IncrementorContract;#[contractimpl]impl IncrementorContract { /// Increment an internal counter; return the new value. pub fn increment(env: Env) -> u32 { let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0); count += 1; log!(&env, \"count: {}\", count); env.storage().instance().set(&COUNTER, &count); env.storage().instance().bump(100); count }}#[cfg(test)]mod test;Make sure it builds:soroban contract buildCheck that it built:ls target/wasm32-unknown-unknown/release/*.wasmYou should see both hello_soroban.wasm and incrementor.wasm.How it Works​Follow along in your contracts/incrementor/src/lib.rs file.Contract Data Keys​Contract data is associated with a key. The key is the value that can be used at a later time to lookup the value.Symbol is a short (up to 32 characters long) string type with limited character space (only a-zA-z0-9_ characters are allowed). Identifiers like contract function names are represented by Symbols.The symbol_short!() macro is a convenient way to pre-compute short symbols up to 9 characters in length at compile time using Symbol::short. It generates a compile-time constant that adheres to the valid character set of letters (a-zA-Z), numbers (0-9), and underscores (_). If a symbol exceeds the 9-character limit, Symbol::new should be utilized for creating symbols at runtime.const COUNTER: Symbol = symbol_short!(\"COUNTER\");Contract Data Access​The Env.storage() function is used to access and update contract data. The executing contract is the only contract that can query or modify contract data that it has stored. The data stored is viewable on ledger anywhere the ledger is viewable, but contracts executing within the Soroban environment are restricted to their own data.The get() function gets the current value associated with the counter key.let mut count: u32 = env .storage() .instance() .get(&COUNTER) .unwrap_or(0); // If no value set, assume 0.If no value is currently stored, the value given to unwrap_or(...) is returned instead.Values stored as contract data and retrieved are transmitted from the environment and expanded into the type specified. In this case a u32. If the value can be expanded, the type returned will be a u32. Otherwise, if a developer caused it to be some other type, a panic would occur at the unwrap.The set() function stores the new count value against the key, replacing the existing value.Managing Contract Data Lifetimes with bump()​All contract data has a \"lifetime\" that must be periodically bumped. If an entry's lifetime is not periodically bumped, the entry will eventually reach the end of its lifetime and \"expire\". You can learn more about this in the State Expiration document.For now, it's worth knowing that there are three kinds of storage: Persistent, Temporary, and Instance. This contract only uses Instance storage: env.storage().instance(). Every time the counter is incremented, this storage gets bumped by 100 ledgers, or about 500 seconds.Run on Sandbox​Let's invoke this contract the same way we invoked the Hello World contract. We'll use --id 2, since we already used --id 1 for the Hello World contract. For Sandbox, these values are stored in a .soroban/ledger.json file in the current directory; you can always remove this file to reset the ledger.soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/incrementor.wasm \\ --id 2 \\ -- \\ incrementYou should see the following output:1Rerun the invoke with the --footprint option to view the footprint of the invocation, which is the ledger entries that the contract will read or write to.soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/incrementor.wasm \\ --id 2 \\ --footprint \\ -- \\ incrementYou should see:Footprint: {\"readOnly\":[{\"contractData\":{\"contractId\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\"key\":{\"static\":\"ledgerKeyContractCode\"}}}],\"readWrite\":[{\"contractData\":{\"contractId\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\"key\":{\"symbol\":[67,79,85,78,84,69,82]}}}]}Footprint formats are unstableSoroban is a pre-release and at this time outputs footprints in an unstable JSON format.Run it without the --footprint a few more times to watch the count change.Use contract read to inspect what the full storage looks like after a few runs.soroban contract read --id 1 --key COUNTERTests​Open the contracts/increment/src/test.rs file and replace the contents with:contracts/incrementor/src/test.rsuse crate::{IncrementorContract, IncrementorContractClient};use soroban_sdk::Env;#[test]fn increment() { let env = Env::default(); let contract_id = env.register_contract(None, IncrementorContract); let client = IncrementorContractClient::new(&env, &contract_id); assert_eq!(client.increment(), 1); assert_eq!(client.increment(), 2); assert_eq!(client.increment(), 3);}This uses the same concepts described in the Hello World example.Make sure it passes:cargo testYou'll see that this runs tests for the whole workspace; both the Hello World contract and the new Incrementor.If you want to see the output of the log! call, run the tests with --nocapture:cargo test -- --nocaptureYou should see the output:running 1 testcount: U32(0)count: U32(1)count: U32(2)test test::incrementor ... okTake it further​Can you figure out how to add get_current_value function to the contract? What about decrement or reset functions?Commit your changes​Looking at your git diff will be interesting now. It's probably kind of noisy if you just run git status or git diff right away, but once you git add ., git will understand the renames (aka \"moves\") of all the old hello-soroban files better.Go ahead and commit it.git commit -m \"add incrementor contract\"Summary​In this section, we added a new contract to this project, reorganizing the project as a multi-contract project using Cargo Workspaces. The new contract made use of Soroban's storage capabilities to store and retrieve data. We also learned about the different kinds of storage and how to manage their lifetimes.Next we'll learn to deploy contracts to Soroban's Futurenet network and interact with them over RPC using the CLI.","metadata":{"source":"https://soroban.stellar.org/docs/getting-started/storing-data","title":"2. Storing Data","contentLength":1549}},{"pageContent":"EventsThe events example demonstrates how to publish events from a contract. This example is an extension of the storing data example.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example, navigate to the events directory, and use cargo test.cd eventscargo testYou should see the output:running 1 testtest test::test ... okCode​events/src/lib.rsconst COUNTER: Symbol = symbol_short!(\"COUNTER\");#[contract]pub struct IncrementContract;#[contractimpl]impl IncrementContract { /// Increment increments an internal counter, and returns the value. pub fn increment(env: Env) -> u32 { // Get the current count. let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0); // If no value set, assume 0. // Increment the count. count += 1; // Save the count. env.storage().instance().set(&COUNTER, &count); // Publish an event about the increment occuring. // The event has two topics: // - The \"COUNTER\" symbol. // - The \"increment\" symbol. // The event data is the count. env.events() .publish((COUNTER, symbol_short!(\"increment\")), count); // Return the count to the caller. count }}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/eventsHow it Works​This example contract extends the increment example by publishing an event each time the counter is incremented.Contract events let contracts emit information about what their contract is doing.Contracts can publish events using the environments events publish function.env.events().publish(topics, data);Event Topics​An event may contain up to four topics.Topics are conveniently defined using a tuple. In the sample code two topics of Symbol type are used.env.events().publish((COUNTER, symbol_short!(\"increment\")), ...);tipThe topics don't have to be made of the same type. You can mix different types as long as the total topic count stays below the limit.Event Data​An event also contains a data object of any value or type including types defined by contracts using #[contracttype]. In the example the data is the u32 count.env.events().publish(..., count);Publishing​Publishing an event is done by calling the publish function and giving it the topics and data. The function returns nothing on success, and panics on failure. Possible failure reasons can include malformed inputs (e.g. topic count exceeds limit) and running over the resource budget (TBD). Once successfully published, the new event will be available to applications consuming the events.env.events().publish((COUNTER, symbol_short!(\"increment\")), count);cautionPublished events are discarded if a contract invocation fails due to a panic, budget exhaustion, or when the contract returns an error.Tests​Open the events/src/test.rs file to follow along.events/src/test.rs#[test]fn test() { let env = Env::default(); let contract_id = env.register_contract(None, IncrementContract); let client = IncrementContractClient::new(&env, &contract_id); assert_eq!(client.increment(), 1); assert_eq!(client.increment(), 2); assert_eq!(client.increment(), 3); assert_eq!( env.events().all(), vec![ &env, ( contract_id.clone(), (symbol_short!(\"COUNTER\"), symbol_short!(\"increment\")).into_val(&env), 1u32.into_val(&env) ), ( contract_id.clone(), (symbol_short!(\"COUNTER\"), symbol_short!(\"increment\")).into_val(&env), 2u32.into_val(&env) ), ( contract_id, (symbol_short!(\"COUNTER\"), symbol_short!(\"increment\")).into_val(&env), 3u32.into_val(&env) ), ] );}In any test the first thing that is always required is an Env, which is the Soroban environment that the contract will run in.let env = Env::default();The contract is registered with the environment using the contract type.let contract_id = env.register_contract(None, IncrementContract);All public functions within an impl block that is annotated with the #[contractimpl] attribute have a corresponding function generated in a generated client type. The client type will be named the same as the contract type with Client appended. For example, in our contract the contract type is IncrementContract, and the client is named IncrementContractClient.let client = IncrementContractClient::new(&env, &contract_id);The example invokes the contract several times.assert_eq!(client.increment(), 1);The example asserts that the events were published.assert_eq!( env.events().all(), vec![ &env, ( contract_id.clone(), (symbol_short!(\"COUNTER\"), symbol_short!(\"increment\")).into_val(&env), 1u32.into_val(&env) ), // ... ]);Build the Contract​To build the contract, use the soroban contract build command.soroban contract buildA .wasm file should be outputted in the target directory:target/wasm32-unknown-unknown/release/soroban_events_contract.wasmRun the Contract​If you have soroban-cli installed, you can invoke contract functions in the using it.soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/soroban_events_contract.wasm \\ --id 1 \\ -- \\ incrementThe following output should occur using the code above.1#0: event: {\"ext\":\"v0\",\"contractId\":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],\"type\":\"contract\",\"body\":{\"v0\":{\"topics\":[{\"symbol\":[67,79,85,78,84,69,82]},{\"symbol\":[105,110,99,114,101,109,101,110,116]}],\"data\":{\"u32\":1}}}}A single event #0 is outputted, which is the contract event the contract published. The event contains the two topics, each a symbol (displayed as bytes), and the data object containing the u32.infoSoroban is a pre-release and at this time outputs events in an unstable JSON format.","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/events","title":"Events","contentLength":857}},{"pageContent":"ErrorsThe errors example demonstrates how to define and generate errors in a contract that invokers of the contract can understand and handle. This example is an extension of the storing data example.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example, navigate to the errors directory, and use cargo test.cd errorscargo testYou should see output that begins like this:running 2 testscount: U32(0)count: U32(1)count: U32(2)count: U32(3)count: U32(4)count: U32(5)Status(ContractError(1))contract call invocation resulted in error Status(ContractError(1))test test::test ... okthread 'test::test_panic' panicked at 'called `Result::unwrap()` on an `Err` value: HostErrorValue: Status(ContractError(1))Debug events (newest first): 0: \"Status(ContractError(1))\" 1: \"count: U32(5)\" 2: \"count: U32(4)\" 3: \"count: U32(3)\"...test test::test_panic - should panic ... oktest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.33sCode​errors/src/lib.rs#[contracterror]#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]#[repr(u32)]pub enum Error { LimitReached = 1,}const COUNTER: Symbol = symbol_short!(\"COUNTER\");const MAX: u32 = 5;#[contract]pub struct IncrementContract;#[contractimpl]impl IncrementContract { /// Increment increments an internal counter, and returns the value. Errors /// if the value is attempted to be incremented past 5. pub fn increment(env: Env) -> Result<u32, Error> { // Get the current count. let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0); // If no value set, assume 0. log!(&env, \"count: {}\", count); // Increment the count. count += 1; // Check if the count exceeds the max. if count <= MAX { // Save the count. env.storage().instance().set(&COUNTER, &count); // Return the count to the caller. Ok(count) } else { // Return an error if the max is exceeded. Err(Error::LimitReached) } }}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/errorsHow it Works​Open the errors/src/lib.rs file to follow along.Defining an Error​Contract errors are Rust u32 enums where every variant of the enum is assigned an integer. The #[contracterror] attribute is used to set the error up so it can be used in the return value of contract functions.The enum has some constraints:It must have the #[repr(u32)] attribute.It must have the #[derive(Copy)] attribute.Every variant must have an explicit integer value assigned.#[contracterror]#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]#[repr(u32)]pub enum Error { LimitReached = 1,}Contract errors cannot be stored as contract data, and therefore cannot be used as types on fields of contract types.tipIf an error is returned from a function anything the function has done is rolled back. If ledger entries have been altered, or contract data stored, all those changes are reverted and will not be persisted.Returning an Error​Errors can be returned from contract functions by returning Result<_, E>.The increment function returns a Result<u32, Error>, which means it returns Ok(u32) in the successful case, and Err(Error) in the error case.pub fn increment(env: Env) -> Result<u32, Error> { // ... if count <= MAX { // ... Ok(count) } else { // ... Err(Error::LimitReached) }}Panicking with an Error​Errors can also be panicked instead of being returned from the function.The increment function could also be written as follows with a u32 return value. The error can be passed to the environment using the panic_with_error! macro.pub fn increment(env: Env) -> u32 { // ... if count <= MAX { // ... count } else { // ... panic_with_error!(&env, Error::LimitReached) }}cautionFunctions that do not return a Result<_, E> type do not include in their specification what the possible error values are. This makes it more difficult for other contracts and clients to integrate with the contract. However, this might be ideal if the errors are diagnostic and debugging, and not intended to be handled.Tests​Open the errors/src/test.rs file to follow along.errors/src/test.rs#[test]fn test() { let env = Env::default(); let contract_id = env.register_contract(None, IncrementContract); let client = IncrementContractClient::new(&env, &contract_id); assert_eq!(client.try_increment(), Ok(Ok(1))); assert_eq!(client.try_increment(), Ok(Ok(2))); assert_eq!(client.try_increment(), Ok(Ok(3))); assert_eq!(client.try_increment(), Ok(Ok(4))); assert_eq!(client.try_increment(), Ok(Ok(5))); assert_eq!(client.try_increment(), Err(Ok(Error::LimitReached))); std::println!(\"{}\", env.logger().all().join(\"\\n\"));}#[test]#[should_panic(expected = \"Status(ContractError(1))\")]fn test_panic() { let env = Env::default(); let contract_id = env.register_contract(None, IncrementContract); let client = IncrementContractClient::new(&env, &contract_id); assert_eq!(client.increment(), 1); assert_eq!(client.increment(), 2); assert_eq!(client.increment(), 3); assert_eq!(client.increment(), 4); assert_eq!(client.increment(), 5); client.increment();}In any test the first thing that is always required is an Env, which is the Soroban environment that the contract will run in.let env = Env::default();The contract is registered with the environment using the contract type.let contract_id = env.register_contract(None, IncrementContract);All public functions within an impl block that is annotated with the #[contractimpl] attribute have a corresponding function generated in a generated client type. The client type will be named the same as the contract type with Client appended. For example, in our contract the contract type is IncrementContract, and the client is named IncrementContractClient.let client = IncrementContractClient::new(&env, &contract_id);Two functions are generated for every contract function, one that returns a Result<>, and the other that does not handle errors and panicks if an error occurs.try_increment​In the first test the try_increment function is called and returns Result<Result<u32, _>, Result<Error, Status>>.assert_eq!(client.try_increment(), Ok(Ok(5)));assert_eq!(client.try_increment(), Err(Ok(Error::LimitReached)));If the function call is successful, Ok(Ok(u32)) is returned.If the function call is successful but returns a value that is not a u32, Ok(Err(_)) is returned.If the function call is unsuccessful, Err(Ok(Error)) is returned.If the function call is unsuccessful but returns an error code not in the Error enum, or returns a system error code, Err(Err(Status)) is returned and the Status can be inspected.increment​In the second test the increment function is called and returns u32. When the last call is made the function panicks.assert_eq!(client.increment(), 5);client.increment();If the function call is successful, u32 is returned.If the function call is successful but returns a value that is not a u32, a panic occurs.If the function call is unsuccessful, a panic occurs.Build the Contract​To build the contract, use the soroban contract build command.soroban contract buildA .wasm file should be outputted in the target directory:target/wasm32-unknown-unknown/release/soroban_errors_contract.wasmRun the Contract​If you have soroban-cli installed, you can invoke contract functions in the Wasm using it.soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/soroban_errors_contract.wasm \\ --id 1 \\ -- \\ incrementRun the command a few times and on the 6th invocation the following output should occur.❯ soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/soroban_errors_contract.wasm \\ --id 1 \\ -- \\ incrementerror: HostErrorValue: Status(ContractError(1))...Use the soroban to inspect what the counter is.soroban contract read --id 1 --key COUNTER","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/errors","title":"Errors","contentLength":1209}},{"pageContent":"LoggingThe logging example demonstrates how to log for the purpose of debugging.Logs in contracts are only visible in tests, or when executing contracts using soroban-cli. Logs are only compiled into the contract if the debug-assertions Rust compiler option is enabled.tipLogs are no a substitute for step-through debugging. Rust tests for Soroban can be step-through debugged in your Rust-enabled IDE. See testing for more details.cautionLogs are not accessible by dapps and other applications. See the events example for how to produce structured events.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example, navigate to the logging directory, and use cargo test.cd loggingcargo test -- --nocaptureYou should see the output:running 1 testHello Symbol(Dev)test test::test ... okCode​Cargo.toml[profile.release-with-logs]inherits = \"release\"debug-assertions = truelogging/src/lib.rs#![no_std]use soroban_sdk::{contractimpl, log, Env, Symbol};#[contract]pub struct Contract;#[contractimpl]impl Contract { pub fn hello(env: Env, value: Symbol) { log!(&env, \"Hello {}\", value); }}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/loggingHow it Works​The log! macro logs a string. Any logs that occur during execution are outputted to stdout in soroban-cli and available for tests to assert on or print.Logs are only outputted if the contract is built with the debug-assertions compiler option enabled. This makes them efficient to leave in code permanently since a regular release build will omit them.Logs are only recorded in Soroban environments that have logging enabled. The only Soroban environments where logging is enabled is in Rust tests, and in the soroban-cli.Open the files above to follow along.Cargo.toml Profile​Logs are only outputted if the contract is built with the debug-assertions compiler option enabled.The test profile that is activated when running cargo test has debug-assertions enabled, so when running tests logs are enabled by default.A new release-with-logs profile is added to Cargo.toml that inherits from the release profile, and enables debug-assertions. It can be used to build a .wasm file that has logs enabled.[profile.release-with-logs]inherits = \"release\"debug-assertions = trueTo build without logs use the --release or --profile release option.To build with logs use the --profile release-with-logs option.Using the log! Macro​The log! macro builds a string from the format string, and a list of arguments. Arguments are substituted wherever the {} value appears in the format string.log!(&env, \"Hello {}\", value);The above log will render as follows if value is a Symbol containing \"Dev\".Hello Symbol(Dev)cautionThe values outputted are currently relatively limited. While primitive values like u32, u64, bool, and Symbols will render clearly in the log output, Bytes, Vec, Map, and custom types will render only their handle number. Logging capabilities are in early development.Tests​Open the logging/src/test.rs file to follow along.logging/src/test.rsextern crate std;#[test]fn test() { let env = Env::default(); let contract_id = env.register_contract(None, Contract); let client = ContractClient::new(&env, &contract_id); client.hello(&symbol_short!(\"Dev\")); let logs = env.logger().all(); assert_eq!(logs, std::vec![\"Hello Symbol(Dev)\"]); std::println!(\"{}\", logs.join(\"\\n\"));}The std crate, which contains the Rust standard library, is imported so that the test can use the std::vec! and std::println! macros. Since contracts are required to use #![no_std], tests in contracts must manually import std to use std functionality like printing to stdout.extern crate std;In any test the first thing that is always required is an Env, which is the Soroban environment that the contract will run in.let env = Env::default();The contract is registered with the environment using the contract type.let contract_id = env.register_contract(None, HelloContract);All public functions within an impl block that is annotated with the #[contractimpl] attribute have a corresponding function generated in a generated client type. The client type will be named the same as the contract type with Client appended. For example, in our contract the contract type is HelloContract, and the client is named HelloContractClient.let client = HelloContractClient::new(&env, &contract_id);let words = client.hello(&symbol_short!(\"Dev\"));Logs are available in tests via the environment.let logs = env.logger().all();They can asserted on like any other value.assert_eq!(logs, std::vec![\"Hello Symbol(Dev)\"]);They can be printed to stdout.std::println!(\"{}\", logs.join(\"\\n\"));Build the Contract​To build the contract, use the soroban contract build command.Without Logs​To build the contract without logs, use the --release option.soroban contract buildA .wasm file should be outputted in the target directory, in the release subdirectory:target/wasm32-unknown-unknown/release/soroban_logging_contract.wasmWith Logs​To build the contract with logs, use the --profile release-with-logs option.soroban contract build --profile release-with-logsA .wasm file should be outputted in the target directory, in the release-with-logs subdirectory:target/wasm32-unknown-unknown/release-with-logs/soroban_logging_contract.wasmRun the Contract​If you have soroban-cli installed, you can invoke contract functions in the using it. Specify the -v option to enable verbose logs.soroban -v contract invoke \\ --wasm target/wasm32-unknown-unknown/release-with-logs/soroban_logging_contract.wasm \\ --id 1 \\ -- \\ hello \\ --value friendThe output should include the following line.soroban_cli::log::event::contract_log: log=\"Hello Symbol(me)\"","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/logging","title":"Logging","contentLength":927}},{"pageContent":"AuthThe auth example demonstrates how to implement authentication and authorization using the Soroban Host-managed auth framework.This example is an extension of the storing data example.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example, navigate to the auth directory, and use cargo test.cd authcargo testYou should see the output:running 1 testtest test::test ... okCode​auth/src/lib.rs#[contracttype]pub enum DataKey { Counter(Address),}#[contract]pub struct IncrementContract;#[contractimpl]impl IncrementContract { /// Increment increments a counter for the user, and returns the value. pub fn increment(env: Env, user: Address, value: u32) -> u32 { // Requires `user` to have authorized call of the `increment` of this // contract with all the arguments passed to `increment`, i.e. `user` // and `value`. This will panic if auth fails for any reason. // When this is called, Soroban host performs the necessary // authentication, manages replay prevention and enforces the user's // authorization policies. // The contracts normally shouldn't worry about these details and just // write code in generic fashion using `Address` and `require_auth` (or // `require_auth_for_args`). user.require_auth(); // This call is equilvalent to the above: // user.require_auth_for_args((&user, value).into_val(&env)); // The following has less arguments but is equivalent in authorization // scope to the above calls (the user address doesn't have to be // included in args as it's guaranteed to be authenticated). // user.require_auth_for_args((value,).into_val(&env)); // Construct a key for the data being stored. Use an enum to set the // contract up well for adding other types of data to be stored. let key = DataKey::Counter(user.clone()); // Get the current count for the invoker. let mut count: u32 = env.storage().persistent().get(&key).unwrap_or_default(); // Increment the count. count += value; // Save the count. env.storage().persistent().set(&key, &count); // Return the count to the caller. count }}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/authHow it Works​The example contract stores a per-Address counter that can only be incremented by the owner of that Address.Open the auth/src/lib.rs file or see the code above to follow along.Address​#[contracttype]pub enum DataKey { Counter(Address),}Address is a universal Soroban identifier that may represent a Stellar account, a contract or an 'account contract' (a contract that defines a custom authentication scheme and authorization policies). Contracts don't need to distinguish between these internal representations though. Address can be used any time some network identity needs to be represented, like to distinguish between counters for different users in this example.Enum keys like DataKey are useful for organizing contract storage.Different enum values create different key 'namespaces'.In the example the counter for each address is stored against DataKey::Counter(Address). If the contract needs to start storing other types of data, it can do so by adding additional variants to the enum.require_auth​impl IncrementContract { pub fn increment(env: Env, user: Address, value: u32) -> u32 { user.require_auth();require_auth method can be called for any Address. Semantically user.require_auth() here means 'require user to have authorized calling increment function of the current IncrementContract instance with the current call arguments, i.e. the current user and value argument values'. In simpler terms, this ensures that the user has allowed incrementing their counter value and nobody else can increment it.When using require_auth the contract implementation doesn't need to worry about the signatures, authentication, and replay prevention. All these features are implemented by the Soroban host and happen automatically as long as the Address type is used.Address has another method called require_auth_for_args. It works in the same fashion as require_auth, but allows customizing the arguments that need to be authorized. Note though, this should be used with care to ensure that there is a deterministic mapping between the contract invocation arguments and the require_auth_for_args arguments.The following two calls are functionally equivalent to user.require_auth:// Completely equivalentuser.require_auth_for_args((&user, value).into_val(&env));// The following has less arguments but is equivalent in authorization// scope to the above call (the user address doesn't have to be// included in args as it's guaranteed to be authenticated).user.require_auth_for_args((value,).into_val(&env));Tests​Open the auth/src/test.rs file to follow along.auth/src/test.rsfn test() { let env = Env::default(); env.mock_all_auths(); let contract_id = env.register_contract(None, IncrementContract); let client = IncrementContractClient::new(&env, &contract_id); let user_1 = Address::random(&env); let user_2 = Address::random(&env); assert_eq!(client.increment(&user_1, &5), 5); // Verify that the user indeed had to authorize a call of `increment` with // the expected arguments: assert_eq!( env.auths(), [( // Address for which auth is performed user_1.clone(), // Identifier of the called contract contract_id.clone(), // Name of the called function symbol_short!(\"increment\"), // Arguments used to call `increment` (converted to the env-managed vector via `into_val`) (user_1.clone(), 5_u32).into_val(&env) )] ); // Do more `increment` calls. It's not necessary to verify authorizations // for every one of them as we don't expect the auth logic to change from // call to call. assert_eq!(client.increment(&user_1, &2), 7); assert_eq!(client.increment(&user_2, &1), 1); assert_eq!(client.increment(&user_1, &3), 10); assert_eq!(client.increment(&user_2, &4), 5);}In any test the first thing that is always required is an Env, which is the Soroban environment that the contract will run in.let env = Env::default();The test instructs the environment to mock all auths. All calls to require_auth or require_auth_for_args will succeed.env.mock_all_auths();The contract is registered with the environment using the contract type.let contract_id = env.register_contract(None, IncrementContract);All public functions within an impl block that is annotated with the #[contractimpl] attribute have a corresponding function generated in a generated client type. The client type will be named the same as the contract type with Client appended. For example, in our contract the contract type is IncrementContract, and the client is named IncrementContractClient.let client = IncrementContractClient::new(&env, &contract_id);Generate Addresses for two users. Normally the exact value of the Address shouldn't matter for testing, so they're simply generated randomly.let user_1 = Address::random(&env);let user_2 = Address::random(&env);Invoke increment function for user_1.assert_eq!(client.increment(&user_1, &5), 5);In order to verify that the require_auth call(s) have indeed happened, use auths function that returns a vector of tuples containing the authorizations from the most recent contract invocation.assert_eq!( env.auths(), [( // Address for which auth is performed user_1.clone(), // Identifier of the called contract contract_id.clone(), // Name of the called function symbol_short!(\"increment\"), // Arguments used to call `increment` (converted to the env-managed vector via `into_val`) (user_1.clone(), 5_u32).into_val(&env) )]);Invoke increment function several more times for both users. Notice, that the values are tracked separately for each users.assert_eq!(client.increment(&user_1, &2), 7);assert_eq!(client.increment(&user_2, &1), 1);assert_eq!(client.increment(&user_1, &3), 10);assert_eq!(client.increment(&user_2, &4), 5);Build the Contract​To build the contract into a .wasm file, use the soroban contract build command.soroban contract buildThe .wasm file should be found in the target directory after building:target/wasm32-unknown-unknown/release/soroban_auth_contract.wasmRun the Contract​If you have soroban-cli installed, you can invoke functions on the contract.But since we are dealing with authorization and signatures, we need to set up some identities to use for testing and get their public keys:soroban config identity generate acc1 && \\soroban config identity generate acc2 && \\soroban config identity address acc1 && \\soroban config identity address acc2Example output with two public keys of identities:GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRUGAJGHZ44IJXYFNOVRZGBCVKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6BNow the contract itself can be invoked. Notice the --source must be the identity name matching the address passed to the --user argument. This allows soroban tool to automatically sign the necessary payload for the invocation.soroban contract invoke \\ --source acc1 \\ --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract.wasm \\ --id 1 \\ -- \\ increment \\ --user GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRU \\ --value 2Run a few more increments for both accounts.soroban contract invoke \\ --source acc2 \\ --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract.wasm \\ --id 1 \\ -- \\ increment \\ --user GAJGHZ44IJXYFNOVRZGBCVKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B \\ --value 5soroban contract invoke \\ --source acc1 \\ --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract.wasm \\ --id 1 \\ -- \\ increment \\ --user GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRU \\ --value 3soroban contract invoke \\ --source acc2 \\ --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract.wasm \\ --id 1 \\ -- \\ increment \\ --user GAJGHZ44IJXYFNOVRZGBCVKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B \\ --value 10View the data that has been stored against each user with soroban contract read.soroban contract read --id 1\"[\"\"Counter\"\",\"\"GA6S566FD3EQDUNQ4IGSLXKW3TGVSTQW3TPHPGS7NWMCEIPBOKTNCSRU\"\"]\",5\"[\"\"Counter\"\",\"\"GAJGHZ44IJXYFNOVRZGBCVKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B\"\"]\",15It is also possible to preview the authorization payload that is being signed by providing --auth flag to the invocation:soroban contract invoke \\ --source acc2 \\ --auth \\ --wasm target/wasm32-unknown-unknown/release/soroban_auth_contract.wasm \\ --id 1 \\ -- \\ increment \\ --user GAJGHZ44IJXYFNOVRZGBCVKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6B \\ --value 123Contract auth: [{\"address_with_nonce\":null,\"root_invocation\":{\"contract_id\":\"0000000000000000000000000000000000000000000000000000000000000001\",\"function_name\":\"increment\",\"args\":[{\"object\":{\"address\":{\"account\":{\"public_key_type_ed25519\":\"c7bab0288753d58d3e21cc3fa68cd2546b5f78ae6635a6f1b3fe07e03ee846e9\"}}}},{\"u32\":123}],\"sub_invocations\":[]},\"signature_args\":[]}]Further reading​Authorization documentation provides more details on how Soroban auth framework works.Timelock and Single Offer examples demonstrate authorizing token operations on behalf of the user, which can be extended to any nested contract invocations.Atomic Swap example demonstrates multi-party authorization where multiple users sign their parts of the contract invocation.Custom Account example for demonstrates an account contract that defines a custom authentication scheme and user-defined authorization policies.","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/auth","title":"Auth","contentLength":1558}},{"pageContent":"Custom TypesThe custom types example demonstrates how to define your own data structures that can be stored on the ledger, or used as inputs and outputs to contract invocations. This example is an extension of the storing data example.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example, navigate to the custom_types directory, and use cargo test.cd custom_typescargo testYou should see the output:running 1 testtest test::test ... okCode​custom_types/src/lib.rs#[contracttype]#[derive(Clone, Debug, Eq, PartialEq)]pub struct State { pub count: u32, pub last_incr: u32,}const STATE: Symbol = symbol_short!(\"STATE\");#[contract]pub struct IncrementContract;#[contractimpl]impl IncrementContract { /// Increment increments an internal counter, and returns the value. pub fn increment(env: Env, incr: u32) -> u32 { // Get the current count. let mut state = Self::get_state(env.clone()); // Increment the count. state.count += incr; state.last_incr = incr; // Save the count. env.storage().instance().set(&STATE, &state); // Return the count to the caller. state.count } /// Return the current state. pub fn get_state(env: Env) -> State { env.storage().instance().get(&STATE).unwrap_or(State { count: 0, last_incr: 0, }) // If no value set, assume 0. }}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/custom_typesHow it Works​Custom types are defined using the #[contracttype] attribute on either a struct or an enum.Open the custom_types/src/lib.rs file to follow along.Custom Type: Struct​Structs are stored on ledger as a map of key-value pairs, where the key is up to a 32 character string representing the field name, and the value is the value encoded.Field names must be no more than 32 characters.#[contracttype]#[derive(Clone, Debug, Eq, PartialEq)]pub struct State { pub count: u32, pub last_incr: u32,}Custom Type: Enum​The example does not contain enums, but enums may also be contract types.Enums containing unit and tuple variants are stored on ledger as a two element vector, where the first element is the name of the enum variant as a string up to 32 characters in length, and the value is the value if the variant has one.Only unit variants and single value variants, like A and B below, are supported.#[contracttype]#[derive(Clone, Debug, Eq, PartialEq)]pub enum Enum { A, B(...),}Enums containing integer values are stored on ledger as the u32 value.#[contracttype]#[derive(Copy, Clone, Debug, Eq, PartialEq)]#[repr(u32)]pub enum Enum { A = 1, B = 2,}Using Types in Functions​Types that have been annotated with #[contracttype] can be stored as contract data and retrieved later.Types can also be used as inputs and outputs on contract functions.pub fn increment(env: Env, incr: u32) -> u32 { let mut state = Self::get_state(env.clone()); state.count += incr; state.last_incr = incr; env.storage().instance().set(&STATE, &state); state.count}pub fn get_state(env: Env) -> State { env.storage().instance().get(&STATE).unwrap_or(State { count: 0, last_incr: 0, }) // If no value set, assume 0.}Tests​Open the custom_types/src/test.rs file to follow along.custom_types/src/test.rs#[test]fn test() { let env = Env::default(); let contract_id = env.register_contract(None, IncrementContract); let client = IncrementContractClient::new(&env, &contract_id); assert_eq!(client.increment(&1), 1); assert_eq!(client.increment(&10), 11); assert_eq!( client.get_state(), State { count: 11, last_incr: 10 } );}In any test the first thing that is always required is an Env, which is the Soroban environment that the contract will run in.let env = Env::default();The contract is registered with the environment using the contract type.let contract_id = env.register_contract(None, IncrementContract);All public functions within an impl block that is annotated with the #[contractimpl] attribute have a corresponding function generated in a generated client type. The client type will be named the same as the contract type with Client appended. For example, in our contract the contract type is IncrementContract, and the client is named IncrementContractClient.let client = IncrementContractClient::new(&env, &contract_id);The test invokes the increment function on the registered contract that causes the State type to be stored and updated a couple times.assert_eq!(client.increment(&1), 1);assert_eq!(client.increment(&10), 11);The test then invokes the get_state function to get the State value that was stored, and can assert on its values.assert_eq!( client.get_state(), State { count: 11, last_incr: 10 });Build the Contract​To build the contract, use the soroban contract build command.soroban contract buildA .wasm file should be outputted in the target directory:target/wasm32-unknown-unknown/release/soroban_custom_types_contract.wasmRun the Contract​If you have soroban-cli installed, you can invoke contract functions in the Wasm using it.soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/soroban_custom_types_contract.wasm \\ --id 1 \\ -- \\ increment \\ --incr 5The following output should occur using the code above.5Run it a few more times with different increment amounts to watch the count change.Use the soroban to inspect what the counter is after a few runs.soroban contract read --id 1 --key STATESTATE,\"{\"\"count\"\":25,\"\"last_incr\"\":15}\"","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/custom-types","title":"Custom Types","contentLength":860}},{"pageContent":"Cross Contract CallsThe cross contract call example demonstrates how to call a contract from another contract.infoIn this example there are two contracts that are compiled separately, deployed separately, and then tested together. There are a variety of ways to develop and test contracts with dependencies on other contracts, and the Soroban SDK and tooling is still building out the tools to support these workflows. Feedback appreciated here.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example, navigate to the cross_contract/contract_b directory, and use cargo test.cd cross_contract/contract_bcargo testYou should see the output:running 1 testtest test::test ... okCode​cross_contract/contract_a/src/lib.rs#[contract]pub struct ContractA;#[contractimpl]impl ContractA { pub fn add(x: u32, y: u32) -> u32 { x.checked_add(y).expect(\"no overflow\") }}cross_contract/contract_b/src/lib.rsmod contract_a { soroban_sdk::contractimport!( file = \"../contract_a/target/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract.wasm\" );}#[contract]pub struct ContractB;#[contractimpl]impl ContractB { pub fn add_with(env: Env, contract: Address, x: u32, y: u32) -> u32 { let client = contract_a::Client::new(&env, &contract); client.add(&x, &y) }}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/cross_contractHow it Works​Cross contract calls are made by invoking another contract by its contract ID.Contracts to invoke can be imported into your contract with the use of contractimport!(file = \"...\"). The import will code generate:A ContractClient type that can be used to invoke functions on the contract.Any types in the contract that were annotated with #[contracttype].tipThe contractimport! macro will generate the types in the module it is used, so it's a good idea to use the macro inside a mod { ... } block, or inside its own file, so that the names of generated types don't collide with names of types in your own contract.Open the files above to follow along.Contract A: The Contract to be Called​The contract to be called is Contract A. It is a simple contract that accepts x and y parameters, adds them together and returns the result.cross_contract/contract_a/src/lib.rs#[contract]pub struct ContractA;#[contractimpl]impl ContractA { pub fn add(x: u32, y: u32) -> u32 { x.checked_add(y).expect(\"no overflow\") }}tipThe contract uses the checked_add method to ensure that there is no overflow, and if there is overflow, panics rather than returning an overflowed value. Rust's primitive integer types all have checked operations available as functions with the prefix checked_.Contract B: The Contract doing the Calling​The contract that does the calling is Contract B. It accepts a contract ID that it will call, as well as the same parameters to pass through. In many contracts the contract to call might have been stored as contract data and be retrieved, but in this simple example it is being passed in as a parameter each time.The contract imports Contract A into the contract_a module.The contract_a::Client is constructed pointing at the contract ID passed in.The client is used to execute the add function with the x and y parameters on Contract A.cross_contract_calls/src/a.rsmod contract_a { soroban_sdk::contractimport!( file = \"../contract_a/target/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract.wasm\" );}#[contract]pub struct ContractB;#[contractimpl]impl ContractB { pub fn add_with(env: Env, contract: Address, x: u32, y: u32) -> u32 { let client = contract_a::Client::new(&env, &contract); client.add(&x, &y) }}Tests​Open the cross_contract/contract_b/src/test.rs file to follow along.cross_contract/contract_b/src/test.rs#[test]fn test() { let env = Env::default(); // Register contract A using the imported Wasm. let contract_a_id = env.register_contract_wasm(None, contract_a::Wasm); // Register contract B defined in this crate. let contract_b_id = env.register_contract(None, ContractB); // Create a client for calling contract B. let client = ContractBClient::new(&env, &contract_b_id); // Invoke contract B via its client. Contract B will invoke contract A. let sum = client.add_with(&contract_a_id, &5, &7); assert_eq!(sum, 12);}In any test the first thing that is always required is an Env, which is the Soroban environment that the contract will run in.let env = Env::default();Contract A is registered with the environment using the imported Wasm.let contract_a_id = env.register_contract_wasm(None, contract_a::Wasm);Contract B is registered with the environment using the contract type.let contract_b_id = env.register_contract(None, ContractB);All public functions within an impl block that is annotated with the #[contractimpl] attribute have a corresponding function generated in a generated client type. The client type will be named the same as the contract type with Client appended. For example, in our contract the contract type is ContractB, and the client is named ContractBClient. The client can be constructed and used in the same way that client generated for Contract A can be.let client = ContractBClient::new(&env, &contract_b_id);The client is used to invoke the add_with function on Contract B. Contract B will invoke Contract A, and the result will be returned.let sum = client.add_with(&contract_a_id, &5, &7);The test asserts that the result that is returned is as we expect.assert_eq!(sum, 12);Build the Contracts​To build the contract into a .wasm file, use the soroban contract build command. Both contract_call/contract_a and contract_call/contract_b must be built, with contract_a being built first.soroban contract buildBoth .wasm files should be found in both contract target directories after building both contracts:target/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract.wasmtarget/wasm32-unknown-unknown/release/soroban_cross_contract_b_contract.wasmRun the Contract​If you have soroban-cli installed, you can invoke contract functions. Both contracts must be deployed.soroban contract deploy \\ --wasm target/wasm32-unknown-unknown/release/soroban_cross_contract_a_contract.wasm \\ --id asoroban contract deploy \\ --wasm target/wasm32-unknown-unknown/release/soroban_cross_contract_b_contract.wasm \\ --id bInvoke Contract B's add_with function, passing in values for x and y (e.g. as 5 and 7), and then pass in the contract ID of Contract A.soroban contract invoke \\ --id b \\ -- \\ add_with \\ --contract_id a \\ --x 5 \\ --y 7The following output should occur using the code above.12Contract B's add_with function invoked Contract A's add function to do the addition.","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/cross-contract-call","title":"Cross Contract Calls","contentLength":1042}},{"pageContent":"DeployerThe deployer example demonstrates how to deploy contracts using a contract.Here we deploy a contract on behalf of any address and initialize it atomically.infoIn this example there are two contracts that are compiled separately, and the tests deploy one with the other.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example, navigate to the deployer/deployer directory, and use cargo test.cd deployer/deployercargo testYou should see the output:running 1 testtest test::test ... okCode​deployer/deployer/src/lib.rs#[contract]pub struct Deployer;#[contractimpl]impl Deployer { /// Deploy the contract Wasm and after deployment invoke the init function /// of the contract with the given arguments. /// /// This has to be authorized by `deployer` (unless the `Deployer` instance /// itself is used as deployer). This way the whole operation is atomic /// and it's not possible to frontrun the contract initialization. /// /// Returns the contract address and result of the init function. pub fn deploy( env: Env, deployer: Address, wasm_hash: BytesN<32>, salt: BytesN<32>, init_fn: Symbol, init_args: Vec<Val>, ) -> (Address, Val) { // Skip authorization if deployer is the current contract. if deployer != env.current_contract_address() { deployer.require_auth(); } // Deploy the contract using the uploaded Wasm with given hash. let deployed_address = env .deployer() .with_address(deployer, salt) .deploy(wasm_hash); // Invoke the init function with the given arguments. let res: Val = env.invoke_contract(&deployed_address, &init_fn, init_args); // Return the contract ID of the deployed contract and the result of // invoking the init result. (deployed_address, res) }}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/deployerHow it Works​Contracts can deploy other contracts using the SDK deployer() method.The contract address of the deployed contract is deterministic and is derived from the address of the deployer. The deployment also has to be authorized by the deployer.Open the deployer/deployer/src/lib.rs file to follow along.Contract Wasm Upload​Before deploying the new contract instances, the Wasm code needs to be uploaded on-chain. Then it can be used to deploy an arbitrary number of contract instances. The upload should typically happen outside of the deployer contract, as it needs to happen just once. However, it is possible to use env.deployer().upload_contract_wasm() function to upload Wasm from a contract as well.See the tests for an example of uploading the contract code programmatically. For the actual on-chain installation see the general deployment tutorial.Authorization​infoThis section can be skipped for factory contracts that deploy another contract from their own address (`deployer == env.current_contract_address()``).infoFor introduction to Soroban authorization see the auth tutorialWe start with verifying authorization of the deployer, unless its the current contract (at which point the authorization is implied).if deployer != env.current_contract_address() { deployer.require_auth();}While deployer().with_address() performs authorization as well, we want to make sure that deployer has also authorized the whole operation, as besides deployment it also performs atomic contract initialization. If we didn't require deployer authorization here, then it would be possible to frontrun the deployment operation performed by deployer and initialize it differently, thus breaking the promise of atomic initialization.See more details on the actual authorization payloads in tests.deployer()​The deployer() SDK function comes with a few deployment-related utilities. Here we use the most generic deployer kind, with_address(deployer_address, salt).let deployed_address = env .deployer() .with_address(deployer, salt) .deploy(wasm_hash);with_address() accepts the deployer address and salt. Both are used to derive the address of the deployed contract deterministically. It is not possible to re-deploy an already existing contract.deploy() function performs the actual deployment using the provided wasm_hash. The implementation of the new contract is defined by the Wasm file uploaded under wasm_hash.tipOnly the wasm_hash itself is stored per contract ID thus saving the ledger space and fees.When only deploying the contract on behalf of the current contract, i.e. when deployer address is always env.current_contract_address() it is possible to use deployer().with_current_contract(salt) function for brevity.Initialization​The contract can be called immediately after deployment, which is useful for initialization.let res: Val = env.invoke_contract(&deployed_address, &init_fn, init_args);invoke_contract can call any defined contract function with any arguments. We pass the actual function to call and the arguments from deploy inputs. The result can be any value, depending on the init_fn's return value.If the initialization fails, then the whole deploy call falls and thus the contract won't be deployed. This behavior is required for the atomic initialization guarantee as well.The contract returns the deployed contract's address and the result of executing the initialization function. (deployed_address, res)Tests​Open the deployer/deployer/src/test.rs file to follow along.Import the test contract Wasm to be deployed.// The contract that will be deployed by the deployer contract.mod contract { soroban_sdk::contractimport!( file = \"../contract/target/wasm32-unknown-unknown/release/soroban_deployer_test_contract.wasm\" );}That contract contains the following code that exports two functions: initialization function that takes a value and a getter function for the stored initialized value.deployer/contract/src/lib.rs#[contract]pub struct Contract;const KEY: Symbol = symbol_short!(\"value\");#[contractimpl]impl Contract { pub fn init(env: Env, value: u32) { env.storage().instance().set(&KEY, &value); } pub fn value(env: Env) -> u32 { env.storage().instance().get(&KEY).unwrap() }}This test contract will be used when testing the deployer. The deployer contract will deploys the test contract and invoke its init function.There are two tests: deployment from the current contract without authorization and deployment from an arbitrary address with authorization. Besides authorization, these tests are very similar.Curent contract deployer​In the first test we deploy contract from the Deployer contract instance itself.#[test]fn test_deploy_from_contract() { let env = Env::default(); let deployer_client = DeployerClient::new(&env, &env.register_contract(None, Deployer)); // Upload the Wasm to be deployed from the deployer contract. // This can also be called from within a contract if needed. let wasm_hash = env.deployer().upload_contract_wasm(contract::WASM); // Deploy contract using deployer, and include an init function to call. let salt = BytesN::from_array(&env, &[0; 32]); let init_fn = symbol_short!(\"init\"); let init_fn_args: Vec<Val> = (5u32,).into_val(&env); let (contract_id, init_result) = deployer_client.deploy( &deployer_client.address, &wasm_hash, &salt, &init_fn, &init_fn_args, ); assert!(init_result.is_void()); // No authorizations needed - the contract acts as a factory. assert_eq!(env.auths(), vec![]); // Invoke contract to check that it is initialized. let client = contract::Client::new(&env, &contract_id); let sum = client.value(); assert_eq!(sum, 5);}In any test the first thing that is always required is an Env, which is the Soroban environment that the contract will run in.let env = Env::default();Register the deployer contract with the environment and create a client to for it.let deployer_client = DeployerClient::new(&env, &env.register_contract(None, Deployer));Upload the code of the test contract that we have imported above via contractimport! and get the hash of the uploaded Wasm code.let wasm_hash = env.deployer().upload_contract_wasm(contract::WASM);The client is used to invoke the deploy function. The contract will deploy the test contract using the hash of its Wasm code, call the init function, and pass in a single 5u32 argument. The expected return value of init function is just void (i.e. no value).let salt = BytesN::from_array(&env, &[0; 32]);let init_fn = symbol_short!(\"init\");let init_fn_args: Vec<Val> = (5u32,).into_val(&env);let (contract_id, init_result) = deployer_client.deploy( &deployer_client.address, &wasm_hash, &salt, &init_fn, &init_fn_args,);The test checks that the test contract was deployed by using its client to invoke it and get back the value set during initialization.let client = contract::Client::new(&env, &contract_id);let sum = client.value();assert_eq!(sum, 5);External deployer​The second test is very similar to the first one.#[test]fn test_deploy_from_address() { let env = Env::default(); let deployer_client = DeployerClient::new(&env, &env.register_contract(None, Deployer)); // Upload the Wasm to be deployed from the deployer contract. // This can also be called from within a contract if needed. let wasm_hash = env.deployer().upload_contract_wasm(contract::WASM); // Define a deployer address that needs to authorize the deployment. let deployer = Address::random(&env); // Deploy contract using deployer, and include an init function to call. let salt = BytesN::from_array(&env, &[0; 32]); let init_fn = symbol_short!(\"init\"); let init_fn_args: Vec<Val> = (5u32,).into_val(&env); env.mock_all_auths(); let (contract_id, init_result) = deployer_client.deploy(&deployer, &wasm_hash, &salt, &init_fn, &init_fn_args); assert!(init_result.is_void()); let expected_auth = AuthorizedInvocation { // Top-level authorized function is `deploy` with all the arguments. function: AuthorizedFunction::Contract(( deployer_client.address, symbol_short!(\"deploy\"), ( deployer.clone(), wasm_hash.clone(), salt, init_fn, init_fn_args, ) .into_val(&env), )), // From `deploy` function the 'create contract' host function has to be // authorized. sub_invocations: vec![AuthorizedInvocation { function: AuthorizedFunction::CreateContractHostFn(CreateContractArgs { contract_id_preimage: ContractIdPreimage::Address(ContractIdPreimageFromAddress { address: deployer.clone().try_into().unwrap(), salt: Uint256([0; 32]), }), executable: xdr::ContractExecutable::Wasm(xdr::Hash(wasm_hash.into_val(&env))), }), sub_invocations: vec![], }], }; assert_eq!(env.auths(), vec![(deployer, expected_auth)]); // Invoke contract to check that it is initialized. let client = contract::Client::new(&env, &contract_id); let sum = client.value(); assert_eq!(sum, 5);}The main difference is that the contract is deployed on behalf of the arbitrary address.// Define a deployer address that needs to authorize the deployment.let deployer = Address::random(&env);Before invoking the contract we need to enable mock authorization in order to get the recorded authorization payload that we can verify.env.mock_all_auths();let (contract_id, init_result) = deployer_client.deploy(&deployer, &wasm_hash, &salt, &init_fn, &init_fn_args);The expected authorization tree for the deployer looks as follows.let expected_auth = AuthorizedInvocation { // Top-level authorized function is `deploy` with all the arguments. function: AuthorizedFunction::Contract(( deployer_client.address, symbol_short!(\"deploy\"), ( deployer.clone(), wasm_hash.clone(), salt, init_fn, init_fn_args, ) .into_val(&env), )), // From `deploy` function the 'create contract' host function has to be // authorized. sub_invocations: vec![AuthorizedInvocation { function: AuthorizedFunction::CreateContractHostFn(CreateContractArgs { contract_id_preimage: ContractIdPreimage::Address(ContractIdPreimageFromAddress { address: deployer.clone().try_into().unwrap(), salt: Uint256([0; 32]), }), executable: xdr::ContractExecutable::Wasm(xdr::Hash(wasm_hash.into_val(&env))), }), sub_invocations: vec![], }],};At the top level we have the deploy function itself with all the arguments that we've passed to it. From the deploy function the CreateContractHostFn has to be authorized. This is the authorization payload that has to be authorized by any deployer in any context. It contains the deployer address, salt and executable.This authorization tree proves that the deployment and initialization are authorized atomically: actual deployment happens within the context of deploy and all of salt, executable, and initialization arguments are authorized together (i.e. there is one signature to authorizes this exact combination).Then we make sure that deployer has authorized the expected tree and that expected value has been stored.assert_eq!(env.auths(), vec![(deployer, expected_auth)]);let client = contract::Client::new(&env, &contract_id);let sum = client.value();assert_eq!(sum, 5);Build the Contracts​To build the contract into a .wasm file, use the soroban contract build command. Build both the deployer contract and the test contract.soroban contract buildBoth .wasm files should be found in both contract target directories after building both contracts:target/wasm32-unknown-unknown/release/soroban_deployer_contract.wasmtarget/wasm32-unknown-unknown/release/soroban_deployer_test_contract.wasmRun the Contract​If you have soroban-cli installed, you can invoke the contract function to deploy the test contract.Before deploying the test contract with the deployer, install the test contract Wasm using the install command. The install command will print out the hash derived from the Wasm file (it's not just the hash of the Wasm file itself though) which should be used by the deployer.soroban contract install --wasm contract/target/wasm32-unknown-unknown/release/soroban_deployer_test_contract.wasmThe command prints out the hash as hex. It will look something like 7792a624b562b3d9414792f5fb5d72f53b9838fef2ed9a901471253970bc3b15.We also need to deploy the Deployer contract:soroban contract deploy --wasm deployer/target/wasm32-unknown-unknown/release/soroban_deployer_contract.wasm --id 1This will return the deployer address: CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD2KM.Then the deployer contract may be invoked with the Wasm hash value above.soroban contract invoke --id 1 -- deploy \\ --deployer CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD2KM --salt 123 \\ --wasm_hash 7792a624b562b3d9414792f5fb5d72f53b9838fef2ed9a901471253970bc3b15 \\ --init_fn init \\ --init_args '[{\"u32\":5}]'And then invoke the deployed test contract using the identifier returned from the previous command.soroban contract invoke \\ --id ead19f55aec09bfcb555e09f230149ba7f72744a5fd639804ce1e934e8fe9c5d \\ -- \\ valueThe following output should occur using the code above.5","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/deployer","title":"Deployer","contentLength":2025}},{"pageContent":"AllocatorThe allocator example demonstrates how to utilize the allocator feature when writing a contract.The soroban-sdk crate provides a lightweight bump-pointer allocator which can be used to emulate heap memory allocation in a Wasm smart contract.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example, navigate to the alloc directory, and use cargo test.cd alloccargo testYou should see the output:running 1 testtest test::test ... okDependencies​This example depends on the alloc feature in soroban-sdk. To include it, add \"alloc\" to the \"features\" list of soroban-sdk in the Cargo.toml file:alloc/Cargo.toml[dependencies]soroban-sdk = { version = \"0.9.2\", features = [\"alloc\"] }[dev_dependencies]soroban-sdk = { version = \"0.9.2\", features = [\"testutils\", \"alloc\"] }Code​alloc/src/lib.rs#![no_std]use soroban_sdk::{contractimpl, Env};extern crate alloc;#[contract]pub struct AllocContract;#[contractimpl]impl AllocContract { /// Allocates a temporary vector holding values (0..count), then computes and returns their sum. pub fn sum(_env: Env, count: u32) -> u32 { let mut v1 = alloc::vec![]; (0..count).for_each(|i| v1.push(i)); let mut sum = 0; for i in v1 { sum += i; } sum }}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/allocHow it Works​extern crate alloc;Imports the alloc crate, which is required in order to support allocation under no_std. See Contract Rust dialect for more info about no_std.let mut v1 = alloc::vec![];Creates a contiguous growable array v1 with contents allocated on the heap memory.infoThe heap memory in the context of a smart contract actually refers to the Wasm linear memory. The alloc will use the global allocator provided by the soroban sdk to interact with the linear memory.cautionUsing heap allocated array is typically slow and computationally expensive. Try to avoid it and instead use a fixed-sized array or soroban_sdk::vec! whenever possible.This is especially the case for a large-size array. Whenever the array size grows beyond the current linear memory size, which is multiple of the page size (64KB), the wasm32::memory_grow is invoked to grow the linear memory by more pages as necessary, which is very computationally expensive.The remaining code pushes values (0..count) to v1, then computes and returns their sum. This is the simplest example to illustrate how to use the allocator.","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/alloc","title":"Allocator","contentLength":425}},{"pageContent":"MetadataThe contractmeta! macro provided in the Rust SDK allows users to write two strings - a key and a val - within a serialized SCMetaEntry::SCMetaV0 XDR object to the custom section of Wasm contracts. The section name for this metadata is contractmetav0. Developers can utilize this macro to write metadata, and tools can then read and display this information to users.The liquidity pool example provides a clear demonstration of how to use the contractmeta! macro:// Metadata that is added on to the Wasm custom sectioncontractmeta!( key = \"Description\", val = \"Constant product AMM with a .3% swap fee\");pub trait LiquidityPoolTrait {...","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/wasm-metadata","title":"Metadata","contentLength":99}},{"pageContent":"Upgrading ContractsThe upgradeable contract example demonstrates how to upgrade a Wasm contract.Code​The example contains both an \"old\" and \"new\" contract, where we upgrade from \"old\" to \"new\". The code below is for the \"old\" contract.upgradeable_contract/old_contract/src/lib.rs#![no_std]use soroban_sdk::{contractimpl, contracttype, Address, BytesN, Env};#[contracttype]#[derive(Clone)]enum DataKey { Admin,}#[contract]pub struct UpgradeableContract;#[contractimpl]impl UpgradeableContract { pub fn init(e: Env, admin: Address) { e.storage().instance().set(&DataKey::Admin, &admin); } pub fn version() -> u32 { 1 } pub fn upgrade(e: Env, new_wasm_hash: BytesN<32>) { let admin: Address = e.storage().instance().get(&DataKey::Admin).unwrap(); admin.require_auth(); e.deployer().update_current_contract_wasm(new_wasm_hash); }}How it works​The upgrade is only possible because the contract calls e.update_current_contract_wasm, with the wasm hash of the new contract as a parameter. The contract ID does not change. Note that the contract required authorization from an admin before upgrading. This is to prevent anyone from upgrading the contract. You can read more about the update_current_contract_wasm function in the Soroban Rust SDK here.pub fn upgrade(e: Env, new_wasm_hash: BytesN<32>) { let admin: Address = e.storage().instance().get(&DataKey::Admin).unwrap(); admin.require_auth(); e.deployer().update_current_contract_wasm(new_wasm_hash);}The update_current_contract_wasm host function will also emit a SYSTEM contract event that contains the old and new wasm reference, allowing downstream users to be notified when a contract they use is updated. The event structure will have topics = [\"executable_update\", old_executable: ContractExecutable, old_executable: ContractExecutable] and data = [].Tests​Open the upgradeable_contract/old_contract/src/test.rs file to follow along.upgradeable_contract/old_contract/srctest.rs#![cfg(test)]use soroban_sdk::{testutils::Address as _, Address, BytesN, Env};mod old_contract { soroban_sdk::contractimport!( file = \"target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_old_contract.wasm\" );}mod new_contract { soroban_sdk::contractimport!( file = \"../new_contract/target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_new_contract.wasm\" );}fn install_new_wasm(e: &Env) -> BytesN<32> { e.install_contract_wasm(new_contract::Wasm)}#[test]fn test() { let env = Env::default(); env.mock_all_auths(); // Note that we use register_contract_wasm instead of register_contract // because the old contracts Wasm is expected to exist in storage. let contract_id = env.register_contract_wasm(None, old_contract::Wasm); let client = old_contract::Client::new(&env, &contract_id); let admin = Address::random(&env); client.init(&admin); assert_eq!(1, client.version()); let new_wasm_hash = install_new_wasm(&env); client.upgrade(&new_wasm_hash); assert_eq!(2, client.version()); // new_v2_fn was added in the new contract, so the existing // client is out of date. Generate a new one. let client = new_contract::Client::new(&env, &contract_id); assert_eq!(1010101, client.new_v2_fn());}We first import wasm files for both contracts -mod old_contract { soroban_sdk::contractimport!( file = \"target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_old_contract.wasm\" );}mod new_contract { soroban_sdk::contractimport!( file = \"../new_contract/target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_new_contract.wasm\" );}We register the old contract, intialize it with an admin, and verify the version it reutrns. The note in the code below is important-// Note that we use register_contract_wasm instead of register_contract// because the old contracts Wasm is expected to exist in storage.let contract_id = env.register_contract_wasm(None, old_contract::Wasm);let client = old_contract::Client::new(&env, &contract_id);let admin = Address::random(&env);client.init(&admin);assert_eq!(1, client.version());We install the new contract's Wasmlet new_wasm_hash = install_new_wasm(&env);Then we run the upgrade, and verify that the upgrade worked.client.upgrade(&new_wasm_hash);assert_eq!(2, client.version());Build the Contract​To build the contract .wasm files, run soroban contract build in both upgradeable_contract/old_contract and upgradeable_contract/new_contract in that order.Both .wasm files should be found in both contract target directories after building both contracts:target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_old_contract.wasmtarget/wasm32-unknown-unknown/release/soroban_upgradeable_contract_new_contract.wasmRun the Contract​If you have soroban-cli installed, you can invoke contract functions. Deploy the old contract and install the wasm for the new contract.soroban contract deploy \\ --wasm target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_old_contract.wasm \\ --id asoroban contract install \\ --wasm target/wasm32-unknown-unknown/release/soroban_upgradeable_contract_new_contract.wasmYou should see this Wasm hash from the install command:c30c71a382438ed7e56669ba172aa862cc813d093b8d2f45e85b47ba38a89ddcYou also need to call the init method so the admin is set. This requires us to setup som identities.soroban config identity generate acc1 && \\soroban config identity address acc1Example output:GAJGHZ44IJXYFNOVRZGBCVKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6BNow call init with this key (make sure to substitute with the key you generated).soroban contract invoke \\ --id a \\ -- \\ init \\ --admin GAJGHZ44IJXYFNOVRZGBCVKC2V62DB2KHZB7BEMYOWOLFQH4XP2TAM6BInvoke the version function.soroban contract invoke \\ --id a \\ -- \\ versionThe following output should occur using the code above.1Now upgrade the contract. Notice the --source must be the identity name matching the address passed to the init function.soroban contract invoke \\ --source acc1 \\ --id a \\ -- \\ upgrade \\ --new_wasm_hash c30c71a382438ed7e56669ba172aa862cc813d093b8d2f45e85b47ba38a89ddcInvoke the version function again.soroban contract invoke \\ --id a \\ -- \\ versionNow that the contract was upgraded, you'll see a new version.2","metadata":{"source":"https://soroban.stellar.org/docs/basic-tutorials/upgrading-contracts","title":"Upgrading Contracts","contentLength":758}},{"pageContent":"TokensThe token example demonstrates how to write a token contract that implements the Token Interface.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example, navigate to the hello_world directory, and use cargo test.cd tokencargo testYou should see the output:running 8 teststest test::initialize_already_initialized - should panic ... oktest test::transfer_spend_deauthorized - should panic ... oktest test::decimal_is_over_max - should panic ... oktest test::test_burn ... oktest test::transfer_receive_deauthorized - should panic ... oktest test::transfer_from_insufficient_allowance - should panic ... oktest test::transfer_insufficient_balance - should panic ... oktest test::test ... okCode​noteThe source code for this token example is broken into several smaller modules. This is a common design pattern for more complex smart contracts.libadminallowancebalancecontracteventmetadatastorage_typestoken/src/lib.rs#![no_std]mod admin;mod allowance;mod balance;mod contract;mod event;mod metadata;mod storage_types;mod test;pub use crate::contract::TokenClient;token/src/admin.rsuse crate::storage_types::DataKey;use soroban_sdk::{Address, Env, symbol_short};pub fn has_administrator(e: &Env) -> bool { let key = DataKey::Admin; e.storage().instance().has(&key)}pub fn read_administrator(e: &Env) -> Address { let key = DataKey::Admin; e.storage().instance().get(&key).unwrap()}pub fn write_administrator(e: &Env, id: &Address) { let key = DataKey::Admin; e.storage().instance().set(&key, id);}token/src/allowance.rsuse crate::storage_types::{AllowanceDataKey, AllowanceValue, DataKey};use soroban_sdk::{Address, Env};pub fn read_allowance(e: &Env, from: Address, spender: Address) -> AllowanceValue { let key = DataKey::Allowance(AllowanceDataKey { from, spender }); if let Some(allowance) = e.storage().temporary().get::<_, AllowanceValue>(&key) { if allowance.expiration_ledger < e.ledger().sequence() { AllowanceValue { amount: 0, expiration_ledger: allowance.expiration_ledger, } } else { allowance } } else { AllowanceValue { amount: 0, expiration_ledger: 0, } }}pub fn write_allowance( e: &Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32,) { let allowance = AllowanceValue { amount, expiration_ledger, }; if amount > 0 && expiration_ledger < e.ledger().sequence() { panic!(\"expiration_ledger is less than ledger seq when amount > 0\") } let key = DataKey::Allowance(AllowanceDataKey { from, spender }); e.storage().temporary().set(&key.clone(), &allowance); if amount > 0 { e.storage().temporary().bump( &key, expiration_ledger .checked_sub(e.ledger().sequence()) .unwrap(), ) }}pub fn spend_allowance(e: &Env, from: Address, spender: Address, amount: i128) { let allowance = read_allowance(e, from.clone(), spender.clone()); if allowance.amount < amount { panic!(\"insufficient allowance\"); } write_allowance( e, from, spender, allowance.amount - amount, allowance.expiration_ledger, );}token/src/balance.rsuse crate::storage_types::DataKey;use soroban_sdk::{Address, Env};pub fn read_balance(e: &Env, addr: Address) -> i128 { let key = DataKey::Balance(addr); if let Some(balance) = e.storage().persistent().get::<DataKey, i128>(&key) { balance } else { 0 }}fn write_balance(e: &Env, addr: Address, amount: i128) { let key = DataKey::Balance(addr); e.storage().persistent().set(&key, &amount);}pub fn receive_balance(e: &Env, addr: Address, amount: i128) { let balance = read_balance(e, addr.clone()); if !is_authorized(e, addr.clone()) { panic!(\"can't receive when deauthorized\"); } write_balance(e, addr, balance + amount);}pub fn spend_balance(e: &Env, addr: Address, amount: i128) { let balance = read_balance(e, addr.clone()); if !is_authorized(e, addr.clone()) { panic!(\"can't spend when deauthorized\"); } if balance < amount { panic!(\"insufficient balance\"); } write_balance(e, addr, balance - amount);}pub fn is_authorized(e: &Env, addr: Address) -> bool { let key = DataKey::State(addr); if let Some(state) = e.storage().persistent().get::<DataKey, bool>(&key) { state } else { true }}pub fn write_authorization(e: &Env, addr: Address, is_authorized: bool) { let key = DataKey::State(addr); e.storage().persistent().set(&key, &is_authorized);}token/src/contract.rs//! This contract demonstrates a sample implementation of the Soroban token//! interface.use crate::admin::{has_administrator, read_administrator, write_administrator};use crate::allowance::{read_allowance, spend_allowance, write_allowance};use crate::balance::{is_authorized, write_authorization};use crate::balance::{read_balance, receive_balance, spend_balance};use crate::event;use crate::metadata::{read_decimal, read_name, read_symbol, write_metadata};use soroban_sdk::{contractimpl, Address, String, Env};use soroban_token_sdk::TokenMetadata;pub trait TokenTrait { fn initialize(e: Env, admin: Address, decimal: u32, name: String, symbol: String); fn allowance(e: Env, from: Address, spender: Address) -> i128; fn approve(e: Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32); fn balance(e: Env, id: Address) -> i128; fn spendable_balance(e: Env, id: Address) -> i128; fn authorized(e: Env, id: Address) -> bool; fn transfer(e: Env, from: Address, to: Address, amount: i128); fn transfer_from(e: Env, spender: Address, from: Address, to: Address, amount: i128); fn burn(e: Env, from: Address, amount: i128); fn burn_from(e: Env, spender: Address, from: Address, amount: i128); fn clawback(e: Env, from: Address, amount: i128); fn set_authorized(e: Env, id: Address, authorize: bool); fn mint(e: Env, to: Address, amount: i128); fn set_admin(e: Env, new_admin: Address); fn decimals(e: Env) -> u32; fn name(e: Env) -> String; fn symbol(e: Env) -> String;}fn check_nonnegative_amount(amount: i128) { if amount < 0 { panic!(\"negative amount is not allowed: {}\", amount) }}#[contract]pub struct Token;#[contractimpl]impl TokenTrait for Token { fn initialize(e: Env, admin: Address, decimal: u32, name: String, symbol: String) { if has_administrator(&e) { panic!(\"already initialized\") } write_administrator(&e, &admin); if decimal > u8::MAX.into() { panic!(\"Decimal must fit in a u8\"); } write_metadata( &e, TokenMetadata { decimal, name, symbol, }, ) } fn allowance(e: Env, from: Address, spender: Address) -> i128 { read_allowance(&e, from, spender) } fn approve(e: Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32) { from.require_auth(); check_nonnegative_amount(amount); write_allowance(&e, from.clone(), spender.clone(), amount, expiration_ledger); event::approve(&e, from, spender, amount, expiration_ledger); } fn balance(e: Env, id: Address) -> i128 { read_balance(&e, id) } fn spendable_balance(e: Env, id: Address) -> i128 { read_balance(&e, id) } fn authorized(e: Env, id: Address) -> bool { is_authorized(&e, id) } fn transfer(e: Env, from: Address, to: Address, amount: i128) { from.require_auth(); check_nonnegative_amount(amount); spend_balance(&e, from.clone(), amount); receive_balance(&e, to.clone(), amount); event::transfer(&e, from, to, amount); } fn transfer_from(e: Env, spender: Address, from: Address, to: Address, amount: i128) { spender.require_auth(); check_nonnegative_amount(amount); spend_allowance(&e, from.clone(), spender, amount); spend_balance(&e, from.clone(), amount); receive_balance(&e, to.clone(), amount); event::transfer(&e, from, to, amount) } fn burn(e: Env, from: Address, amount: i128) { from.require_auth(); check_nonnegative_amount(amount); spend_balance(&e, from.clone(), amount); event::burn(&e, from, amount); } fn burn_from(e: Env, spender: Address, from: Address, amount: i128) { spender.require_auth(); check_nonnegative_amount(amount); spend_allowance(&e, from.clone(), spender, amount); spend_balance(&e, from.clone(), amount); event::burn(&e, from, amount) } fn clawback(e: Env, from: Address, amount: i128) { check_nonnegative_amount(amount); let admin = read_administrator(&e); admin.require_auth(); spend_balance(&e, from.clone(), amount); event::clawback(&e, admin, from, amount); } fn set_authorized(e: Env, id: Address, authorize: bool) { let admin = read_administrator(&e); admin.require_auth(); write_authorization(&e, id.clone(), authorize); event::set_authorized(&e, admin, id, authorize); } fn mint(e: Env, to: Address, amount: i128) { check_nonnegative_amount(amount); let admin = read_administrator(&e); admin.require_auth(); receive_balance(&e, to.clone(), amount); event::mint(&e, admin, to, amount); } fn set_admin(e: Env, new_admin: Address) { let admin = read_administrator(&e); admin.require_auth(); write_administrator(&e, &new_admin); event::set_admin(&e, admin, new_admin); } fn decimals(e: Env) -> u32 { read_decimal(&e) } fn name(e: Env) -> Bytes { read_name(&e) } fn symbol(e: Env) -> Bytes { read_symbol(&e) }}token/src/event.rsuse soroban_sdk::{Address, Env, Symbol, symbol_short};pub(crate) fn approve(e: &Env, from: Address, to: Address, amount: i128, expiration_ledger: u32) { let topics = (Symbol::new(e, \"approve\"), from, to); e.events().publish(topics, (amount, expiration_ledger));}pub(crate) fn transfer(e: &Env, from: Address, to: Address, amount: i128) { let topics = (symbol_short!(\"transfer\"), from, to); e.events().publish(topics, amount);}pub(crate) fn mint(e: &Env, admin: Address, to: Address, amount: i128) { let topics = (symbol_short!(\"mint\"), admin, to); e.events().publish(topics, amount);}pub(crate) fn clawback(e: &Env, admin: Address, from: Address, amount: i128) { let topics = (symbol_short!(\"clawback\"), admin, from); e.events().publish(topics, amount);}pub(crate) fn set_authorized(e: &Env, admin: Address, id: Address, authorize: bool) { let topics = (Symbol::new(e, \"set_authorized\"), admin, id); e.events().publish(topics, authorize);}pub(crate) fn set_admin(e: &Env, admin: Address, new_admin: Address) { let topics = (symbol_short!(\"set_admin\"), admin); e.events().publish(topics, new_admin);}pub(crate) fn burn(e: &Env, from: Address, amount: i128) { let topics = (symbol_short!(\"burn\"), from); e.events().publish(topics, amount);}token/src/metadata.rsuse soroban_sdk::{Bytes, Env};use soroban_token_sdk::{TokenMetadata, TokenUtils};pub fn read_decimal(e: &Env) -> u32 { let util = TokenUtils::new(e); util.get_metadata_unchecked().unwrap().decimal}pub fn read_name(e: &Env) -> Bytes { let util = TokenUtils::new(e); util.get_metadata_unchecked().unwrap().name}pub fn read_symbol(e: &Env) -> Bytes { let util = TokenUtils::new(e); util.get_metadata_unchecked().unwrap().symbol}pub fn write_metadata(e: &Env, metadata: TokenMetadata) { let util = TokenUtils::new(e); util.set_metadata(&metadata);}token/src/storage_types.rsuse soroban_sdk::{contracttype, Address};#[derive(Clone)]#[contracttype]pub struct AllowanceDataKey { pub from: Address, pub spender: Address,}#[contracttype]pub struct AllowanceValue { pub amount: i128, pub expiration_ledger: u32,}#[derive(Clone)]#[contracttype]pub enum DataKey { Allowance(AllowanceDataKey), Balance(Address), Nonce(Address), State(Address), Admin,}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/tokenHow it Works​Tokens created on a smart contract platform can take many different forms, include a variety of different functionalities, and meet very different needs or use-cases. While each token can fulfill a unique niche, there are some \"normal\" features that almost all tokens will need to make use of (e.g., payments, transfers, balance queries, etc.). In an effort to minimize repetition and streamline token deployments, Soroban implements the Token Interface, which provides a uniform, predictable interface for developers and users.Creating a Soroban token from an existing Stellar asset is very easy, and the wrapped token makes use of the Stellar Asset Contract (more on that later). This example contract, however, demonstrates how a smart contract token might be constructed that doesn't take advantage of the Stellar Asset Contract, but does still satisfy the commonly used Token Interface to maximize interoperability.Separation of Functionality​You have likely noticed that this example contract is broken into discrete modules, with each one responsible for a siloed set of functionality. This common practice helps to organize the code and make it more maintainable.For example, most of the token logic exists in the contract.rs module. Functions like mint, burn, transfer, etc. are written and programmed in that file. The Token Interface describes how some of these functions should emit events when they occur. However, keeping all that event-emitting logic bundled in with the rest of the contract code could make it harder to track what is happening in the code, and that confusion could ultimately lead to errors.Instead, we have a separate events.rs module that takes away all the headache of emitting events when other functions run. Here is the function to emit an event whenever the token is minted:pub(crate) fn mint(e: &Env, admin: Address, to: Address, amount: i128) { let topics = (symbol_short!(\"mint\"), admin, to); e.events().publish(topics, amount);}Admittedly, this is a simple example, but constructing the contract this way makes it very clear to the developer what is happening and where. This function is then used by the contract.rs module whenever the mint function is invoked:// earlier in `contract.rs`use crate::event;fn mint(e: Env, to: Address, amount: i128) { check_nonnegative_amount(amount); let admin = read_administrator(&e); admin.require_auth(); receive_balance(&e, to.clone(), amount); event::mint(&e, admin, to, amount);}This same convention is used to separate from the \"main\" contract code the metadata for the token, the storage type definitions, etc.Standardized Interface, Customized Behavior​This example contract follows the standardized Token Interface, implementing all of the same functions as the Stellar Asset Contract. This gives wallets, users, developers, etc. a predictable interface to interact with the token. Even though we are implementing the same interface of functions, that doesn't mean we have to implement the same behavior inside those functions. While this example contract doesn't actually modify any of the functions that would be present in a deployed instance of the Stellar Asset Contract, that possibility remains open to the contract developer.By way of example, perhaps you have an NFT project, and the artist wants to have a small royalty paid every time their token transfers hands:// This is mainly the `transfer` function from `src/contract.rs`fn transfer(e: Env, from: Address, to: Address, amount: i128) { from.require_auth(); check_nonnegative_amount(amount); spend_balance(&e, from.clone(), amount); // We calculate some new amounts for payment and royalty let payment = (amount * 997) / 1000; let royalty = amount - payment receive_balance(&e, artist.clone(), royalty); receive_balance(&e, to.clone(), payment); event::transfer(&e, from, to, amount);}The transfer interface is still in use, and is still the same as other tokens, but we've customized the behavior to address a specific need. Another use-case might be a tightly controlled token that requires authentication from an admin before any transfer, allowance, etc. function could be invoked.tipOf course, you will want your token to behave in an intuitive and transparent manner. If a user is invoking a transfer, they will expect tokens to move. If an asset issuer needs to invoke a clawback they will likely require the right kind of behavior to take place.Compatibility with Stellar Assets​One of the key benefits of the Stellar network is that assets are first-class citizens. On a protocol level, asset issuers have a robust set of tools to manage the authorization and behavior of assets. Any asset that already exists on the Stellar network can also make use of the Stellar Asset Contract on the Soroban platform. All that is required is a simple, one-time action of wrapping the asset to be deployed for Soroban.At that point, the asset can use all the features of the Stellar Asset Contract that are highlighted in this example (allowance, mint, burn, etc.), while still maintaining the high-quality asset issuer features included with Stellar.Additionally, all of that comes with no contract writing required. Any asset can be easily wrapped using the Soroban-CLI:soroban lab token wrap \\ --asset USDC:GCYEIQEWOCTTSA72VPZ6LYIZIK4W4KNGJR72UADIXUXG45VDFRVCQTYEnoteA Stellar asset could be wrapped for Soroban by any user. This command will set the asset issuer account as the admin address for the Soroban token, meaning that issuer account will still maintain control over asset minting, authorization, etc.Tests​Open the token/src/test.rs file to follow along.token/src/test.rs#![cfg(test)]extern crate std;use crate::{contract::Token, TokenClient};use soroban_sdk::{testutils::Address as _, Address, Env, IntoVal, Symbol};fn create_token<'a>(e: &Env, admin: &Address) -> TokenClient<'a> { let token = TokenClient::new(e, &e.register_contract(None, Token {})); token.initialize(admin, &7, &\"name\".into_val(e), &\"symbol\".into_val(e)); token}#[test]fn test() { let e = Env::default(); e.mock_all_auths(); let admin1 = Address::random(&e); let admin2 = Address::random(&e); let user1 = Address::random(&e); let user2 = Address::random(&e); let user3 = Address::random(&e); let token = create_token(&e, &admin1); token.mint(&user1, &1000); assert_eq!( e.auths(), std::vec![( admin1.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), symbol_short!(\"mint\"), (&user1, 1000_i128).into_val(&e), )), sub_invocations: std::vec![] } )] ); assert_eq!(token.balance(&user1), 1000); token.approve(&user2, &user3, &500, &200); assert_eq!( e.auths(), std::vec![( user2.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), symbol_short!(\"approve\"), (&user2, &user3, 500_i128, 200_u32).into_val(&e), )), sub_invocations: std::vec![] } )] ); assert_eq!(token.allowance(&user2, &user3), 500); token.transfer(&user1, &user2, &600); assert_eq!( e.auths(), std::vec![( user1.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), symbol_short!(\"transfer\"), (&user1, &user2, 600_i128).into_val(&e), )), sub_invocations: std::vec![] } )] ); assert_eq!(token.balance(&user1), 400); assert_eq!(token.balance(&user2), 600); token.transfer_from(&user3, &user2, &user1, &400); assert_eq!( e.auths(), std::vec![( user3.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), Symbol::new(&e, \"transfer_from\"), (&user3, &user2, &user1, 400_i128).into_val(&e), )), sub_invocations: std::vec![] } )] ); assert_eq!(token.balance(&user1), 800); assert_eq!(token.balance(&user2), 200); token.transfer(&user1, &user3, &300); assert_eq!(token.balance(&user1), 500); assert_eq!(token.balance(&user3), 300); token.set_admin(&admin2); assert_eq!( e.auths(), std::vec![( admin1.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), symbol_short!(\"set_admin\"), (&admin2,).into_val(&e), )), sub_invocations: std::vec![] } )] ); token.set_authorized(&user2, &false); assert_eq!( e.auths(), std::vec![( admin2.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), Symbol::new(&e, \"set_authorized\"), (&user2, false).into_val(&e), )), sub_invocations: std::vec![] } )] ); assert_eq!(token.authorized(&user2), false); token.set_authorized(&user3, &true); assert_eq!(token.authorized(&user3), true); token.clawback(&user3, &100); assert_eq!( e.auths(), std::vec![( admin2.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), symbol_short!(\"clawback\"), (&user3, 100_i128).into_val(&e), )), sub_invocations: std::vec![] } )] ); assert_eq!(token.balance(&user3), 200); // Set allowance to 500 token.approve(&user2, &user3, &500, &200); assert_eq!(token.allowance(&user2, &user3), 500); token.approve(&user2, &user3, &0, &200); assert_eq!( e.auths(), std::vec![( user2.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), symbol_short!(\"approve\"), (&user2, &user3, 0_i128, 200_u32).into_val(&e), )), sub_invocations: std::vec![] } )] ); assert_eq!(token.allowance(&user2, &user3), 0);}#[test]fn test_burn() { let e = Env::default(); e.mock_all_auths(); let admin = Address::random(&e); let user1 = Address::random(&e); let user2 = Address::random(&e); let token = create_token(&e, &admin); token.mint(&user1, &1000); assert_eq!(token.balance(&user1), 1000); token.approve(&user1, &user2, &500, &200); assert_eq!(token.allowance(&user1, &user2), 500); token.burn_from(&user2, &user1, &500); assert_eq!( e.auths(), std::vec![( user2.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), symbol_short!(\"burn_from\"), (&user2, &user1, 500_i128).into_val(&e), )), sub_invocations: std::vec![] } )] ); assert_eq!(token.allowance(&user1, &user2), 0); assert_eq!(token.balance(&user1), 500); assert_eq!(token.balance(&user2), 0); token.burn(&user1, &500); assert_eq!( e.auths(), std::vec![( user1.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), symbol_short!(\"burn\"), (&user1, 500_i128).into_val(&e), )), sub_invocations: std::vec![] } )] ); assert_eq!(token.balance(&user1), 0); assert_eq!(token.balance(&user2), 0);}#[test]#[should_panic(expected = \"insufficient balance\")]fn transfer_insufficient_balance() { let e = Env::default(); e.mock_all_auths(); let admin = Address::random(&e); let user1 = Address::random(&e); let user2 = Address::random(&e); let token = create_token(&e, &admin); token.mint(&user1, &1000); assert_eq!(token.balance(&user1), 1000); token.transfer(&user1, &user2, &1001);}#[test]#[should_panic(expected = \"can't receive when deauthorized\")]fn transfer_receive_deauthorized() { let e = Env::default(); e.mock_all_auths(); let admin = Address::random(&e); let user1 = Address::random(&e); let user2 = Address::random(&e); let token = create_token(&e, &admin); token.mint(&user1, &1000); assert_eq!(token.balance(&user1), 1000); token.set_authorized(&user2, &false); token.transfer(&user1, &user2, &1);}#[test]#[should_panic(expected = \"can't spend when deauthorized\")]fn transfer_spend_deauthorized() { let e = Env::default(); e.mock_all_auths(); let admin = Address::random(&e); let user1 = Address::random(&e); let user2 = Address::random(&e); let token = create_token(&e, &admin); token.mint(&user1, &1000); assert_eq!(token.balance(&user1), 1000); token.set_authorized(&user1, &false); token.transfer(&user1, &user2, &1);}#[test]#[should_panic(expected = \"insufficient allowance\")]fn transfer_from_insufficient_allowance() { let e = Env::default(); e.mock_all_auths(); let admin = Address::random(&e); let user1 = Address::random(&e); let user2 = Address::random(&e); let user3 = Address::random(&e); let token = create_token(&e, &admin); token.mint(&user1, &1000); assert_eq!(token.balance(&user1), 1000); token.approve(&user1, &user3, &100, &200); assert_eq!(token.allowance(&user1, &user3), 100); token.transfer_from(&user3, &user1, &user2, &101);}#[test]#[should_panic(expected = \"already initialized\")]fn initialize_already_initialized() { let e = Env::default(); let admin = Address::random(&e); let token = create_token(&e, &admin); token.initialize(&admin, &10, &\"name\".into_val(&e), &\"symbol\".into_val(&e));}#[test]#[should_panic(expected = \"Decimal must fit in a u8\")]fn decimal_is_over_max() { let e = Env::default(); let admin = Address::random(&e); let token = TokenClient::new(&e, &e.register_contract(None, Token {})); token.initialize( &admin, &(u32::from(u8::MAX) + 1), &\"name\".into_val(&e), &\"symbol\".into_val(&e), );}The token example implements eight different tests to cover a wide array of potential behaviors and problems. However, all of the tests start with a few common pieces. In any test, the first thing that is always required is an Env, which is the Soroban environment that the contract will run in.let e = Env::default();We mock authentication checks in the tests, which allows the tests to proceed as if all users/addresses/contracts/etc. had successfully authenticated.e.mock_all_auths();We're also using a create_token function to ease the repetition of having to register and initialize our token contract. The resulting token client is then used to invoke the contract during each test.// It is defined at the top of the file...fn create_token<'a>(e: &Env, admin: &Address) -> TokenClient<'a> { let token = TokenClient::new(e, &e.register_contract(None, Token {})); token.initialize(admin, &7, &\"name\".into_val(e), &\"symbol\".into_val(e)); token}// ... and it is used inside each testlet token = create_token(&e, &admin);All public functions within an impl block that has been annotated with the #[contractimpl] attribute will have a corresponding function in the test's generated client type. The client type will be named the same as the contract type with Client appended. For example, in our contract, the contract type is named Token, and the client type is named TokenClient.The eight tests created for this example contract test a range of possible conditions and ensure the contract responds appropriately to each one:test() - This function makes use of a variety of the built-in token functions to test the \"predictable\" way an asset might be interacted with by a user, as well as an administrator.test_burn() - This function ensures a burn() invocation decreases a user's balance, and that a burn_from() invocation decreases a user's balance as well as consuming another user's allowance of that balance.transfer_insufficient_balance() - This function ensures a transfer() invocation panics when the from user doesn't have the balance to cover it.transfer_receive_deauthorized() - This function ensures a user who is specifically de-authorized to hold the token cannot be the beneficiary of a transfer() invocation.transfer_spend_deauthorized() - This function ensures a user with a token balance, who is subsequently de-authorized cannot be the source of a transfer() invocation.transfer_from_insufficient_allowance() - This function ensures a user with an existing allowance for someone else's balance cannot make a transfer() greater than that allowance.initialize_already_initialized() - This function checks that the contract cannot have it's initialize() function invoked a second time.decimal_is_over_max() - This function tests that invoking initialize() with too high of a decimal precision will not succeed.Build the Contract​To build the contract, use the soroban contract build command.soroban contract buildA .wasm file should be outputted in the target directory:target/wasm32-unknown-unknown/release/soroban_token_contract.wasmRun the Contract​If you have soroban-cli installed, you can invoke contract functions using it.soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/soroban_token_contract.wasm \\ --id 1 \\ -- \\ balance \\ --id GBZV3NONYSUDVTEHATQO4BCJVFXJO3XQU5K32X3XREVZKSMMOZFO4ZXR","metadata":{"source":"https://soroban.stellar.org/docs/advanced-tutorials/tokens","title":"Tokens","contentLength":3667}},{"pageContent":"Stellar Asset ContractThe Stellar Asset Contract is an implementation of CAP-46-6 Smart Contract Standardized Asset.cautionThe Stellar Asset Contract is in early development, has not been audited, and is intended for use in development and testing only at this stage. Report issues here.Overview​Stellar has numerous assets on its classic network, and being able to use them in Soroban would give users much more flexibility with how they can use their assets. For this reason, we introduced the Stellar Asset Contract, or SAC for short, which allows users to use their Stellar account and trustline balances in Soroban.The SAC implements the token interface, which is similar to the widely used ERC-20 token standard. This should make it easier for existing smart contract developers to get started on Stellar.Deployment​For every 'classic' asset exactly one respective Stellar Asset Contract can be deployed. It can be deployed using the InvokeHostFunctionOp with HOST_FUNCTION_TYPE_CREATE_CONTRACT and CONTRACT_ID_FROM_ASSET specified here. The resulting token will have a deterministic identifier, which will be the sha256 hash of HashIDPreimage::ENVELOPE_TYPE_CONTRACT_ID_FROM_ASSET xdr specified here.Anyone can deploy the instances of Stellar Asset Contract. Note, that the initialization of the Stellar Asset Contracts happens automatically during the deployment. Asset Issuer will have the administrative permissions after the contract has been deployed.Interacting with classic Stellar assets​The Stellar Asset Contract is the only way to interact with 'classic' Stellar assets in Soroban. 'Classic' assets include native Stellar token (lumens) and all the existing trustlines.The issuer of the asset will be the administrator of the deployed contract. Because the Native Stellar token doesn't have an issuer, it will not have an administrator either. It also cannot be burned.After the contract has been deployed, users can use their classic account (for lumens) or trustline (for other assets) balance. There are some differences depending on if you are using a classic account Address vs a contract Address (corresponding either to a regular contract or to a custom account contract). The following section references some issuer and trustline flags from Stellar classic, which you can learn more about here.Using Address::AccountThe balance must exist in a trustline (or an account for the native balance). This means the contract will not store the balance in ContractData. If the trustline or account is missing, any function that tries to interact with that balance will fail.Classic trustline semantics will be followed.Transfers will only succeed if the corresponding trustline(s) have the AUTHORIZED_FLAG set.A trustline balance can only be clawed back using the clawback contract function if the trustline has TRUSTLINE_CLAWBACK_ENABLED_FLAG set.The admin can only deauthorize a trustline if the issuer of the asset has AUTH_REVOCABLE_FLAG set. The deauthorization will fail if the issuer is missing. Note that when a trustline is deauthorized from Soroban, AUTHORIZED_FLAG is cleared and AUTHORIZED_TO_MAINTAIN_LIABILITIES_FLAG is set to avoid having to pull offers and redeeming pool shares.Transfers to the issuer account will burn the token, while transfers from the issuer account will mint.Trustline balances are stored in a 64-bit signed integer even though the interface accepts 128-bit signed integers. Any operation that attempts to send or receive an amount more than the maximum amount that can be represented by a 64-bit signed integer will fail.Using Address::ContractThe balance and authorization state will be stored in contract storage, as opposed to a trustline.AUTH_REVOCABLE_FLAG is not required to be set on the issuer to deauthorize a balance.Balances are stored in a 128-bit signed integer.A balance can only be clawed back if the issuer account had the AUTH_CLAWBACK_ENABLED_FLAG set when the balance was created. A balance is created when either an Address::Contract is on the receiving end of a successful transfer, or if the admin sets the authorization state. Read more about AUTH_CLAWBACK_ENABLED_FLAG here.Balance Authorization Required​In the Address::Contract case, if the issuer has AUTH_REQUIRED_FLAG set, then the specified Address::Contract will need to be explicitly authorized with set_auth before it can receive a balance. This logic lines up with how trustlines interact with the AUTH_REQUIRED_FLAG issuer flag, allowing asset issuers to have the same control in Soroban as they do in Stellar classic. Read more about AUTH_REQUIRED_FLAG here.Authorization semantics​See the authorization overview and auth example for general information about authorization in Soroban.The token contract contains three kinds of operations that follow the token interface:getters, such as balance, which do not change the state of the contractunprivileged mutators, such as incr_allow and xfer, which change the state of the contract but do not require special privilegesprivileged mutators, such as clawback and set_admin, which change the state of the contract but require special privilegesGetters require no authorization because they do not change the state of the contract and all contract data is public. For example, balance simply returns the balance of the specified Address without changing it.Unprivileged mutators require authorization from the Address that spends or allows spending their balance. The exceptions are xfer_from and burn_from operations where the Address that require authorization from the 'spender' entity that has got an allowance from another Address beforehand.Priviliged mutators require authorization from a specific privileged identity, known as the \"administrator\". For example, only the administrator can mint more of the token. Similarly, only the administrator can appoint a new administrator.Using Stellar Asset Contract with other contracts​From the contract perspective Stellar Asset Contract is not different from any other token that implements the Soroban token interface. The Rust SDK contains a pregenerated client for any contract that implements the token interface:use soroban_sdk::token;struct MyContract;#[contractimpl]impl MyContract { fn token_fn(e: Env, token_id: BytesN<32>) { // Create a client instance for the provided token identifier. If the // `token_id` value corresponds to an SAC contract, then SAC implementation // is used. let client = token::Client::new(&env, &token_id); // Call token operations. client.transfer(...); }}Examples​See the full examples that utilize the token contract in various ways for more details:Timelock and single offer move token via xfer to and from the contractAtomic swap uses incr_allow to transfer token on behalf of the userNotice, that these examples don't do anything to support SAC specifically.Testing​Soroban Rust SDK provides an easy way to instantiate a Stellar Asset Contract tokens using register_stellar_asset_contract. For example:let admin = Address::random();let user = Address::random();let token = TokenClient::new(e, &e.register_stellar_asset_contract(admin.clone()));token.mint(&admin, &user, &1000);See the tests in the examples above for the full test implementation.Contract Interface​This interface can be found in the SDK. It extends the common token interface.","metadata":{"source":"https://soroban.stellar.org/docs/advanced-tutorials/stellar-asset-contract","title":"Stellar Asset Contract","contentLength":1105}},{"pageContent":"Atomic SwapThe atomic swap example swaps two tokens between two authorized parties atomically while following the limits they set.This is example demonstrates advanced usage of Soroban auth framework and assumes the reader is familiar with the auth example and with Soroban token usage.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example use cargo test.cargo test -p soroban-atomic-swap-contractYou should see the output:running 1 testtest test::test_atomic_swap ... okCode​atomic_swap/src/lib.rs#[contract]pub struct AtomicSwapContract;#[contractimpl]impl AtomicSwapContract { // Swap token A for token B atomically. Settle for the minimum requested price // for each party (this is an arbitrary choice to demonstrate the usage of // allowance; full amounts could be swapped as well). pub fn swap( env: Env, a: Address, b: Address, token_a: Address, token_b: Address, amount_a: i128, min_b_for_a: i128, amount_b: i128, min_a_for_b: i128, ) { // Verify preconditions on the minimum price for both parties. if amount_b < min_b_for_a { panic!(\"not enough token B for token A\"); } if amount_a < min_a_for_b { panic!(\"not enough token A for token B\"); } // Require authorization for a subset of arguments specific to a party. // Notice, that arguments are symmetric - there is no difference between // `a` and `b` in the call and hence their signatures can be used // either for `a` or for `b` role. a.require_auth_for_args( (token_a.clone(), token_b.clone(), amount_a, min_b_for_a).into_val(&env), ); b.require_auth_for_args( (token_b.clone(), token_a.clone(), amount_b, min_a_for_b).into_val(&env), ); // Perform the swap by moving tokens from a to b and from b to a. move_token(&env, &token_a, &a, &b, amount_a, min_a_for_b); move_token(&env, &token_b, &b, &a, amount_b, min_b_for_a); }}fn move_token( env: &Env, token: &Address, from: &Address, to: &Address, max_spend_amount: i128, transfer_amount: i128,) { let token = token::Client::new(env, token); let contract_address = env.current_contract_address(); // This call needs to be authorized by `from` address. It transfers the // maximum spend amount to the swap contract's address in order to decouple // the signature from `to` address (so that parties don't need to know each // other). token.transfer(from, &contract_address, &max_spend_amount); // Transfer the necessary amount to `to`. token.transfer(&contract_address, to, &transfer_amount); // Refund the remaining balance to `from`. token.transfer( &contract_address, from, &(&max_spend_amount - &transfer_amount), );}Ref: https://github.com/stellar/soroban-examples/tree/v0.9.2/atomic_swapHow it Works​The example contract requires two Address-es to authorize their parts of the swap operation: one Address wants to sell a given amount of token A for token B at a given price and another Address wants to sell token B for token A at a given price. The contract swaps the tokens atomically, but only if the requested minimum price is respected for both parties.Open the atomic_swap/src/lib.rs file or see the code above to follow along.Swap authorization​...a.require_auth_for_args( (token_a.clone(), token_b.clone(), amount_a, min_b_for_a).into_val(&env),);b.require_auth_for_args( (token_b.clone(), token_a.clone(), amount_b, min_a_for_b).into_val(&env),);...Authorization of swap function leverages require_auth_for_args Soroban host function. Both a and b need to authorize symmetric arguments: token they sell, token they buy, amount of token they sell, minimum amount of token they want to receive. This means that a and b can be freely exchanged in the invocation arguments (as long as the respective arguments are changed too).Moving the tokens​...// Perform the swap via two token transfers.move_token(&env, token_a, &a, &b, amount_a, min_a_for_b);move_token(&env, token_b, &b, &a, amount_b, min_b_for_a);...fn move_token( env: &Env, token: &Address, from: &Address, to: &Address, max_spend_amount: i128, transfer_amount: i128,) { let token = token::Client::new(env, token); let contract_address = env.current_contract_address(); // This call needs to be authorized by `from` address. It transfers the // maximum spend amount to the swap contract's address in order to decouple // the signature from `to` address (so that parties don't need to know each // other). token.transfer(from, &contract_address, &max_spend_amount); // Transfer the necessary amount to `to`. token.transfer(&contract_address, to, &transfer_amount); // Refund the remaining balance to `from`. token.transfer( &contract_address, from, &(&max_spend_amount - &transfer_amount), );}The swap itself is implemented via two token moves: from a to b and from b to a. The token move is implemented via allowance: the users don't need to know each other in order to perform the swap, and instead they authorize the swap contract to spend the necessary amount of token on their behalf via incr_allow. Soroban auth framework makes sure that the incr_allow signatures would have the proper context, and they won't be usable outside the swap contract invocation.Tests​Open the atomic_swap/src/test.rs file to follow along.Refer to another examples for the general information on the test setup.The interesting part for this example is verification of swap authorization:contract.swap( &a, &b, &token_a.address, &token_b.address, &1000, &4500, &5000, &950,);assert_eq!( env.auths(), std::vec![ ( a.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( contract.address.clone(), symbol_short!(\"swap\"), ( token_a.address.clone(), token_b.address.clone(), 1000_i128, 4500_i128 ) .into_val(&env), )), sub_invocations: std::vec![AuthorizedInvocation { function: AuthorizedFunction::Contract(( token_a.address.clone(), symbol_short!(\"transfer\"), (a.clone(), contract.address.clone(), 1000_i128,).into_val(&env), )), sub_invocations: std::vec![] }] } ), ( b.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( contract.address.clone(), symbol_short!(\"swap\"), ( token_b.address.clone(), token_a.address.clone(), 5000_i128, 950_i128 ) .into_val(&env), )), sub_invocations: std::vec![AuthorizedInvocation { function: AuthorizedFunction::Contract(( token_b.address.clone(), symbol_short!(\"transfer\"), (b.clone(), contract.address.clone(), 5000_i128,).into_val(&env), )), sub_invocations: std::vec![] }] } ), ]);env.auths() returns all the authorizations. In the case of swap four authorizations are expected. Two for each address authorizing, because each address authorizes not only the swap, but the approve all on the token being sent.","metadata":{"source":"https://soroban.stellar.org/docs/advanced-tutorials/atomic-swap","title":"Atomic Swap","contentLength":954}},{"pageContent":"Batched Atomic SwapsThe atomic swap batching example swaps a pair of tokens between the two groups of users that authorized the swap operation from the Atomic Swap example.This contract basically batches the multiple swaps while following some simple rules to match the swap participants.Follow the comments in the code for more information.","metadata":{"source":"https://soroban.stellar.org/docs/advanced-tutorials/atomic-multi-swap","title":"Batched Atomic Swaps","contentLength":54}},{"pageContent":"TimelockThe timelock example demonstrates how to write a timelock and implements a greatly simplified claimable balance similar to the claimable balance feature available on Stellar.The contract accepts deposits of an amount of a token, and allows other users to claim it before or after a time point.","metadata":{"source":"https://soroban.stellar.org/docs/advanced-tutorials/timelock","title":"Timelock","contentLength":48}},{"pageContent":"Single Offer SaleThe single offer sale example demonstrates how to write a contract that allows a seller to set up an offer to sell token A for token B to multiple buyers. The comments in the source code explain how the contract should be used.","metadata":{"source":"https://soroban.stellar.org/docs/advanced-tutorials/single-offer-sale","title":"Single Offer Sale","contentLength":45}},{"pageContent":"Liquidity PoolThe liquidity pool example demonstrates how to write a constant product liquidity pool contract. The comments in the source code explain how the contract should be used.","metadata":{"source":"https://soroban.stellar.org/docs/advanced-tutorials/liquidity-pool","title":"Liquidity Pool","contentLength":28}},{"pageContent":"Custom AccountThe custom account example demonstrates how to implement a simple account contract that supports multisig and customizable authorization policies. This account contract can be used with the Soroban auth framework, so that any time an Address pointing at this contract instance is used, the custom logic implemented here is applied.Custom accounts are exclusive to Soroban and can't be used to perform other Stellar operations.dangerImplementing a custom account contract requires a very good understanding of authentication and authorization and requires rigorous testing and review. The example here is not a full-fledged account contract - use it as an API reference only.cautionCustom Accounts are still experimental and there is not much tooling built around them yet beyond the Soroban SDK support.Run the Example​First go through the Setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesOr, skip the development environment setup and open this example in Gitpod.To run the tests for the example use cargo test.cargo test -p soroban-account-contractYou should see the output:running 1 testtest test::test_token_auth ... okHow it Works​Open the account/src/lib.rs file to follow along.Account contracts implement a special function __check_auth that takes the signature payload, signatures and authorization context. The function should error if auth is declined, otherwise auth will be approved.This example contract uses ed25519 keys for signature verification and supports multiple equally weighted signers. It also implements a policy that allows setting per-token limits on transfers. The token can be spent beyond the limit only if every signature is provided.For example, the user may initialize this contract with 2 keys and introduce 100 USDC spend limit. This way they can use a single key to sign their contract invocations and be sure that even if they sign a malicious transaction they won't spend more than 100 USDC.Initialization​#[contracttype]#[derive(Clone)]enum DataKey { SignerCnt, Signer(BytesN<32>), SpendLimit(BytesN<32>),}...// Initialize the contract with a list of ed25519 public key ('signers').pub fn init(env: Env, signers: Vec<BytesN<32>>) { // In reality this would need some additional validation on signers // (deduplication etc.). for signer in signers.iter() { env.storage().instance().set(&DataKey::Signer(signer), &()); } env.storage() .instance() .set(&DataKey::SignerCnt, &signers.len());}This account contract needs to work with the public keys explicitly. Here we initialize the contract with ed25519 keys.Policy modification​// Adds a limit on any token transfers that aren't signed by every signer.pub fn add_limit(env: Env, token: BytesN<32>, limit: i128) { // The current contract address is the account contract address and has // the same semantics for `require_auth` call as any other account // contract address. // Note, that if a contract *invokes* another contract, then it would // authorize the call on its own behalf and that wouldn't require any // user-side verification. env.current_contract_address().require_auth(); env.storage() .instance() .set(&DataKey::SpendLimit(token), &limit);}This function allows users to set and modify the per-token spend limit described above. The neat trick here is that require_auth can be used for the current_contract_address(), i.e. the account contract may be used to verify authorization for its own administrative functions. This way there is no need to write duplicate authorization and authentication logic.__check_auth​pub fn __check_auth( env: Env, signature_payload: BytesN<32>, signatures: Vec<Signature>, auth_context: Vec<Context>,) -> Result<(), AccError> { // Perform authentication. authenticate(&env, &signature_payload, &signatures)?; let tot_signers: u32 = env .storage() .instance() .get::<_, u32>(&DataKey::SignerCnt) .unwrap(); let all_signed = tot_signers == signatures.len(); let curr_contract = env.current_contract_address(); // This is a map for tracking the token spend limits per token. This // makes sure that if e.g. multiple `transfer` calls are being authorized // for the same token we still respect the limit for the total // transferred amount (and not the 'per-call' limits). let mut spend_left_per_token = Map::<Address, i128>::new(&env); // Verify the authorization policy. for context in auth_context.iter() { verify_authorization_policy( &env, &context, &curr_contract, all_signed, &mut spend_left_per_token, )?; } Ok(())}__check_auth is a special function that account contracts implement. It will be called by the Soroban environment every time require_auth or require_auth_for_args is called for the address of the account contract.Here it is implemented in two steps. First, authentication is performed using the signature payload and a vector of signatures. Second, authorization policy is enforced using the auth_context vector. This vector contains all the contract calls that are being authorized by the provided signatures.__check_auth is a reserved function and can only be called by the Soroban environment in response to a call to require_auth. Any direct call to __check_auth will fail. This makes it safe to write to the account contract storage from __check_auth, as it's guaranteed to not be called in unexpected context. In this example it's possible to persist the spend limits without worrying that they'll be exhausted via a bad actor calling __check_auth directly.Authentication​fn authenticate( env: &Env, signature_payload: &BytesN<32>, signatures: &Vec<Signature>,) -> Result<(), AccError> { for i in 0..signatures.len() { let signature = signatures.get_unchecked(i); if i > 0 { let prev_signature = signatures.get_unchecked(i - 1); if prev_signature.public_key >= signature.public_key { return Err(AccError::BadSignatureOrder); } } if !env .storage() .instance() .has(&DataKey::Signer(signature.public_key.clone())) { return Err(AccError::UnknownSigner); } env.crypto().ed25519_verify( &signature.public_key, &signature_payload.clone().into(), &signature.signature, ); } Ok(())}Authentication here simply checks that the provided signatures are valid given the payload and also that they belong to the signers of this account contract.Authorization policy​fn verify_authorization_policy( env: &Env, context: &Context, curr_contract: &Address, all_signed: bool, spend_left_per_token: &mut Map<Address, i128>,) -> Result<(), AccError> { // For the account control every signer must sign the invocation. let contract_context = match context { Context::Contract(c) => { if &c.contract == curr_contract { if !all_signed { return Err(AccError::NotEnoughSigners); } } c } Context::CreateContractHostFn(_) => return Err(AccError::InvalidContext), };We verify the policy per Context. i.e. Per one require_auth call. The policy for the account contract itself enforces every signer to have signed the method call.// Otherwise, we're only interested in functions that spend tokens.if contract_context.fn_name != TRANSFER_FN && contract_context.fn_name != Symbol::new(env, \"approve\"){ return Ok(());}let spend_left: Option<i128> = if let Some(spend_left) = spend_left_per_token.get(contract_context.contract.clone()) { Some(spend_left) } else if let Some(limit_left) = env .storage() .instance() .get::<_, i128>(&DataKey::SpendLimit(contract_context.contract.clone())) { Some(limit_left) } else { None };// 'None' means that the contract is outside of the policy.if let Some(spend_left) = spend_left { // 'amount' is the third argument in both `approve` and `transfer`. // If the contract has a different signature, it's safer to panic // here, as it's expected to have the standard interface. let spent: i128 = contract_context .args .get(2) .unwrap() .try_into_val(env) .unwrap(); if spent < 0 { return Err(AccError::NegativeAmount); } if !all_signed && spent > spend_left { return Err(AccError::NotEnoughSigners); } spend_left_per_token.set(contract_context.contract.clone(), spend_left - spent);}Ok(())Then we check for the standard token function names and verify that for these function we don't exceed the spending limits.Tests​Open the account/src/test.rs file to follow along.Refer to another examples for the general information on the test setup.Here we only look at some points specific to the account contracts.fn sign(e: &Env, signer: &Keypair, payload: &BytesN<32>) -> RawVal { Signature { public_key: signer_public_key(e, signer), signature: signer .sign(payload.to_array().as_slice()) .to_bytes() .into_val(e), } .into_val(e)}Unlike most of the contracts that may simply use Address, account contracts deal with the signature verification and hence need to actually sign the payloads.let payload = BytesN::random(&env);let token = BytesN::random(&env);env.try_invoke_contract_check_auth::<AccError>( &account_contract.address.contract_id(), &payload, &vec![&env, sign(&env, &signers[0], &payload)], &vec![ &env, token_auth_context(&env, &token, Symbol::new(&env, \"transfer\"), 1000), ],).unwrap();__check_auth can't be called directly as regular contract functions, hence we need to use try_invoke_contract_check_auth testing utility that emulates being called by the Soroban host during a require_auth call.// Add a spend limit of 1000 per 1 signer.account_contract.add_limit(&token, &1000);// Verify that this call needs to be authorized.assert_eq!( env.auths(), std::vec![( account_contract.address.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( account_contract.address.clone(), symbol_short!(\"add_limit\"), (token.clone(), 1000_i128).into_val(&env), )), sub_invocations: std::vec![] } )]);Asserting the contract-specific error to try_invoke_contract_check_auth allows verifying the exact error code and makes sure that the verification has failed due to not having enough signers and not for any other reason.It's a good idea for the account contract to have detailed error codes and verify that they are returned when they are expected.assert_eq!( env.try_invoke_contract_check_auth::<AccError>( &account_contract.address.contract_id(), &payload, &vec![&env, sign(&env, &signers[0], &payload)], &vec![ &env, token_auth_context(&env, &token, Symbol::new(&env, \"transfer\"), 1001) ], ) .err() .unwrap() .unwrap(), AccError::NotEnoughSigners);","metadata":{"source":"https://soroban.stellar.org/docs/advanced-tutorials/custom-account","title":"Custom Account","contentLength":1443}},{"pageContent":"Fuzz TestingThe fuzzing example demonstrates how to fuzz test Soroban contracts with cargo-fuzz and customize the input to fuzz tests with the arbitrary crate. It also demonstrates how to adapt fuzz tests into reusable property tests with the proptest and proptest-arbitrary-interop crates. It builds on the timelock example.Run the example​First go through the setup process to get your development environment configured, then clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesYou will also need the cargo-fuzz tool, and to run cargo-fuzz you will need a nightly Rust toolchain:cargo install cargo-fuzzrustup install nightlyTo run one of the fuzz tests, navigate to the fuzzing directory and run the cargo fuzz subcommand with the nightly toolchain:cd fuzzingcargo +nightly fuzz run fuzz_target_1You should see output that begins like this:$ cargo +nightly fuzz run fuzz_target_1 Compiling soroban-fuzzing-contract v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing) Compiling soroban-fuzzing-contract-fuzzer v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz) Finished release [optimized + debuginfo] target(s) in 23.74s Finished release [optimized + debuginfo] target(s) in 0.07s Running `fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1 ...`INFO: Running with entropic power schedule (0xFF, 100).INFO: Seed: 886588732INFO: Loaded 1 modules (1093478 inline 8-bit counters): 1093478 [0x55eb8e2c7620, 0x55eb8e3d2586),INFO: Loaded 1 PC tables (1093478 PCs): 1093478 [0x55eb8e3d2588,0x55eb8f481be8),INFO: 105 files found in /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: seed corpus: files: 105 min: 32b max: 61b total: 3558b rss: 86Mb#2 pulse ft: 8355 exec/s: 1 rss: 307Mb#4 pulse cov: 8354 ft: 11014 corp: 1/32b exec/s: 2 rss: 313Mb#8 pulse cov: 8495 ft: 12420 corp: 4/128b exec/s: 4 rss: 315MbThe rest of this tutorial will explain how to set up this fuzz test, interpret this output, and remedy fuzzing failures.Background: fuzz testing and Rust​Fuzzing is a kind of testing where new inputs are repeatedly fed into a program in hopes of finding unexpected bugs. This style of testing is commonly employed to increase confidence in the correctness of security-sensitive software.In Rust, fuzzing is most often performed with the cargo-fuzz tool, which drives LLVM's libfuzzer, though other fuzzing tools are available.Soroban has built-in support for fuzzing Soroban contracts with cargo-fuzz.cargo-fuzz is a mutation-based fuzzer: it runs a test program, passing it generated input; while the program is executing, the fuzzer monitors which branches the program takes, and which functions it executes; after execution the fuzzer uses this information to make decisions about how to mutate the previously-used input to create new input that might discover more branches and functions; it then runs the test again with new input, repeating this process for potentially millions of iterations. In this way cargo-fuzz is able to automatically explore execution paths through the program that may never be seen by other types of tests.If a fuzz tests panics or hard-crashes, cargo-fuzz considers it a failure and provides instructions for repeating the test with the failing inputs.Fuzz testing is typically an exploratory and interactive process, with the programmer devising schemes for producing input that will stress the program in interesting ways, observing the behavior of the fuzz test, and iterating on the test itself.Resolving a fuzz testing failure typically involves capturing the problematic input in a unit test. The fuzz test itself may or may not be kept, depending on determinations about the cost of maintaining the fuzzer vs the likelihood of it continuing to find bugs in the future.While fuzzing non-memory-safe software tends to be more lucrative than fuzzing Rust software, it is still relatively common to find panics and other logic errors in Rust through fuzzing.In Rust, multiple fuzzers are maintained by the rust-fuzz GitHub organization, which also maintains a \"trophy case\" of Rust bugs found through fuzzing.About the example​The example used for this tutorial is based on the timelock example program, with some changes to demonstrate fuzzing.The contract, ClaimableBalanceContract, allows one party to deposit an arbitrary quantity of a token to the contract, specifying additionally: the claimants, addresses that may withdraw from the contract; and the time_bound, a specification of when those claimants may withdraw from the account.The TimeBound type looks like#[derive(Clone)]#[contracttype]pub struct TimeBound { pub kind: TimeBoundKind, pub timestamp: u64,}#[derive(Clone)]#[contracttype]pub enum TimeBoundKind { Before, After,}ClaimableBalanceContract has two methods, deposit and claim: pub fn deposit( env: Env, from: Address, token: Address, amount: i128, claimants: Vec<Address>, time_bound: TimeBound, ); pub fn claim( env: Env, claimant: Address, amount: i128, );deposit may only be successfully called once, after which claim may be called multiple times until the balance is completely drained, at which point the contract becomes dormant and may no longer be used.Fuzz testing setup​For these examples, the fuzz tests have been created for you, but normally you would use the cargo fuzz init command to create a fuzzing project as a subdirectory of the contract under test.To do that you would navigate to the contract directory, in this case, soroban-examples/fuzzing, and executecargo fuzz initA cargo-fuzz project is its own crate, which lives in the fuzz subdirectory of the crate being tested. This crate has its own Cargo.toml and Cargo.lock, and another subdirectory, fuzz_targets, which contains Rust programs, each its own fuzz test.Our soroban-examples/fuzzing directory looks likeCargo.toml - this is the contract's manifestCargo.locksrclib.rs - this is the contract codefuzz - this is the fuzzing crateCargo.toml - this is fuzzing crate's manifestCargo.lockfuzz_targetsfuzz_target_1.rs - this is a single fuzz testfuzz_target_2.rsThere are special considerations to note in the configuration of both the contract's manifest and the fuzzing crate's manifest.Within the contract's manifest one must specificy the crate type as both \"cdylib\" and \"rlib\":[package]name = \"soroban-fuzzing-contract\"version = \"0.0.0\"authors = [\"Stellar Development Foundation <[email protected]>\"]license = \"Apache-2.0\"edition = \"2021\"publish = false[lib]crate-type = [\"cdylib\", \"rlib\"]doctest = false[features]testutils = []In most examples, a Soroban contract will only be a \"cdylib\", a Rust crate that is compiled to a dynamically loadable wasm module. For fuzzing though, the fuzzing crate needs to be able to link to the contract crate as a Rust library, an \"rlib\".Note that cargo has a feature/bug that inhibits LTO of cdylibs when a crate is both a \"cdylib\" and \"rlib\". This can be worked around by building the contract with either soroban contract build or cargo rustc --crate-type cdylib instead of the typical cargo build.The contract crate must also provide the \"testutils\" feature. When \"testutils\" is activated, the Soroban SDK's contracttype macro emits additional code needed for running fuzz tests.Within the fuzzing crate's manifest one must turn on the \"testutils\" features in both the contract crate and the soroban-sdk crate:[package]name = \"soroban-fuzzing-contract-fuzzer\"version = \"0.0.0\"publish = falseedition = \"2021\"[package.metadata]cargo-fuzz = true[dependencies]libfuzzer-sys = \"0.4\"soroban-sdk = { version = \"0.9.1\", features = [\"testutils\"] }[dependencies.soroban-fuzzing-contract]path = \"..\"features = [\"testutils\"]A simple fuzz test​First let's look at fuzz_target_1.rs. This fuzz test does two things: it first deposits an arbitrary amount, then it claims an arbitrary amount.Again, you can run this fuzzer from the soroban-examples/fuzzing directory with the following command:cargo +nightly fuzz run fuzz_target_1The entry point and setup code for Soroban contract fuzz tests will typically look like:#[derive(Arbitrary, Debug)]struct Input { deposit_amount: i128, claim_amount: i128,}fuzz_target!(|input: Input| { let env = Env::default(); env.mock_all_auths(); env.ledger().set(LedgerInfo { timestamp: 12345, protocol_version: 1, sequence_number: 10, network_id: Default::default(), base_reserve: 10, }); // Turn off the CPU/memory budget for testing. env.budget().reset_unlimited(); // ... do fuzzing here ...}Instead of a main function, cargo-fuzz uses a special entry point defined by the fuzz_target! macro. This macro accepts a Rust closure that accepts input, any Rust type that implements the Arbitrary trait. Here we have defined a struct, Input, that derives Arbitrary.cargo-fuzz will be responsible for generating input and repeatedly calling this closure.To test a Soroban contract, we must set up an Env. Note that we have disabled the CPU and memory budget: this will allow us to fuzz arbitrarily complex code paths without worrying about running out of budget; we can assume that running out of budget during a transaction always correctly fails, canceling the transaction; it is not something we need to fuzz.Refer to the fuzz_target_1.rs source code for additional setup for this contract.This fuzzer performs two steps: deposit, then claim: // Deposit, then assert invariants. { let _ = fuzz_catch_panic(|| { timelock_client.deposit( &depositor_address, &token_contract_id, &input.deposit_amount, &vec![ &env, claimant_address.clone(), ], &TimeBound { kind: TimeBoundKind::Before, timestamp: 123456, }, ); }); assert_invariants( &env, &timelock_contract_id, &token_client, &input ); } // Claim, then assert invariants. { let _ = fuzz_catch_panic(|| { timelock_client.claim( &claimant_address, &input.claim_amount, ); }); assert_invariants( &env, &timelock_contract_id, &token_client, &input ); }There are a number of potential strategies for writing fuzz tests. The strategy in this test is to make arbitrary, possibly weird and unrealistic, calls to the contract, disregarding whether those calls succeed or fail, and then to make assertions about the state of the contract.Because there are many potential failure cases for any given contract call, we don't want to write a fuzz test by attempting to interpret the success or failure of any given call: that path leads to duplicating the contract's logic within the fuzz test. Instead we just want to ensure that, regardless of what happened during execution, the contract is never left in an invalid state.Notice the use of the fuzz_catch_panic function to invoke the contract: This is a special function in the Soroban SDK for intercepting panics in a way that works with cargo-fuzz, and is needed to call contract functions that might fail. Without fuzz_catch_panic a panic from within a contract will immediately cause the fuzz test to fail, but in most cases a panic within a contract does not indicate a bug - it is simply how a Soroban contract cancels a transaction. fuzz_catch_panic returns a Result, but here we discard it.Finally, the assert_invariants function is where we make any assertions we can about the state of the contract:/// Directly inspect the contract state and make assertions about it.fn assert_invariants( env: &Env, timelock_contract_id: &Address, token_client: &TokenClient, input: &Input,) { // Configure the environment to access the timelock contract's storage. env.as_contract(timelock_contract_id, || { let storage = env.storage(); // Get the two datums owned by the timelock contract. let is_initialized = storage.has(&DataKey::Init); let claimable_balance = storage.get::<_, ClaimableBalance>(&DataKey::Balance); // Call the token client to get the balance held in the timelock contract. // This consumes contract execution budget. let actual_token_balance = token_client.balance(timelock_contract_id); // There can only be a claimaible balance after the contract is initialized, // but once the balance is claimed there is no balance, // but the contract remains initialized. // This is a truth table of valid states. assert!(match (is_initialized, claimable_balance.is_some()) { (false, false) => true, (false, true) => false, (true, true) => true, (true, false) => true, }); assert!(actual_token_balance >= 0); if let Some(claimable_balance) = claimable_balance { let claimable_balance = claimable_balance.expect(\"balance\"); assert!(claimable_balance.amount > 0); assert!(claimable_balance.amount <= input.deposit_amount); assert_eq!(claimable_balance.amount, actual_token_balance); assert!(claimable_balance.claimants.len() > 0); } });}Interpreting cargo-fuzz output​If you run cargo-fuzz with fuzz_target_1, from inside the soroban-examples/fuzzing directory, you will see output similar to:$ cargo +nightly fuzz run fuzz_target_1 Compiling soroban-fuzzing-contract v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing) Compiling soroban-fuzzing-contract-fuzzer v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz) Finished release [optimized + debuginfo] target(s) in 25.18s Finished release [optimized + debuginfo] target(s) in 0.08s Running `fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1 -artifact_prefix=/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/artifacts/fuzz_target_1/ /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1`INFO: Running with entropic power schedule (0xFF, 100).INFO: Seed: 1384064486INFO: Loaded 1 modules (1122058 inline 8-bit counters): 1122058 [0x561f6ecd4fc0, 0x561f6ede6eca),INFO: Loaded 1 PC tables (1122058 PCs): 1122058 [0x561f6ede6ed0,0x561f6ff05f70),INFO: 173 files found in /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: seed corpus: files: 173 min: 32b max: 61b total: 6039b rss: 83Mb#4 pulse cov: 4848 ft: 10214 corp: 1/32b exec/s: 2 rss: 313Mb#8 pulse cov: 8507 ft: 11743 corp: 4/128b exec/s: 4 rss: 315Mb#16 pulse cov: 8512 ft: 12393 corp: 10/320b exec/s: 8 rss: 319Mbthread '<unnamed>' panicked at 'assertion failed: claimable_balance.amount > 0', fuzz_targets/fuzz_target_1.rs:130:13note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace==6102== ERROR: libFuzzer: deadly signal #0 0x561f6ae3a431 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1c80431) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846) #1 0x561f6e3855b0 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x51cb5b0) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846) #2 0x561f6e35c08a (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x51a208a) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846) #3 0x7fce05f5e08f (/lib/x86_64-linux-gnu/libc.so.6+0x4308f) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee) #4 0x7fce05f5e00a (/lib/x86_64-linux-gnu/libc.so.6+0x4300a) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee) #5 0x7fce05f3d858 (/lib/x86_64-linux-gnu/libc.so.6+0x22858) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee) ... #27 0x561f6e3847b9 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x51ca7b9) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846) #28 0x561f6ad98346 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde346) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846) #29 0x7fce05f3f082 (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee) #30 0x561f6ad9837d (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde37d) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)NOTE: libFuzzer has rudimentary signal handlers. Combine libFuzzer with AddressSanitizer or similar for better crash reports.SUMMARY: libFuzzer: deadly signalMS: 0 ; base unit: 00000000000000000000000000000000000000000x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5d,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x5f,0x5f,0x52,0xff,\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000]\\000\\000\\000\\000\\000\\000\\000\\000\\377__R\\377artifact_prefix='/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/artifacts/fuzz_target_1/'; Test unit written to /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627Base64: AAAAAAAAAAAAAAAAAAAAAAAAXQAAAAAAAAAA/19fUv8=────────────────────────────────────────────────────────────────────────────────Failing input: fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627Output of `std::fmt::Debug`: Input { deposit_amount: 0, claim_amount: -901525218878596739118967460911579136, }Reproduce with: cargo fuzz run fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627Minimize test case with: cargo fuzz tmin fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627────────────────────────────────────────────────────────────────────────────────Error: Fuzz target exited with exit status: 77This is a fuzzing failure, indicating a bug in either the fuzzer or the program. The details will be different.Here is the same output, with less important lines trimmed:thread '<unnamed>' panicked at 'assertion failed: claimable_balance.amount > 0', fuzz_targets/fuzz_target_1.rs:130:13...Failing input: fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627Output of `std::fmt::Debug`: Input { deposit_amount: 0, claim_amount: -901525218878596739118967460911579136, }Reproduce with: cargo fuzz run fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627Minimize test case with: cargo fuzz tmin fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627The first line here is printed by our Rust program, and indicates exactly where the fuzzer panicked. The later lines indicate how to reproduce this failing case.The first thing to do when you get a fuzzing failure is copy the command to reproduce the failure, so that you can use it to debug:cargo +nightly fuzz run fuzz_target_1 fuzz/artifacts/fuzz_target_1/crash-04704b1542f61a21a4649e39023ec57ff502f627Notice though that we need to tell cargo to use the nightly toolchain with the +nightly flag, something that cargo-fuzz doesn't print in its version of the command.Another thing to notice is that by default, cargo-fuzz / libfuzzer does not print names of functions in its output, as in the stack trace:==6102== ERROR: libFuzzer: deadly signal #0 0x561f6ae3a431 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1c80431) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846) ... #28 0x561f6ad98346 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde346) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846) #29 0x7fce05f3f082 (/lib/x86_64-linux-gnu/libc.so.6+0x24082) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee) #30 0x561f6ad9837d (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde37d) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)Depending on how your system is set up, you may or may not have this problem. In order to print stack traces, libfuzzer needs the llvm-symbolizer program. On Ubuntu-based systems this can be installed with the llvm-dev package:$ sudo apt install llvm-devAfter which libfuzzer will print demangled function names instead of addresses:==6323== ERROR: libFuzzer: deadly signal #0 0x557c9da6a431 in __sanitizer_print_stack_trace /rustc/llvm/src/llvm-project/compiler-rt/lib/asan/asan_stack.cpp:87:3 #1 0x557ca0fb55b0 in fuzzer::PrintStackTrace() /home/azureuser/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/libfuzzer/FuzzerUtil.cpp:210:38 #2 0x557ca0f8c08a in fuzzer::Fuzzer::CrashCallback() /home/azureuser/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/libfuzzer/FuzzerLoop.cpp:233:18 #3 0x557ca0f8c08a in fuzzer::Fuzzer::CrashCallback() /home/azureuser/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/libfuzzer/FuzzerLoop.cpp:228:6 #4 0x7ff19e84d08f (/lib/x86_64-linux-gnu/libc.so.6+0x4308f) (BuildId: 1878e6b475720c7c51969e69ab2d276fae6d1dee) #5 0x7ff19e84d00a in __libc_signal_restore_set /build/glibc-SzIz7B/glibc-2.31/signal/../sysdeps/unix/sysv/linux/internal-signals.h:86:3 #6 0x7ff19e84d00a in raise /build/glibc-SzIz7B/glibc-2.31/signal/../sysdeps/unix/sysv/linux/raise.c:48:3 #7 0x7ff19e82c858 in abort /build/glibc-SzIz7B/glibc-2.31/stdlib/abort.c:79:7 ... #23 0x557c9daee89a in fuzz_target_1::assert_invariants::hd6d4f9549b01c31c /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/fuzz_targets/fuzz_target_1.rs:103:5 #24 0x557c9daee89a in fuzz_target_1::_::run::hac1117cb3dfecb2b /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/fuzz_targets/fuzz_target_1.rs:69:9 #25 0x557c9daecea6 in rust_fuzzer_test_input /home/azureuser/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/src/lib.rs:297:60 ... #37 0x557c9d9c8346 in main /home/azureuser/.cargo/registry/src/index.crates.io-6f17d22bba15001f/libfuzzer-sys-0.4.5/libfuzzer/FuzzerMain.cpp:20:30 #38 0x7ff19e82e082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16 #39 0x557c9d9c837d in _start (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1+0x1bde37d) (BuildId: 6a95a932984a405ebab8171dddc9f812fdf16846)To continue, our program has a bug that should be easy to fix by inspecting the error and making a slight modification to the source.Once the bug is fixed, the fuzzer will run continuously, producing output that looks like$ cargo +nightly fuzz run fuzz_target_1 Compiling soroban-fuzzing-contract v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing) Compiling soroban-fuzzing-contract-fuzzer v0.0.0 (/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz) Finished release [optimized + debuginfo] target(s) in 24.91s Finished release [optimized + debuginfo] target(s) in 0.08s Running `fuzz/target/x86_64-unknown-linux-gnu/release/fuzz_target_1 -artifact_prefix=/home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/artifacts/fuzz_target_1/ /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1`INFO: Running with entropic power schedule (0xFF, 100).INFO: Seed: 1619748028INFO: Loaded 1 modules (1122061 inline 8-bit counters): 1122061 [0x5647a55b9080, 0x5647a56caf8d),INFO: Loaded 1 PC tables (1122061 PCs): 1122061 [0x5647a56caf90,0x5647a67ea060),INFO: 173 files found in /home/azureuser/data/stellar/soroban-examples/fuzzing/fuzz/corpus/fuzz_target_1INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytesINFO: seed corpus: files: 173 min: 32b max: 61b total: 6039b rss: 85Mb#2 pulse ft: 8067 exec/s: 1 rss: 312Mb#4 pulse cov: 8068 ft: 10709 corp: 1/32b exec/s: 2 rss: 315Mb#8 pulse cov: 8476 ft: 11498 corp: 5/160b exec/s: 4 rss: 317Mb#16 pulse cov: 8512 ft: 12362 corp: 9/288b exec/s: 8 rss: 320Mb#32 pulse cov: 8516 ft: 13290 corp: 19/608b exec/s: 10 rss: 326Mb#64 pulse cov: 8516 ft: 13311 corp: 27/864b exec/s: 21 rss: 340Mb#128 pulse cov: 8540 ft: 13536 corp: 37/1196b exec/s: 25 rss: 365Mb#175 INITED cov: 8540 ft: 13580 corp: 42/1387b exec/s: 29 rss: 382Mb#177 NEW cov: 8545 ft: 13821 corp: 43/1419b lim: 48 exec/s: 29 rss: 384Mb L: 32/48 MS: 1 ChangeASCIIInt-#178 NEW cov: 8545 ft: 13824 corp: 44/1451b lim: 48 exec/s: 29 rss: 384Mb L: 32/48 MS: 1 ChangeBinInt-#229 NEW cov: 8545 ft: 13826 corp: 45/1483b lim: 48 exec/s: 38 rss: 401Mb L: 32/48 MS: 1 ChangeByte-#256 pulse cov: 8545 ft: 13826 corp: 45/1483b lim: 48 exec/s: 36 rss: 410Mb#361 NEW cov: 8545 ft: 13830 corp: 46/1521b lim: 48 exec/s: 40 rss: 451Mb L: 38/48 MS: 5 ShuffleBytes-CMP-EraseBytes-CopyPart-ChangeBinInt- DE: \"\\005\\000\\000\\000\"- NEW_FUNC[1/1]: 0x5647a2964640 in rand::rngs::adapter::reseeding::ReseedingCore$LT$R$C$Rsdr$GT$::reseed_and_generate::ha760ded93293681c /home/azureuser/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rand-0.7.3/src/rngs/adapter/reseeding.rs:235#368 NEW cov: 8557 ft: 13842 corp: 47/1566b lim: 48 exec/s: 40 rss: 454Mb L: 45/48 MS: 2 CrossOver-InsertRepeatedBytes-#512 pulse cov: 8557 ft: 13842 corp: 47/1566b lim: 48 exec/s: 46 rss: 502Mb#850 NEW cov: 8557 ft: 13843 corp: 48/1610b lim: 48 exec/s: 53 rss: 591Mb L: 44/48 MS: 2 CopyPart-ChangeBit-#1024 pulse cov: 8557 ft: 13843 corp: 48/1610b lim: 48 exec/s: 56 rss: 645Mb#1796 NEW cov: 8557 ft: 13863 corp: 49/1642b lim: 53 exec/s: 71 rss: 669Mb L: 32/48 MS: 1 ChangeBinInt-#1913 NEW cov: 8557 ft: 13864 corp: 50/1675b lim: 53 exec/s: 73 rss: 669Mb L: 33/48 MS: 2 ShuffleBytes-InsertByte-#3749 REDUCE cov: 8557 ft: 13864 corp: 50/1670b lim: 68 exec/s: 98 rss: 669Mb L: 39/48 MS: 1 EraseBytes-...And this output will continue until the fuzzer is killed with Ctrl-C.Next, let's look at a single line of fuzzer output:#177 NEW cov: 8545 ft: 13821 corp: 43/1419b lim: 48 exec/s: 29 rss: 384Mb L: 32/48 MS: 1 ChangeASCIIInt-The most important column here is cov. This is a cumulative measure of branches covered by the fuzzer. When this number stops increasing the fuzzer has probably explored as much of the program as it can. The other columns are described in the libfuzzer documentation.Finally, lets look at this warning:INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes.By default, libfuzzer only generates input up to 4096 bytes. In a lot of cases, this is probably reasonable, but cargo-fuzz can increase the max_len by appending the argument after --:$ cargo +nightly fuzz run fuzz_target_1 -- -max_len=20000All the options to libfuzzer can be listed with$ cargo +nightly fuzz run fuzz_target_1 -- -help=1See the libfuzzer documentation for more.Accepting Soroban types as input with the SorobanArbitrary trait​Inputs to the fuzz_target! macro must implement the Arbitrary trait, which accepts bytes from the fuzzer driver and converts them to Rust values. Soroban types though are managed by the host environment, and so must be created from an Env value, which is not available to the fuzzer driver. The SorobanArbitrary trait, implemented for all Soroban contract types, exists to bridge this gap: it defines a prototype pattern whereby the fuzz_target macro creates prototype values that the fuzz program can convert to contract values with the standard soroban conversion traits, FromVal or IntoVal.The types of prototypes are identified by the associated type, SorobanArbitrary::Prototype:pub trait SorobanArbitrary: TryFromVal<Env, Self::Prototype> + IntoVal<Env, Val> + TryFromVal<Env, Val>{ type Prototype: for <'a> Arbitrary<'a>;}Types that implement SorobanArbitrary include:i32, u32, i64, u64, i128, u128, I256, U256, (), and bool,Error,Bytes, BytesN, Vec, Map,Address, Symbol,Val,All user-defined contract types, those with the contracttype attribute, automatically derive SorobanArbitrary. Note that SorobanArbitrary is only derived when the \"testutils\" Cargo feature is active. This implies that, in general, to make a Soroban contract fuzzable, the contract crate must define a \"testutils\" Cargo feature, that feature should turn on the \"soroban-sdk/testutils\" feature, and the fuzz test, which is its own crate, must turn that feature on.A more complex fuzz test​The fuzz_target_2.rs example, demonstrates the use of SorobanArbitrary, the advancement of time, and more advanced fuzzing techniques.This fuzz test takes a much more complex input, where some of the values are user-defined types exported from the contract under test. This test is structured as a simple interpreter, where the fuzzing harness provides arbitrarily-generated \"steps\", where each step is either a deposit command or a claim command. The test then treats each of these steps as a separate transaction: it maintains a snapshot of the blockchain state, and for each step creates a fresh environment in which to execute the contract call, simulating the advancement of time between each step. As in the previous example, assertions are made after each step.The input to the fuzzer looks, in part, like:#[derive(Arbitrary, Debug)]struct Input { addresses: [<Address as SorobanArbitrary>::Prototype; NUM_ADDRESSES], #[arbitrary(with = |u: &mut Unstructured| u.int_in_range(0..=i128::MAX))] token_mint: i128, steps: RustVec<Step>,}#[derive(Arbitrary, Debug)]struct Step { #[arbitrary(with = |u: &mut Unstructured| u.int_in_range(1..=u64::MAX))] advance_time: u64, command: Command, // `Command` not shown here - see the full source.}This shows how to use the SorobanArbitrary::Prototype associated type to define inputs to the fuzzer. A Soroban Address can only be created with an Env, so cannot be generated directly by the Arbitrary trait. Instead we use the fully-qualified name of the Address prototype, <Address as SorobanArbitrary>::Prototype, to ask for Address's prototype instead. Then when our fuzzer needs the Address we instantiate it with the FromVal trait:let depositor_address = Address::from_val(&env, &input.addresses[cmd.depositor_index]);The contract we are fuzzing is a timelock contract, where calculation of time is crucial for correctness. So our testing must account for the advancement of time.The contract defines a TimeBound type and accepts it in the deposit method:#[derive(Clone, Debug)]#[contracttype]pub struct TimeBound { pub kind: TimeBoundKind, pub timestamp: u64,}#[contractimpl]impl ClaimableBalanceContract { pub fn deposit( env: Env, from: Address, token: Address, amount: i128, claimants: Vec<Address>, time_bound: TimeBound, ) { ... }}In our fuzzer, one of the possible commands issued each step is a DepositCommand:#[derive(Arbitrary, Debug)]struct DepositCommand { #[arbitrary(with = |u: &mut Unstructured| u.int_in_range(0..=NUM_ADDRESSES - 1))] depositor_index: usize, amount: i128, // This is an ugly way to get a vector of integers in range #[arbitrary(with = |u: &mut Unstructured| { u.arbitrary_len::<usize>().map(|len| { (0..len).map(|_| { u.int_in_range(0..=NUM_ADDRESSES - 1) }).collect::<Result<RustVec<usize>, _>>() }).and_then(|inner_result| inner_result) })] claimant_indexes: RustVec<usize>, time_bound: <TimeBound as SorobanArbitrary>::Prototype,}Notice that this command again uses the SorobanArbitrary::Prototype associated type to accept a TimeBound as input.To advance time we maintain a LedgerSnapshot, defined in the soroban-ledger-snapshot crate. For each step we call Env::from_snapshot to create a fresh environment to execute the step, then Env::to_snapshot to create a new snapshot to use in the following step.Here is a simplified outline of how this works. See the full source code for details.let init_snapshot = { let init_ledger = LedgerInfo { timestamp: 12345, protocol_version: 1, sequence_number: 10, network_id: Default::default(), base_reserve: 10, min_temp_entry_expiration: u32::MAX, min_persistent_entry_expiration: u32::MAX, }; LedgerSnapshot::from(init_ledger, None)};let mut prev_env = Env::from_snapshot(init_snapshot);for step in &config.input.steps { // Advance time and create a new env from snapshot. let curr_env = { let mut snapshot = prev_env.to_snapshot(); snapshot.sequence_number += 1; snapshot.timestamp = snapshot.timestamp.saturating_add(step.advance_time); let env = Env::from_snapshot(snapshot); env.budget().reset_unlimited(); env }; step.command.exec(&config, &curr_env); prev_env = curr_env;}Converting a fuzz test to a property test​In addition to fuzz testing, Soroban supports property testing in the style of quickcheck, by using the proptest and proptest-arbitrary-interop crates in conjunction with the SorobanArbitrary trait.Property tests are similar to fuzz tests in that they generate randomized input. Property tests though do not instrument their test cases or mutate their input based on feedback from previous tests. Thus they are a weaker form of test.The great benefit of property tests though is that they can be included in standard Rust test suites and require no extra tooling to execute. One might take advantage of this by interactively fuzzing to discover deep bugs, then convert fuzz tests to property tests to help prevent regressions.The proptest.rs file is a translation of fuzz_target_1.rs to a property test.","metadata":{"source":"https://soroban.stellar.org/docs/advanced-tutorials/fuzzing","title":"Fuzz Testing","contentLength":4820}},{"pageContent":"High-Level OverviewRust language​Contracts are small programs written in the Rust programming language. In order to write contracts, install a Rust toolchain, configure your editor to support Rust programs, and learn at least some basic Rust concepts.Contracts can be compiled to native code for local (off-chain) testing, but must be compiled as WebAssembly (\"Wasm\") for deployment. The on-chain host environment only allows uploading Wasm contracts, and runs them within a Wasm \"sandbox\" virtual machine (\"VM\").In practice several special characteristics of the contract execution environment -- resource constraints, security considerations, nonstandard IO and invocation primitives, the requirement for strict determinism -- will mean that contracts can only use a very narrow subset of the full Rust language, and must use specialized libraries for most tasks. See the rust dialect section for details.In particular both the Rust standard library and most 3rd party libraries (\"crates\" in Rust parlance) will not be available for direct off-the-shelf use in contracts, due to the constraints listed above. Some crates will be possible to adapt to use in contracts, others may be incorporated into the host environment as host objects or functions.In the future it is possible that other source languages may be supported. The execution environment is somewhat language-agnostic, and some very early experiments suggest that other languages may be possible. However, at this time only Rust is supported.SDK​Contracts are developed with the help of a Software Development Kit or SDK. The SDK consists of both a Rust crate and a command-line tool.The SDK crate acts as a substitute for the Rust standard library -- providing data structures and utility functions for contracts -- as well as providing access to smart-contract-specific functionality from the contract environment, like cryptographic hashing and signature verification, access to on-chain persistent storage, and location and invocation of secondary contracts via stable identifiers.Local testing mode​The SDK command-line tool provides a developer-focused front-end for compiling, testing, inspecting, versioning and deploying contracts.The SDK also includes a complete implementation of the contract host environment -- identical to the one that runs on-chain -- such that contracts can be run locally on a developer's workstation, and can be tested and debugged directly with a local debugger within a standard IDE, as well as a native test harness for fast-feedback unit testing and high-speed fuzzing or property testing.Host Environment​The host environment is a set of Rust crates that are compiled into both the SDK command-line tool and stellar-core, the transaction processor at the heart of the stellar network. It comprises a set of host objects and functions, an interface to on-chain storage and contract invocation, a resource-accounting and fee-charging system, and a Wasm interpreter.Most contract developers will not frequently need to interact with the host environment directly -- SDK functions wrap most of its facilities and provide richer and more ergonomic types and functions -- but it is helpful to understand its structure in order to understand the conceptual model the SDK is presenting. It is also likely that some parts of the host environment will be visible when testing or debugging contracts compiled natively on a local workstation.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/high-level-overview","title":"High-Level Overview","contentLength":540}},{"pageContent":"Soroban on Stellar FAQscautionSoroban's Stellar integration is under active-development and may change.What is Soroban to Stellar? Is it a new blockchain?​Soroban is not a new blockchain. Soroban is a smart contract platform that is integrated into the existing Stellar blockchain. It is an additive feature that lives alongside, and doesn't replace, the existing set of Stellar operations.How do I invoke a Soroban contract on Stellar?​A Soroban contract can be invoked by submitting a transaction that contains the new operation: InvokeContractOp.Can Soroban contracts use Stellar accounts for authentication?​Yes. Stellar accounts are shared with Soroban. Smart contacts have access to Stellar account signer configuration and know the source account that directly invoked them in a transaction. Check out the Auth and Advanced Auth examples for more information.Can Soroban contracts interact with Stellar assets?​Yes. Soroban contains a built-in Stellar Asset Contract that is able to interact with classic trustlines. Read more about this here.Do issuers of Stellar assets maintain their authorization over an asset that has been sent to a non-account identifier in Soroban? (AUTH_REQUIRED, AUTH_REVOCABLE, AUTH_CLAWBACK)​Yes. Issuers retain the same level of control on Soroban as they have on Classic. This functionality is accessible through a set of admin functions (clawback, set_auth) on the built-in Stellar Asset Contract.Can Soroban contracts interact with any other Stellar operations?​No. Aside from the interactions with accounts and assets as mentioned above. This means that Soroban contracts can not interact with SDEX, AMMs, Claimable Balances, or Sponsorships.Does the Stellar base reserve apply to Soroban contracts?​No. Soroban has a different fee structure and ledger entries that are allocated by Soroban contracts do not add to an account's required minimal balance.Should I issue my token as a Stellar asset or a custom Soroban token?​We recommend, to the extent possible, issuing tokens as Stellar assets. These tokens will benefit from being interoperable with the existing ecosystem of tools available in the Stellar ecosystem, as well as being more performant because the Stellar Asset Contract is built into the host.Haven't found what you're looking for?​Join #soroban on the Stellar Developer Discord","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/faq","title":"Soroban on Stellar FAQs","contentLength":367}},{"pageContent":"AuthorizationinfoThis is an overview of the Soroban authorization framework.AuthorizationAuthorization is the process of judging which operations \"should\" or \"should not\" be allowed to occur; it is about judging permission.Authorization differs from authentication, which is the narrower problem of judging whether a person \"is who they say they are\", or whether a message claiming to come from a person \"really\" came from them.Authorization often uses cryptographic authentication (via signatures) to support its judgments, but is a broader, more general process.Soroban Authorization Framework​Soroban aims to provide a light-weight, but flexible and extensible framework that allows contracts to implement arbitrarily complex authorization rules, while providing built-in implementation for some common tasks (such as replay prevention). The framework consists of the following components:Contract-specific authorization - custom authorization rules implemented by contracts using the private contract storage and abstract accounts.Account abstraction - allows users to customize their authentication rules and define universal authorization policies via custom account contracts (this includes the built-in support for the Stellar accounts).Host-based authorization library - ensures integrity between the custom accounts and regular contracts. Also defines the structured signature payload format, ensures replay prevention and takes care of providing the correct signature contexts.Soroban host also provides some cryptographic functions (signature verfication, hashing) which may be useful for the custom account implementation.Contracts that use Soroban authorization framework are interoperable with each other. Also it is easier for the client applications to write generic code for interaction with Soroban authorization framework. For example, wallets can implement a generalized way to present and sign Soroban payloads.We realize that it's not possible to cover each and every case, but we hope that the vast majority of the contracts can operate within the framework and thus contribute to building a more cohesive ecosystem. Custom authorization frameworks are still possible to implement, but are not encouraged (unless there are no alternatives).Contract-specific Authorization​Contract storage​Contracts have an exclusive read and write access to their storage in the ledger. This allows contracts to safely control and manage user access to their data. For example, a token contract may ensure that only the administrator can mint more of the token by storing the administrator identity in its storage. Similarly, it can make sure that only an owner of the balance may transfer that balance.Address​The storage-based approach described in the previous section requires a way to represent the user identities and authenticate them. Address type is a host-managed type that performs these functions.From the contract perspective Address is an opaque identifier type. The contract logic doesn't need to depend on the internal representation of the Address (see Account Abstraction section below for more details).Address type has two similar methods in Soroban SDK: require_auth and require_auth_for_args (these methods call the respective Soroban host function). The only difference between the functions is the ability to customize the invocation arguments. See auth example that demonstrates how to use these functions.Both functions ensure that the Address has authorized the call of the current function within the current context (where context is defined by require_auth calls in the current call stack; see more formal definition in the section below). The authentication rules for this authorization are defined by the Address and are enforced by the Soroban host. Replay protection is also implemented in the host, i.e., there is normally no need for a contract to manage its own nonces.Authorizing Sub-contract Calls​One of the key features of Soroban Authorization Framework is the ability to easily make authorized sub-contract calls. For example, it is possible for a contract to call require_auth for an Address and then call token.xfer authorized for the same Address (see timelock example that demonstrates this pattern).Contracts don't need to do anything special to benefit from this feature. Just calling a sub-contract that calls require_auth will ensure that the sub-contract call has been properly authorized.When to require_auth​The main authorization-related decision a contract writer needs to make for any given Address is whether they need to call require_auth for it. While the decision needs to be made on case-by-case basis, here are some rules of thumb:If the access to the Address data in this contract is read-only, then require_auth is probably not needed.If the Address data in this contract is being modified in a way that's not strictly beneficial to the user, then require_auth is probably needed (e.g. reducing the user's token balance needs to be authorized, while increasing it doesn't need to be authorized)If a contract calls another contract that will call require_auth for the Address (e.g. token.xfer), then adding require_auth in the caller would ensure that the authorization for the inner call can't be reused outside of your contract. For example, if you want to do something positive for the user, but only when they have transferred some token to your contract, then the contract call itself should require_auth.Authorizing Multiple Addresses​There is no explicit restriction on how many Address entities the contract uses and how many Addresses have require_auth called. That means that it is possible to authorize a contract call on behalf of multiple users, which may even have different authorization contexts (customized via arguments in require_auth_for_args). Atomic swap is an example that deals with authorization of two Addresses.Note though, that contracts that deal with multiple authorized Addresses need a bit more complex support on the client side (to collect and attach the proper signatures).Account Abstraction​Account abstraction is a way to decouple the authentication logic from the contract-specific authorization rules. The Address defined above is in fact an identifier of an 'abstract' account. That is, the contracts know the Address and can require authorization from it, but they don't know how exactly it is implemented.For example, imagine a token contract. Its responsibilities are to manage the balances of multiple users (transfer, mint, burn etc.). There is really nothing about these responsibilities that has anything to do with how exactly the user authorized the balance-modifying transaction. The users may want to use some hardware key that supports a new generation of crypto algorithms(which don't even have to exist today) or they may want to have bespoke multisig scheme and none of this really has anything to do with the token logic.Account abstraction provides a convenient extension point for every contract that uses Address for authorization. It doesn't solve all the issues automatically - client-side tooling may still need to be adapted to support different authentication schemes or different wallets. But the on-chain state doesn't need to be modified and modifying the on-chain state is a much harder problem.Types of Account Implementations​Conceptually, every abstract account is a special contract that defines authentication rules and potentially some additional account-specific authorization policies. However, for the sake of optimization and integration with the existing Stellar accounts, Soroban supports 4 different kinds of the account implementations.Below are the general descriptions of these implementations. See the transaction guide for the concrete information of how different accounts are represented.Stellar Account​Corresponds to Address::Account.This is a special, built-in 'account contract' that handles all the Stellar accounts. It is not a real contract and doesn't need to be deployed.This supports the Stellar multisig with medium threshold. See Stellar documentation for more details on multisig and thresholds.Transaction Invoker​Corresponds to Address::Account.This is also a Stellar account, but its signature is inferred from the source account of the Stellar transaction (or operation, if it has one).This is purely an optimization of the Stellar Account that can skip one signature in case the transaction source account also authorizes the contract invocation.Contract Invoker​Corresponds to Address::Contract.This is a special case of an 'account' that may appear only when a contract calls another contract. We consider that since the contract makes a call, then it must be authorizing it (otherwise, it shouldn't have made that call). Hence all the require_auth calls made on behalf of the direct invoker contract Address are considered to be authorized (but not any calls on behalf of the contract deeper down the stack).Custom Account​Corresponds to Address::Contract.This is the extension point of account abstraction. Custom account is a special contract that implements __check_auth method. If any contract calls require_auth for the Address of this contract, Soroban host will call __check_auth with the corresponding arguments.__check_auth gets a signature payload, a list of signatures (in any user-defined format) and a list of the contract invocations that are being authorized by these signatures. Its responsibility is to perform the authentication via verifying the signatures and also (optionally) to apply a custom authorization policy. For example, a signature weight system similar to Stellar can be implemented, but it also can have customizable rules for the weights, e.g. to allow spending more than X units of token Y only given signature weight Z.Custom account can also be treated as a custodial smart wallet. It holds the user's funds (token balances, NFTs etc.) and provides the user(s) with ways to authorize operations on these funds. That said, nothing prevents custom accounts to authorize operations that have nothing to do with any balances, for example, it can be used to perform administrative functions for tokens (don't forget, custom account simply defines what to do when require_auth is called).For the exact interface and more details, see the custom account example.Advanced Concepts​Most of the contracts shouldn't need the concepts described in this section. Refer to this when developing complex contracts that deal with deep contract call trees and/or multiple Addresses.require_auth implementation details​When a Soroban transaction is executed on-chain, the host collects a list of SorobanAuthorizationEntry entries from the transaction (XDR). These entries contain signed authorizer credentials and authorized invocation trees. The host uses these entries to verify authorization during the contract execution.Every time require_auth/require_auth_for_args host function is called for non-contract-invoker account, the following steps happen:Find an authorized invocation tree that matches the require_auth call. The matching process is pretty involved and is described in the section below.If authentication hasn't happened for this tree yet, then perform it:Verify signature expiration. Expired signatures are not vlaid.Verify and consume nonce. Nonce is an arbitrary number, that has to be unique among all the non-expired signatures of the address.Build the expected signature payload preimage and compute its SHA-256 hash to get the final signature payloadCall __check_auth of the account contract corresponding to the Address using the signature payload and the invocations from the authorization treeMark the invocation as 'exhausted' in its authorized invocation tree. 'Exhausted' invocations will be skipped when matching the future require_auth calls.If any of the steps above fails, then the authorization is considered unsuccessful.Notice, that authentication happens just once per tree, as the whole tree needs to be signed.Matching Authorized Invocation Trees​In order for authorizations to succeed, all the require_auth/require_auth_for_args calls have to be covered by the corresponding SorobanAuthorizedInvocation trees in a transaction (defined in transaction XDR).Formally, this correspondence is defined as follows.Given a top-level contract invocation I we can build a 'contract invocation tree' T by tracing all the sub-contract calls (a directed edge A->B in the tree means 'contract function A calls contract function B). Note, that we only consider the functions that are implemented in different contracts, i.e. any function calls that don't involve a contract invocation via host call are considered to belong to the same node.Let's say authorization is required from addresses A_1..A_N. Then for every address A_i there are two kinds of nodes in the invocation tree T: R-nodes that had a require_auth call for A_i and N-nodes that didn't have such call. Then we remove all the N-nodes and all the edges from T and add the directed edges connecting the remaining R-nodes such that the edge goes from R_j to R_k if there was a path between R_j and R_k in T that doesn't contain any other R-nodes. As a result we get a forest of SorobanAuthorizedInvocation trees for A_i. Notice, that these trees don't have to have their root be I node (i.e. the top-level contract call), so it's possible to e.g. batch the authorized call together without requiring signing the batching function.In simpler terms, SorobanAuthorizedInvocation trees for an Address are subsets of the full invocation tree that are 'condensed' to only contain invocations that have require_auth call for that Address.During the matching process that happens for every require_auth host tries to match the current path in T to a SorobanAuthorizedInvocation tree for the corresponding Address. The path is considered to be matched only when there is a corresponding path of exhausted R nodes leading to the current call. This means that if the Address signs a sequence of calls A.foo->B.bar->C.baz, then its authorization check will fail in case if A.foo directly calls C.baz because C.baz strictly has to be called from B.bar.Duplicate Addresses​In case if the same contract function calls require_auth for the same Address multiple times (e.g. when multiple operations from the same user are being batched), every require_auth call still has to have a corresponding node in the SorobanAuthorizedInvocation tree. Due to that, there might be multiple valid trees that make all the authorization checks pass. There is nothing wrong about that - the address still must have authorized all the invocations. The only requirement for such cases to be handled correctly is to ensure that the require_auth calls for an Address happen before the corresponding sub-contract calls.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/authorization","title":"AuthorizationAuthorization","contentLength":2344}},{"pageContent":"Built-In TypesBuilt-in types are available to all contracts for use as contract function inputs and outputs, and are defined by the environment and the Rust SDK.tipCustom types like structs, enums, and unions are also supported. See Custom Types.Primitive Types​The following primitive types are supported:Unsigned 32-bit Integer (u32)​Signed 32-bit Integer (i32)​Unsigned 64-bit Integer (u64)​Signed 64-bit Integer (i64)​Unsigned 128-bit Integer (u128)​Signed 128-bit Integer (i128)​Bool (bool)​Symbol (Symbol)​Symbols are small efficient strings up to 32 characters in length and limited to a-z A-Z 0-9 _ that are encoded into 64-bit integers.Symbols are primarily used for function names and other identifiers that are exported in the public API of a contract. They can also be used wherever short strings are needed to keep resource costs down.Bytes, Strings (Bytes, BytesN)​Byte arrays and strings can be passed to contracts and stores using the Bytes type.For byte arrays of fixed length, BytesN can be used. For example, contract IDs are fixed 32-byte byte arrays, and are represented as BytesN<32>.Vec (Vec)​Vec is a sequential and indexable growable collection type.Values are stored in the environment and are available to contract through the functions defined on Vec. Values stored in the Vec are transmitted to the environment as RawVals, and when retrieved from the Vec are transmitted back and converted from RawVal back into their type.The values in a Vec are not guaranteed to be of any specific type and conversion will fail if they are not of the expected type. Most functions on Vec return a Result due to this.Map (Map)​Map is a ordered key-value dictionary.The map is ordered by its keys. Iterating a map is stable and always returns the keys and values in order of the keys.The map is stored in the Host and available to the Guest through the functions defined on Map. Values stored in the Map are transmitted to the Host as RawVals, and when retrieved from the Map are transmitted back and converted from RawVal back into their type.The keys and values in a Map are not guaranteed to be of type K/V and conversion will fail if they are not. Most functions on Map return a Result due to this.Maps have at most one entry per key. Setting a value for a key in the map that already has a value for that key replaces the value.Address (Address)​Address is a universal opaque identifier to use in contracts. It may represent a 'classic' Stellar account, a custom account implemented in Soroban or just an arbitrary contract.Address can be used as a contract function input argument (for example, to identify the payment recipient), as a data key (for example, to store the balance), as the authentication & authorization source (for example, to authorize a token transfer) etc.See authorization documentation for more details on how to use the Address type.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/built-in-types","title":"Built-In Types","contentLength":509}},{"pageContent":"Contract LifecycleDevelopment​Contract development can be done on a local computer with as little as 3 necessary components: an IDE, a copy of the Rust toolchain, and a copy of the Soroban SDK.The SDK contains a full working copy of the host environment, as well as a \"mock\" version of the ledger for persistent storage of contract data. It is therefore possible (and encouraged) to edit, compile, test and debug contracts directly against this \"local\" copy of the host, entirely offline and without even accessing a test network.To make the local development process even more convenient and fast, the contract being developed can (and should) be compiled as native code and linked directly to the local host, rather than compiled to Wasm and run in a local VM sandbox. Both configurations are possible, but the native configuration is fastest and provides the richest testing and debugging experience.The SDK-provided local contract host also contains a local web server that serves the necessary HTTP API endpoint used for client applications to interact with a contract. This can be used for local development of applications, again without needing to deploy contracts to any test or live network.Deployment​Once a contract has been tested and debugged locally, it can be deployed. To do this it must be compiled to Wasm code, and then included by value in a transaction sent to the intended deployment network.The SDK provides a command-line utility that invokes the Rust compiler with the correct settings for producing a Wasm bundle for deployment, but developers can also build this themselves.Before submitting to the network, developers should inspect the resulting Wasm binary emitted by the Rust compiler to ensure that it contains only the intended code and data, and is as small as possible. The SDK command-line utility contains diagnostic commands to assist with this process.The SDK command-line utility can also build and submit the transaction deploying a Wasm contract to the network. Deployment requires sufficient network credentials to sign a transaction performing the deployment and pay its fees. Contracts should be deployed to test networks and thoroughly tested there before being deployed to the live network.Execution​Deployed contracts live on chain in a CONTRACT_DATA ledger entry. They are executed within a VM sandbox managed by a host environment inside stellar-core. Each transaction that leads to a contract execution is run in a separate host environment, and each contract called by such a transaction (either directly or indirectly from another contract) is executed in a separate guest Wasm VM contained within the transaction’s host environment.Execution is initiated by a host function called \"call\". The \"call\" host function can itself be invoked two different ways: either by someone submitting a transaction to the network that invokes \"call\" directly, or indirectly by some other contract invoking \"call\".In either case, the \"call\" host function is provided with the ID of a contract to invoke, the name of a function in the contract, and a vector of argument values to pass. The \"call\" host function then sets up a VM sandbox for the called contract, loads and instantiates its Wasm bytecode, and invokes the named function, passing the provided arguments.Each contract execution continues until the contract either completes successfully or traps with an error condition. If execution completes successfully, all ledger entries modified during execution will be written back to the ledger atomically. If execution traps, all modified ledger entries will be discarded and the contract will have no effect on the ledger.A variety of conditions in either the guest or host environments can cause a contract to trap. If a host function is called with invalid arguments, for example, the host will trap. Similarly if the contract performs an erroneous Wasm bytecode such as a division by zero or access to memory out of bounds, the Wasm VM will trap. Also if the contract uses more resources than its enclosing transaction has paid for, the contract will trap.Monitoring​Contracts can be monitored in two main ways: by observing events emitted during their execution, and by examining the ledger entries written by them.TBD: expand this section.Upgrading contracts​See the Upgrading Contracts page for details on this.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/contract-lifecycle","title":"Contract Lifecycle","contentLength":711}},{"pageContent":"Custom TypesCustom types are struct, union, and enum types defined by contracts. They are usable everywhere primitives types can be used: as contract inputs, outputs, or for storage.infoThe custom types example demonstrates how to define your own types.infoError enum types are another type contracts can define that have some unique behaviors. See Errors for more information.Structs (with Named Fields)​Structs with named fields are stored on ledger as a map of key-value pairs, where the key is a 32 character string representing the field name, and the value is the value encoded.Field names must be no more than 32 characters. Fields with names no longer than 9 characters are slightly more efficient at runtime, though the difference should be marginal most of the time.#[contracttype]#[derive(Clone, Debug, Eq, PartialEq)]pub struct State { pub count: u32, pub last_incr: u32,}When converted to XDR, the value becomes an ScVal, containing an ScMap, containing an array of key-value pairs.{ \"map\": [ { \"key\": { \"symbol\": \"count\" }, \"val\": { \"u32\": 0 } }, { \"key\": { \"symbol\": \"last_incr\" }, \"val\": { \"u32\": 0 } } ]}Structs (with Unnamed Fields)​Structs with unnamed fields are stored on ledger as a vector of values, and are interchangable with tuples and vectors. The elements are placed in the vector in order that they appear in the field list.#[contracttype]#[derive(Clone, Debug, Eq, PartialEq)]pub struct State(pub u32, pub u32);When converted to XDR, the value becomes an ScVal, containing an ScVec, containing an array of values.{ \"vec\": [{ \"u32\": 0 }, { \"u32\": 0 }] }Enum (Unit and Tuple Variants)​Enums containing unit and tuple variants are are stored on ledger as a two element vector, where the first element is the name of the enum variant as a string up to 32 characters in length, and the value is the value if the variant has one.Only unit variants and single value variants, like A and B below, are supported.#[contracttype]#[derive(Clone, Debug, Eq, PartialEq)]pub enum Enum { A, B(u32),}When a unit variant, such as Enum::A, is converted to XDR, the value becomes an ScVal, containing an ScVec, containing an array with a single value, the symbol containing the variant name.{ \"vec\": [{ \"symbol\": \"A\" }] }When a tuple variant, such as Enum::B, is converted to XDR, the value becomes an ScVal, containing an ScVec, containing an array with two values, the symbol containing the variant name and the tuple value.{ \"vec\": [{ \"symbol\": \"B\" }, { \"u32\": 0 }] }When tuple variants containing multiple values are implemented, the values will be included into the vector.Enum (Integer Variants)​Enums containing integer values are stored on ledger as the u32 value.#[contracttype]#[derive(Copy, Clone, Debug, Eq, PartialEq)]#[repr(u32)]pub enum Enum { A = 1, B = 2,}When converted to XDR, the value becomes an ScVal, containing a U32.{ \"u32\": 1 }","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/custom-types","title":"Custom Types","contentLength":467}},{"pageContent":"DebuggingSoroban contracts are as much as possible regular Rust programs and can be debugged using the same tools you'd usually use.The debugging facilities available differ significantly depending on whether a contract is compiled natively for local testing, or compiled into Wasm for deployment.Deciding between these two modes and making the most of them while debugging requires a careful understanding of which code is compiled-in to deployed contracts and which code is only available for local testing.Local-testing mode​It is possible (and encouraged during development) to compile Soroban contracts natively (eg. as x86-64 or AArch64 code) and link against the host environment directly, such that the contract is not a guest running in a Wasm virtual machine at all: it is simply one native library calling another -- its host -- and both host and contract are linked together as a single program, together with a test harness.This configuration is referred to as \"local-testing mode\" and since it eliminates the Wasm virtual machine from the debugging experience it has many advantages:Tests run much faster since there is no VM interpreting them, and will execute in parallel by default on multiple threads.Tests can use numerous standard testing and debugging techniques:The standard Rust #[test] harness, including push-button IDE support for running and re-running single tests.Standard IDE-supported debuggers, including IDE support for setting breakpoints and inspecting values in both contract and host.Lightweight debugging via standard logging or tracing.Systematic testing such as fuzzing, property-testing, or even model checking or formal verification.The simplest of all debugging approaches, printing to standard error.Local-testing mode is the default configuration when compiling code targeting your local computer's CPU and operating system, which is what cargo will do if you set up a new Rust project and don't specify a target.Wasm mode​If on the other hand you wish to compile for deployment, you must tell cargo to build for the Wasm target.Building for Wasm will disable many of the debugging facilities described above, typically for one of three reasons:The Wasm VM simply can't (or the VM we've chosen doesn't) provide them.The Wasm VM could provide them but doing so would violate constraints of the contract Rust dialect.The Wasm VM could provide them but doing so would make the resulting Wasm code impractically large.While we encourage most testing to happen in local-testing mode, some problems will obviously only arise in deployment and some debugging facilities thus remain available even there:A \"sandbox\" host with a mock-ledger that can read and write CONTRACT_DATA ledger entries to the local filesystem.A general logging system that allows contracts to log values of the shared host/guest \"value\" type, even in production.User-extensible Status codes that can be returned from any contract call to indicate problems.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/debugging","title":"Debugging","contentLength":485}},{"pageContent":"Environment ConceptsThe contract environment is an interface that defines the facilities -- objects, functions, data sources, etc. -- available to contracts.Host and Guest​As an interface, the environment has two sides, which we refer to as the host environment and the guest environment. Code in the host environment implements the environment interface; code in the guest environment uses the environment interface.The host environment is provided by a known set of Rust crates, compiled once into stellar-core (or the SDK). Multiple contracts interact with the same host environment, and the host environment has access to any facilities of its enclosing operating system: files, networking, memory, etc.In contrast, a new guest environment is established for each invocation of each smart contract. Each contract sees a single environment interface, and can only call functions provided by the environment interface. In other words, the guest environment is a sandbox for executing arbitrary code within safe parameters.WebAssembly​The on-chain guest environment is isolated inside a WebAssembly (Wasm) virtual machine (\"VM\"). This means that deployed contract code is compiled to Wasm bytecode rather than native machine code. The host environment includes an interpreter for the VM, and a new short-lived VM is instantiated for each call to a contract, running the bytecode for the contract and then exiting.The use of a VM helps provide security against any potential guest-code misbehavior, to both host and other guest environments, as well as ensuring portability of guest code between hosts running on different types of hardware.When developing and testing contract code off-chain, it is possible to compile contract code to native machine code rather than Wasm bytecode, and to run tests and debug contracts against a local copy of the host environment by linking directly to it, rather than executing within a VM. This configuration runs much faster and provides much better debugging information, but is only possible locally, off-chain. On-chain deployed contracts are always Wasm.WebAssembly is a relatively low-level VM, which means that it does not provide a very rich set of standard or \"built-in\" operations. In contrast to VMs like the JVM, it has no garbage collector (not even a memory allocator), no IO facilities, no standard data structures like lists, arrays, maps or strings, no concepts of objects or types at all besides basic machine types like 32 and 64-bit integers.As a result, programs compiled to Wasm bytecode often face a dilemma: if they want rich standard functionality, they must often include a copy of all the \"support code\" for that functionality within themselves. But if they do, they dramatically increase their code size, which incurs costs and limits performance. Moreover, including such support code limits their ability to interoperate with other programs that may include different, incompatible support code.The way out of this dilemma is for the environment itself to provide support code for rich standard functionality, in the form of host objects and functions that guest code can use by reference. Each contract refers to the same functionality implemented in the host, ensuring much smaller code size, higher performance, and greater interoperability between contracts. This is what Soroban does.Host objects and functions​Shared, standard functionality available to all contract guest code is provided through the environment interface in terms of host objects and host functions.The environment supports a small number of types of host objects covering data structures like vectors, maps, binary blobs, and arbitrary precision numbers. Host objects are all immutable, are allocated and reside within the host environment, and are only available in the guest environment by reference. Guest code refers to host objects by integer-valued handles.There is also a slightly larger set of host functions that act on host objects: creating, modifying, inspecting and manipulating them. Some host functions allow copying blocks of binary data into and out of the VM memory of the guest, and some host functions perform cryptographic operations on host objects.There are also host functions for interacting with select components of the host environment beyond the host object repertoire, such as reading and writing ledger entries, emitting events, calling other contracts, and accessing information about the transaction context in which guest code is executing.Serialization​Host objects can be passed (by handle) directly to storage routines or between collaborating contracts. No serialization or deserialization code needs to exist in the guest: the host knows how to serialize and deserialize all of its object types and does so transparently whenever necessary.Values and types​All host functions can accept as arguments and return values from, at most, the limited Wasm VM repertoire of machine-level types. To simplify matters, Soroban further limits all host functions to passing and returning values from within a single specialized form of 64-bit integers called \"value\" or \"the value type\". Through careful bit-packing, the value type can encode any of several separate types more meaningful to users than just \"integers\".Specifically, the value type can directly encode 63-bit unsigned integers (equivalent to positive signed 64-bit numbers), but also boolean true and false, signed or unsigned 32-bit integers, typed host object handles, typed error codes, small symbols (up to 10 latin-alphanumeric characters), small bitsets (up to 60 bits), or a unique void value. Individual bits in a value are allocated to tagging and switching between these cases dynamically, and host functions or objects that require specific cases may reject values of other cases.Since the value type can contain a handle to a host object, any container object that can contain the value type can in fact hold any object. Therefore the host map and vector types -- container data structures -- are defined merely as containers for the value type, where the specific case of each value may vary from container to container or even among the elements of a container. In this way, the host container types are more like the containers of dynamic-typed languages like JavaScript or Python. The SDK also provides static, uniformly-typed wrappers when this is desired, prohibiting values outside the designated case from being added to the container.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/environment-concepts","title":"Environment Concepts","contentLength":1028}},{"pageContent":"ErrorsThere are a number of ways to generate errors in contracts.One way is error enum types, that are defined by contracts and that map errors to unsigned 32-bit integer values. They are usable as error values in the return types of contract functions.infoThe errors example demonstrates how to define your own error types.Error Enums​Errors are a special type of enum integer type that are stored on ledger as Status values containing a u32 code.#[contracterror]#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]#[repr(u32)]pub enum Error { AnError = 1,}When converted to XDR, the value becomes an ScVal, containing a ScStatus, containing the integer value of the error as contract error.{ \"status\": { \"contractError\": 1 } }","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/errors","title":"Errors","contentLength":120}},{"pageContent":"EventsEvents are the mechanism that applications off-chain can use to monitor changes and events in contracts on-chain.How are events emitted?​ContractEvents are emitted in Stellar Core's TransactionMeta. You can see in the TransactionMetaV3 XDR below that there is a list of OperationEvents called events. Each OperationEvent corresponds to an operation in a transaction, and itself contains a list of ContractEvents. Note that events will only be populated if the transaction succeeds. Take a look at this example to learn more about how to emit an event in your contract.ContractEvent​struct ContractEvent{ // We can use this to add more fields, or because it // is first, to change ContractEvent into a union. ExtensionPoint ext; Hash* contractID; ContractEventType type; union switch (int v) { case 0: struct { SCVec topics; SCVal data; } v0; } body;};OperationEvents​struct OperationEvents{ ContractEvent events<>;};TransactionMetaV3​struct TransactionMetaV3{ LedgerEntryChanges txChangesBefore; // tx level changes before operations // are applied if any OperationMeta operations<>; // meta for each operation LedgerEntryChanges txChangesAfter; // tx level changes after operations are // applied if any OperationEvents events<>; // custom events populated by the // contracts themselves. One list per operation. TransactionResult txResult; Hash hashes[3]; // stores sha256(txChangesBefore, operations, txChangesAfter), // sha256(events), and sha256(txResult) // Diagnostics events that are not hashed. One list per operation. // This will contain all contract and diagnostic events. Even ones // that were emitted in a failed contract call. OperationDiagnosticEvents diagnosticEvents<>;};Link to the XDR above.Event types​There are three ContractEventType's -CONTRACT events are events emitted by contracts that use the contract_event host function to convey state changes.SYSTEM events are events emitted by the host. At the moment, there's only one system event emitted by the host. It is emitted when the update_current_contract_wasm host function is called, where topics = [\"executable_update\", old_executable: ContractExecutable, old_executable: ContractExecutable] and data = [].DIAGNOSTIC events are meant for debugging and will not be emitted unless the host instance explictly enables it. You can read more about this below.What are diagnosticEvents?​While looking at the TransactionMetaV3 XDR struct above, you may have noticed the diagnosticEvents field. This list will be empty by default unless your stellar-core instance has ENABLE_SOROBAN_DIAGNOSTIC_EVENTS=true in its config file. If diagnostic events are enabled, this list will not only include all ContractEvents in events, but will also include events from failed contract calls, errors from the host, events to trace the contract call stack, and logs from the log_from_linear_memory host function. These events can be identified by type == DIAGNOSTIC. The diagnostic events emitted by the host to track the call stack are defined below.fn_call​The fn_call diagnostic event is emitted when a contract is called and contains -TopicsThe symbol \"fn_call\".The contract id of the contract about to be called.A symbol containing the name of the function being called.DataA vector of the arguments passed to the function being called.fn_return​The fn_return diagnostic event is emitted when a contract call completes and contains -TopicsThe symbol \"fn_return\".A symbol containing the name of the function that is about to return.DataThe value returned by the contract function.When should diagnostic events be enabled?​events contain ContractEvents that should convey information about state changes. diagnosticEvents on the other hand contain events that are not useful for most users, but may be helpful in debugging issues or building the contract call stack. Because they won't be used by most users, they can be optionally enabled because they are not hashed into the ledger, and therefore are not part of the protocol. This is done so a stellar-core node can stay in sync with the network while emitting these events that normally would not be useful for most users.Due to the fact that a node with diagnostic events enabled will be excuting code paths that diverge from a regular node, we highly encourage only using this feature on watcher node (nodes where NODE_IS_VALIDATOR=false is set).","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/events","title":"Events","contentLength":648}},{"pageContent":"Fees and MeteringcautionSoroban is still under active development. While the fee model described here is unlikely to change, the exact values of the fee rates and limits remain undetermined.Fee ModelExecuting a Soroban transaction on the Stellar network requires a fee. This measure helps prevent spam and allows multiple parties to compete for inclusion in the ledger in case of traffic surges. The fee is paid using the native Stellar token (lumens, also known as XLM).The Soroban transaction fee comprises two parts: the resource fee and the inclusion fee.The resource fee is the amount of lumens the submitter must pay for their transaction to be included in the ledger. It depends solely on the amount of resources the transaction needs for execution. There is no auction for the resource fee; it simply must be paid if the transaction is included in the ledger.The inclusion fee is the maximum fee bid the submitter is willing to pay for inclusion. It is used to prioritize transactions — the transaction with the higher inclusion fee is included in the ledger before those with lower inclusion fees. The inclusion fee can be discounted depending on the traffic. If the ledger is not at capacity, only the minimal base fee is charged (100 stroops or 10^-5 XLM). If the ledger is at capacity, then the lowest inclusion fee bid is charged. In general, the behavior of the inclusion fee and bidding strategies align with the classic Stellar fees.The remainder of this chapter focuses on resource fees, as they are specific to Soroban.Resource fee​Soroban uses a multi-dimensional fee model that charges fees for several resource types using network-defined rates. The resource fee is calculated based on the resource consumption declared in the transaction. If the transaction attempts to exceed the declared resource limit, it will fail. If the transaction uses fewer resources than declared, there will be no refunds, with a few exceptions.The resource fee depends on the following:Instructions: the number of CPU instructions the transaction uses, metered by the Soroban host.Ledger entry accesses: Reading or writing any single ledger entry (any storage key in the contract context).Ledger I/O: The number of bytes read from or written to the ledger.Transaction size: The size of the transaction submitted to the network in bytes.Metadata size: The size of the metadata produced by the contract. Metadata consists of the changed ledger entries (essentially an additional charge for ledger I/O) and size of the events emitted by the contract.Some parameters may contribute to multiple fee components. For example, the transaction size is charged for network propagation (as network bandwidth is limited) and for historical storage (as storing ledger history is not free).The implementation details for fee computation are provided by the following library. This library is used by the protocol to compute the fees and thus can be considered canonical. The resource fee rates may be updated based on network validator consensus.The precise network fee rates will be defined in the upcoming mainnet release. The Futurenet preview release uses placeholder values.The best way to find the required fees for any Soroban transaction is to use the transaction simulation with preflight service.Refundable resources​The only refundable resource at the moment is metadata. If the transaction emits less metadata than declared, the network will refund the difference in fees.Resource limits​Ledger close time is constrained to a few seconds, thus preventing the execution of arbitrarily large transactions, regardless of the resource fees involved. All the resources referenced in the prior section are subject to a per-transaction limit. Additionally, the memory (RAM) usage by a transaction is capped, though it is not subject to any charge.The limits are may change in the mainnet release. They can also be updated, usually increased, based on the network validator consensus.The current (Futurenet) limits are as follows:ResourceLimitCPU Instructions100,000,000RAM100 MBLedger Entry Reads40Ledger Entry Writes20Ledger Read Bytes200 KBLedger Write Bytes100 KBTransaction Size100 KBMetadata Size200 KBApart from these resource limits, there is also a maximum contract size limit of 64 KB.MeteringMetering is a crucial mechanism within the host environment that accounts for the resource costs, such as CPU instructions and RAM usage, incurred during the execution of a smart contract. The outcomes of metering act as the canonical truth of a smart contract's execution cost and serve as an input for fee computations.Why Metering​The Soroban smart contract execution environment comprises a host and a guest. The host encapsulates shared functionalities for all contracts, including host objects, functions, and a Wasm interpreter (VM). The guest environment is where the compiled Wasm contract is interpreted and executed. Detailed discussion about these environments can be found in Environment Concepts.The division between the host and guest environments, and the shared functionalities between them, necessitates a unique approach to resource accounting. In particular, the resources required for executing Wasm instructions and running host functions must be accounted for uniformly, with costs denoted in terms of CPU instructions and memory bytes. Consider two contracts, A and B, both comprising the same number of Wasm instructions. If Contract A repeatedly calls host functions for complex computations while Contract B executes pure arithmetic operations within the VM, Contract A should be more costly. This difference should be accurately represented in the metering process.In essence, metering ensures fairness, thwarts resource manipulation and attacks, and generates a deterministic and reproducible measure of runtime resource costs.Methodology​To maintain equivalence in metering between the host and guest, computation costs on both sides are expressed in terms of cpu instructions and memory bytes (representing CPU and RAM usage). Metering and limit-checking occur within the host environment, and pre-calibrated numerical models are used to ensure results are deterministic.Cost Types​Metering is segmented into host components, referred to as cost types. Each cost type can be viewed as a \"meta instruction\" symbolizing a specific host operation, having a known complexity and depends on a runtime input. For instance, cost type ComputeSha256Hash represents the cost of computing the SHA256 hash of a byte array.infoExecution of Wasm instructions is accounted for as a host cost type WasmInsnExec, which has a constant CPU cost per Wasm instruction. This methodology treats guest instructions and host executions equivalently.For a complete list of host cost types and their definitions, please refer to ContractCostType.Cost Parameters​The cost types are carefully selected to:Serve as comprehensive building blocks for all significant contract execution costs.Ensure each component cost increases at most linearly (i.e., constant or linear) with respect to its input. That is, y = a + bx, where y is the cost output, x is the input, and a, b are the constant and linear model parameters, respectively.Each cost type has a separate model for both resource types (CPU and memory).The parameters for each model, a and b, are calibrated and fitted offline against inputs of various sizes. The collection of all model cost parameters form the network configurable entries (see ConfigSettingsEntry), which can be updated through network consensus.Metering Process​Before contract execution, the host environment is prepared with the cost parameters and a budget defining the resource limits. Metering is then implemented to measure the cumulative resource consumption during host execution.During execution, whenever a component (a code block defining a cost type) is encountered, the corresponding model computes the resource output from the runtime input and increments the meter accordingly. The meter checks the cumulative consumption against the budget limit. If the limit is exceeded, an error is produced, and execution is terminated.If the contract execution concludes within the specified resource limits, the metered total of CPU instructions is recorded and utilized as the input for fee calculation. Note that while memory usage is not included in the fee computation, it is nevertheless subject to the resource limits.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/fees-and-metering","title":"Fees and MeteringFee ModelMetering","contentLength":1322}},{"pageContent":"Fully-Typed ContractsWhen you compile a contract created with soroban-sdk, the Wasm file ends up with a custom section containing a machine-readable description of your contract's interface types, sometimes called its spec or its API. This is similar to ABIs in Ethereum, except that Soroban will store every single one of them on-chain from day one, and they include the comments from the contract's author.Today, these interface types are formatted using XDR, but this may change down the road.The important part is that tooling can fetch these interface types to make your life easier. Soroban CLI is the first tool to do so. Specifically, one subcommand:soroban contract invoke​Really, every smart contract is its own program, and deserves its own CLI.So that's what Soroban CLI gives you.A unique CLI for each smart contract. Constructed on-the-fly, right from the on-chain interface types. Including the author's comments. An implicit CLI.With aliases in your shell, you can also easily make explicit CLIs out of your most-used contracts. For example, if you use the Smart Deploy contract:$ alias smartdeploy=\"soroban contract invoke --id 6808e8e2cce73cfca472a8197080938b320d72e7b696e34eb52ebf17070f4ee --\"$ smartdeploy --helpUsage: 6808e8e2cce73cfca472a8197080938b320d72e7b696e34eb52ebf17070f4ee [COMMAND]Commands: register_name Register a contract name to allow publishing. publish Publish a contract. Currently a contract's version is a `u32` and publishing will increment it. If no repo is provided, then the previously published binary's repo will be used. If it's the first time then it will be empty. fetch Fetch the hash for a given contract_name. If version is not provided, it is the most recent version. fetch_metadata Fetch metadata for a given contract_name. If version is not provided, it is the most recent version. deploy Deploys a new published contract returning the deployed contract's id. help Print this message or the help of the given subcommand(s)Options: -h, --help Print helpLike any other CLI, you can also get help for any of these subcommands using something like smartdeploy deploy --help. Soroban CLI again fetches the on-chain interface types, this time using it to generate a full list of all arguments to the function, and even generates examples. And just to be totally clear, you don't need to alias these commands. This would work, too:soroban contract invoke --id 6808e8e2cce73cfca472a8197080938b320d72e7b696e34eb52ebf17070f4ee -- deploy --helpOr, if you clone soroban-examples and make build them all, you can get CLI help for any individual contract or a specific function within a contract:$ soroban contract invoke --id 1 --wasm target/wasm32-unknown-unknown/release/soroban_hello_world_contract.wasm -- hello --helpUsage: hello [OPTIONS]Options: --to <Symbol> Example: --to hello -h, --help Print help (see a summary with '-h')If you're unfamiliar with the -- double dash separator, this is a pattern used by other CLIs. Everything after the double dash, sometimes called the slop, gets passed to the child process. An example of another CLI that makes use of this is cargo run.Of course, the exact way that that Soroban CLI parses arguments is an ongoing design discussion. Representing complex custom arguments on the command line is a design challenge no blockchain CLI gets perfect yet; many, including Soroban CLI, currently use JSON. But this has downsides, and other options are possible. How would you like to see it work?Already the best; just getting started​We love that Soroban will have all contract interface types available on-chain right from day one. No secondary API calls to external services, no secondary API token management, no signing in or creating an account anywhere else, and near-perfect reliability. It's a game-changer within the blockchain space.Soroban CLI already shows how this can be built into foundational tooling to give developers delightful experiences. And this is only the beginning. At every level of the stack, you can expect—and build—tooling that makes interacting with any contract predictable and seamless.Soon we'll have TypeScript/JavaScript libraries that mirror the behavior of soroban contract invoke, customized for browser & nodejs environments. You can expect GUIs that adapt to any given contract on-the-fly, functioning as interactive documentation. If you're writing contracts that make cross-contract calls, most of the code you need can also be auto-generated.And that's still all just the beginning. With those as the foundations, what else can we build? What else can you imagine? What is the future of components, now that one small program, aka smart contract, can be easily interacted with at all layers of the software stack? When considered in combination with Wasm—on-chain, in-browser, and elsewhere—what possibilities for interop can we imagine and co-create?We can't wait to see what you build.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/fully-typed-contracts","title":"Fully-Typed Contracts","contentLength":791}},{"pageContent":"Interacting with ContractsThree types of interactions​Function call​A function call is the simplest and least expensive kind of contract interaction. A function call does exactly what you would expect a contract call to do in any other software development context: the contract transfers control and data to another part of the same contract. Because a function call always transfers control to the same contract, they do not change the values returned by get_current_contract and get_invoking_contract. A function call is the only way to access the private methods of a contract, although it can also be used to access the public methods of a contract.To perform a function call, simply make a Rust function call.Contract invocation​A contract invocation is a more powerful and more expensive kind of contract interaction. A contract invocation is similar to starting a new process because the code that runs will be in a separate address space, meaning that they do not share any data other than what was passed in the invocation. While a contract invocation typically transfers control to a different contract, it is possible to transfer control to the currently running contract. Regardless of whether the contract that receives control is a different contract or the currently running contract, the value returned by get_invoking_contract will be the previous value of get_current_contract. A contract invocation can only access the public methods of a contract.If a contract contains a public function f, then invoking f can be done by making a Rust function call to f::invoke.Some contracts, such as the token contract, only export the contract invocation functions. In doing so, they are able to assign those functions friendly names. For example, initialize#[contractimpl(export_if = \"export\")]impl TokenTrait for Token { fn initialize(e: Env, admin: Identifier, decimal: u32, name: Binary, symbol: Binary) {is exported aspub use crate::contract::initialize::invoke as initialize;This function is then easily called by the liquidity pool contract.Stellar Operation​A Stellar operation is the ultimate entry point of every contract interaction. An operation transfers control and external data to a contract, allowing execution to begin.This kind of interaction is currently supported in experimental versions of stellar-core only.Interacting with contracts in tests​Debugging contracts explains that it is much more convenient to debug using native code than Wasm. Given that you are testing native code, it is tempting to interact with your contract directly using function calls. If you attempt this approach, you will find that it doesn't always work. Function call interactions do not set the environment into the correct state for contract execution, so functions involving contract data and determining the current or invoking contract will not work.When writing tests, it is important to always interact with contracts through contract invocation. In a production setting, contract invocation will execute Wasm bytecode loaded from the ledger. So how does this work if you are testing native code? You must register your contract with the environment, so it knows what functions are available and how to call them. While this sounds complex, the contractimpl procedural macro automatically generates almost all the code to do this. All you have to do is write a small stub to actually call the generated code, such aspub fn register_test_contract(e: &Env, contract_id: &[u8; 32]) { let contract_id = FixedBinary::from_array(e, *contract_id); e.register_contract(&contract_id, crate::contract::Token {});}Some contracts, such as the token contract, also provide a friendlier interface to facilitate testing. There are many ways these interfaces might make testing easier, but one common one is to allow automatic message signing by passing a ed25519_dalek::Keypair.Note that everything described in this section is only available if the testutils feature is enabled.Example​This machinery can also be used to test multiple contracts together. For example, the single offer contract test case creates a token.Calling contracts​Contracts are invoked through a pair of host functions call and try_call:try_call(contract, function, args) calls function exported from contract, passing args and returning a Status on any error.call(contract, function, args) just calls try_call with its arguments and traps on Status, essentially propagating the error.In both cases contract is a Binary host object containing the contract ID, function is a Symbol holding the name of an exported function to call, and args is a Vector of values to pass as arguments.These host functions can be invoked in two separate ways:From outside the host, such as when a user submits a transaction that calls a contract.From within the host, when one contract calls another.Both cases follow the same logic:The contract's Wasm bytecode is retrieved from a CONTRACT_DATA ledger entry in the host's storage system.A Wasm VM is instantiated for the duration of the invocation.The function is looked up and invoked, with arguments passed from caller to callee.When a call occurs from outside the host, any arguments will typically be provided in serialized XDR form accompanying the transaction, and will be deserialized and converted to host objects automatically before invoking the contract.When a call occurs from inside the host, the caller and callee contracts share the same host and the caller can pass references to host objects directly to the callee without any need to serialize or deserialize them.Since host objects are immutable, there is limited risk to passing a shared reference from one contract to another: the callee cannot modify the object in a way that would surprise the caller, only create new objects.Preflight​Footprint​As mentioned in the persisting data section, a contract can only load or store CONTRACT_DATA entries that are declared in a footprint associated with its invocation.A footprint is a set of ledger keys, each marked as either read-only or read-write. Read-only keys are available to the transaction for reading, read-write available for reading, writing or both.Any transaction submitted by a user has to be accompanied by a footprint. A single footprint encompasses all the data read and written by all contracts transitively invoked by the transaction: not just the initial contract that the transaction calls, but also all contracts it calls, and so on.Since it can be difficult for a user to always know which ledger entries a given contract call will attempt to read or write -- especially those caused by contracts called by other contracts deep within a transaction -- the host provides an auxiliary \"preflight\" mechanism that executes a transaction against a temporary, possibly slightly-stale snapshot of the ledger. The preflight mechanism is not constrained to only read or write the contents of a footprint; rather it records a footprint describing the transaction's execution, discards the execution's effects, and then returns the recorded footprint it to its caller.Such a preflight-provided footprint can then be used to accompany a \"real\" submission of the same transaction to the network for real execution. If the state of the ledger has changed too much between the time of the preflight and the real submission, the footprint may be too stale and no longer accurately identify the keys the transaction needs to read and write, at which point the preflight must be retried to refresh the footprint.In any event -- whether successful or failing -- the real transaction will execute atomically, deterministically and with serializable consistency semantics. An inaccurate footprint simply causes deterministic transaction failure, not a stale-read anomaly. All effects of such a failed transaction are discarded, as they would be in the presence of any other error.Authorization​See authorization overview and authorization in transactions section for general information on Soroban authorization.Preflight mechanism can also be used to compute the SorobanAuthorizedInvocation trees that have to be authorized by the Addresses in order for all the require_auth checks to pass.Soroban host provides a special 'recording' mode for auth. Whenever require_auth is called host records its context (address, contract id, function, arguments), attributes it to an SorobanAuthorizedInvocation tree, and marks it as successful. Then after the invocation has finished, preflight can return all the recorded trees, as well as the generated random nonce values.Given this information from preflight, the client only needs to provide these trees and nonces to the respective Addresses for signing and then build the final transaction using the preflight output and the corresponding signatures.The recording auth mode is optional for preflight. For example, when dealing with the custom account contracts, it may be necessary to preflight the custom account's __check_auth code (that is simply omitted in the recording auth mode), for example, to get its ledger footprint. The non-recording mode is referred to as 'enforcing'. Enforcing mode is basically equivalent to running the transaction on-chain (with possibly a slightly stale ledger state) and hence it requires all the signatures to be valid.Note, that the recording auth mode never emulates authorization failures. The reason for that is that failing authorization is always an exceptional situation (the Addresses for which you don't anticipate successful authorization shouldn't be used in the first place). It is similar to how, for example, the preflight doesn't emulate failures caused by the incorrect footprint. Preflight with enforcing auth mode may still be used to verify the signatures before executing the transaction on-chain.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/interacting-with-contracts","title":"Interacting with Contracts","contentLength":1554}},{"pageContent":"Interacting with Soroban via StellarStellar supports invoking and deploying contracts with a new Operation named InvokeHostFunctionOp. The soroban-cli abstracts these details away from the user, but SDKs do not yet and if you're building a dapp you'll probably find yourself building the XDR transaction to submit to the network.The InvokeHostFunctionOp can be used to perform the following Soroban operations:Invoke contract functions.Upload Wasm of the new contracts.Deploy new contracts using the uploaded Wasm or built-in implementations (this currently includes only the token contract).There is only a single InvokeHostFunctionOp allowed per transaction. Contracts should be used to perform multiple actions atomically, for example, to deploy a new contract and initialize it atomically.InvokeHostFunctionOp​The XDR of HostFunction and InvokeHostFunctionOp below can be found here.union HostFunction switch (HostFunctionType type){case HOST_FUNCTION_TYPE_INVOKE_CONTRACT: SCVec invokeContract;case HOST_FUNCTION_TYPE_CREATE_CONTRACT: CreateContractArgs createContract;case HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASM: opaque wasm<>;};struct InvokeHostFunctionOp{ // Host function to invoke. HostFunction hostFunction; // Per-address authorizations for this host function. SorobanAuthorizationEntry auth<>;};Function​The hostFunction in InvokeHostFunctionOp will be executed by the Soroban host environment. The supported functions are:HOST_FUNCTION_TYPE_INVOKE_CONTRACTThis will invoke a function of the deployed contract with arguments specified in invokeContract vector.invokeContract arguments are expected to contain the contract id SCBytes, contract function name SCSymbol, and the arguments of the contract function being invoked.HOST_FUNCTION_TYPE_UPLOAD_CONTRACT_WASMThis will upload the contract Wasm using the provided wasm blob.Uploaded Wasm can be identified by the SHA-256 hash of the uploaded Wasm.HOST_FUNCTION_TYPE_CREATE_CONTRACTThis will deploy a contract instance to the network using the specified executable. The 32-byte contract identifer is based on contractIDPreimage value and the network identifier (so every network has a separate contract identifier namespace).struct CreateContractArgs{ ContractIDPreimage contractIDPreimage; ContractExecutable executable;};executable can be either a SHA-256 hash of the previously uploaded Wasm or it can specify that a built-in contract has to be used:enum ContractExecutableType{ CONTRACT_EXECUTABLE_WASM = 0, CONTRACT_EXECUTABLE_TOKEN = 1};union ContractExecutable switch (ContractExecutableType type){case CONTRACT_EXECUTABLE_WASM: Hash wasm_hash;case CONTRACT_EXECUTABLE_TOKEN: void;};contractIDPreimage is defined as following:union ContractIDPreimage switch (ContractIDPreimageType type){case CONTRACT_ID_PREIMAGE_FROM_ADDRESS: struct { SCAddress address; uint256 salt; } fromAddress;case CONTRACT_ID_PREIMAGE_FROM_ASSET: Asset fromAsset;};The final contract identifier is created by computing SHA-256 of this together with the network identifier as a part of HashIDPreimage:union HashIDPreimage switch (EnvelopeType type){...case ENVELOPE_TYPE_CONTRACT_ID: struct { Hash networkID; ContractIDPreimage contractIDPreimage; } contractID;...CONTRACT_ID_PREIMAGE_FROM_ADDRESS specifies that the contract will be created using the provided address and salt. This operation has to be authorized by address (see the following section for details).CONTRACT_ID_FROM_ASSET specifies that the contract will be created using the Stellar asset. This is only supported when executable == CONTRACT_EXECUTABLE_TOKEN. Note, that the asset doesn't need to exist when this is applied, however the issuer of the asset will be the initial token administrator. Anyone can deploy asset contracts.Authorization Data​Soroban authorization framework provides a standardized way for passing authorization data to the contract invocations via SorobanAuthorizationEntry structures.struct SorobanAuthorizationEntry{ SorobanCredentials credentials; SorobanAuthorizedInvocation rootInvocation;};union SorobanCredentials switch (SorobanCredentialsType type){case SOROBAN_CREDENTIALS_SOURCE_ACCOUNT: void;case SOROBAN_CREDENTIALS_ADDRESS: SorobanAddressCredentials address;};SorobanAuthorizationEntry contains a tree of invocations with rootInvocation as a root. This tree is authorized by a user specified in credentials.SorobanAddressCredentials have 2 options:SOROBAN_CREDENTIALS_SOURCE_ACCOUNT - this simply uses the signature of the transaction (or operation, if any) source account and hence doesn't require any additional payload.SOROBAN_CREDENTIALS_ADDRESS - contains SorobanAddressCredentials with the following structure:struct SorobanAddressCredentials{ SCAddress address; int64 nonce; uint32 signatureExpirationLedger; SCVec signatureArgs;};The fields of this structure have the following semantics:When address is the address that authorizes invocation.signatureExpirationLedger the ledger sequence number on which the signature expires. Signature is still considered valid on signatureExpirationLedger, but it is no longer valid on signatureExpirationLedger + 1. It is recommended to keep this as small as viable, as it makes the transaction cheaper.nonce is an arbitrary value that is unique for all the signatures of performed by address until signatureExpirationLedger. A good approach to generating this is to just use a random value.signatureArgs - signature (or multiple signatures) that sign the 32-byte SHA-256 hash of ENVELOPE_TYPE_SOROBAN_AUTHORIZATION preimage (XDR). The signature structure is defined by the account contract corresponding to the Address (see below for the Stellar account signature structure).SorobanAuthorizedInvocation defines a node in the authorized invocation tree:struct SorobanAuthorizedInvocation{ SorobanAuthorizedFunction function; SorobanAuthorizedInvocation subInvocations<>;};union SorobanAuthorizedFunction switch (SorobanAuthorizedFunctionType type){case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN: SorobanAuthorizedContractFunction contractFn;case SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN: CreateContractArgs createContractHostFn;};struct SorobanAuthorizedContractFunction{ SCAddress contractAddress; SCSymbol functionName; SCVec args;};SorobanAuthorizedInvocation consists of the function that is being authorized (either contract function or a host function) and authorized sub-invocations that function performs (if any).SorobanAuthorizedFunction has two variants:SOROBAN_AUTHORIZED_FUNCTION_TYPE_CONTRACT_FN is a contract function that includes the address of the contract, name of the function being invoked and arguments of require_auth/require_auth_for_args call performed on behalf of the address. Note, that if require_auth[_for_args] wasn't called, there shouldn't be a SorobanAuthorizedInvocation entry in the transaction.SOROBAN_AUTHORIZED_FUNCTION_TYPE_CREATE_CONTRACT_HOST_FN is authorization for HOST_FUNCTION_TYPE_CREATE_CONTRACT or for create_contract host function called from a contract. It only contains the CreateContractArgs XDR structure corresponding to the created contract.Building SorobanAuthorizedInvocation trees may be simplified by using the recording auth mode in Soroban preflight (see the docs for more details).Stellar Account Signatures​signatureArgs format is user-defined for the custom accounts, but it is protocol-defined for the Stellar accounts.The signatures for the Stellar account are a vector of the following Soroban structures in the Soroban SDK format:#[contracttype]pub struct AccountEd25519Signature { pub public_key: BytesN<32>, pub signature: BytesN<64>,}Transaction resources​Every Soroban transaction has to have a SorobanTransactionData transaction extension populated. This is needed to compute the Soroban resource fee.The Soroban transaction data is defined as follows:struct SorobanResources{ // The ledger footprint of the transaction. LedgerFootprint footprint; // The maximum number of instructions this transaction can use uint32 instructions; // The maximum number of bytes this transaction can read from ledger uint32 readBytes; // The maximum number of bytes this transaction can write to ledger uint32 writeBytes; // Maximum size of dynamic metadata produced by this contract ( // currently only includes the events). uint32 extendedMetaDataSizeBytes;};struct SorobanTransactionData{ SorobanResources resources; // Portion of transaction `fee` allocated to refundable fees. int64 refundableFee; ExtensionPoint ext;};This data comprises two parts: Soroban resources and the refundableFee. The refundableFee is the portion of the transaction fee eligible for refund. It should currently be no less than the metadata fee of the transaction.The SorobanResources structure includes the ledger footprint and the resource values, which together determine the resource consumption limit and the resource fee. The footprint must contain the LedgerKeys that will be read and/or written.The simplest method to determine the values in SorobanResources is to use the transaction simulation with preflight service.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/invoking-contracts-with-transactions","title":"Interacting with Soroban via Stellar","contentLength":1105}},{"pageContent":"IntroductionWe are excited to introduce you to Soroban, a powerful smart contracts platform designed to be sensible, built-to-scale, and developer-friendly, with a focus on Rust's performance and safety benefits. With its user-friendly interface and powerful features, Soroban offers an ideal platform for developers who are seeking a more efficient and effective way to build decentralized applications and transition from Solidity to Rust. In this article, we will explore the fundamentals of Solidity, Rust, and Soroban, and guide you through setting up the development environment to start your journey with Soroban's Rust smart contract compatibility.Solidity and dApp Development​Solidity is a high-level, statically-typed programming language primarily used for developing smart contracts on the Ethereum Virtual Machine (EVM). It enables the creation of decentralized applications (dApps) that can run on various blockchain platforms, automating complex transactions and interactions without the need for a central authority.Rust: Performance and Safety​Rust is a systems programming language that emphasizes safety, concurrency, and performance. Its unique features, such as a strong static type system, ownership model, and memory safety guarantees, make it an ideal choice for developing high-performance, secure applications, including smart contracts.Soroban: Programmable Logic​Soroban, a sensible and built-to-scale smart contracts platform, offers a developer-friendly and batteries-included experience. While it shares the same principles of scalability and practicality as Stellar, Soroban can also function as a standalone platform and integrate with other transaction processors, such as L2s, permissioned ledgers, and even other blockchains. With Soroban, Classic Stellar gains the added functionality of programmable logic in the form of custom operations encapsulated within smart contracts.You can learn more about Soroban's features and benefits in the Soroban Welcome Page.Setting Up the Development Environment for Rust and Soroban​To get started with Rust and Soroban, follow the steps on the Setup Page.Or if you want to jump right in, you can open up our examples in a ready to go dev Environment in Gitpod by clicking the button below:SummaryAs you embark on your journey with Soroban, remember that the platform is designed to provide a seamless, efficient, and enjoyable experience for developers transitioning from Solidity to Rust. By leveraging Rust's performance and safety benefits, alongside Soroban's advanced tooling, you'll be well-equipped to develop high-quality, efficient, and secure smart contracts.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/migrating-from-evm/introduction-to-solidity-and-rust","title":"IntroductionSummary","contentLength":397}},{"pageContent":"Getting Started with Rust and SolidityIn this tutorial, we'll explore Rust and Solidity, two powerful programming languages. Rust, a systems programming language, is renowned for its safety, concurrency, and performance features, which can be advantageous when building smart contracts. On the other hand, Solidity is a high-level language specifically designed for creating smart contracts on the Ethereum Virtual Machine. This section aims to provide a high-level overview of the similarities and differences between the two languages.Table of Contents​Solidity Syntax, Data Types, and Basic ConstructsRust Syntax, Data Types, and Ownership ModelWriting and Interacting With Simple Smart ContractsSolidity Syntax​Solidity is a programming language designed specifically for creating smart contracts on the Ethereum Virtual Machine (EVM). It has a syntax similar to JavaScript and supports a variety of data types and constructs.pragma solidity ^0.8.0;contract HelloWorld { function sayHello() public pure returns (string memory) { return \"Hello, World!\"; }}Data Types​Solidity supports various data types, such as:Boolean: boolInteger: int (signed) and uint (unsigned)Address: addressString: stringBytes: bytes (dynamic-size) and bytes32 (fixed-size)Arrays: dynamic-size or fixed-size and can be declared with various types.Structs: structEnums: enumMapping: mappingHere are examples of implementations for each data type:pragma solidity ^0.8.0;contract DataTypesExample { // Boolean bool public isCompleted = false; // Integer (signed and unsigned) int256 public signedInteger = -10; uint256 public unsignedInteger = 10; // Address address public userAddress = 0x742d35Cc6634C0532925a3b844Bc454e4438f44e; // String string public greeting = \"Hello, World!\"; // Bytes (dynamic-size and fixed-size) bytes public dynamicBytes = \"hello, solidity\"; bytes32 public fixedBytes = \"hello, solidity\"; // Arrays (dynamic-size and fixed-size) uint[] public dynamicArray = [1, 2, 3]; uint[5] public fixedArray = [1, 2, 3, 4, 5]; address[] public dynamicAddressArray = [0xd41d1744871f42Bb724D777A2d0Bf53FB43a0040, 0x1f514ae9834aEAF6c2c3eb6D20E27e865F419010]; address[3] public fixedAddressArray = [0xC90cd0D820D6dc447B3cD9545185B046873786A6, 0x401997E856CE51e0D4A8f26ce64952313BEA0E25, 0x221d3b9821f3Cc49B42E7dd487E2a6d1b3ed0E05]; bool[] public dynamicBoolArray = [true, false, true]; bool[2] public fixedBoolArray = [true, false]; // Struct struct Person { string name; uint age; } Person public person = Person(\"Alice\", 30); // Enums enum Status { Open, Closed, Pending } Status public currentStatus = Status.Open; Status public nextStatus = Status.Closed; Status public previousStatus = Status.Pending; // Mapping mapping(address => uint) public balances; constructor() { balances[msg.sender] = 100; }}Basic Constructs​Some of the basic constructs in Solidity include:Variables: Declared with a data type and an identifier.Functions: Defined with the function keyword.Modifiers: Used to modify functions' behavior.Events: Used to log changes in the contract state.Inheritance: Solidity supports single and multiple inheritance.We will explore some of these constructs in more detail in the next article, Advanced Solidity Concepts.Rust Syntax​Rust is a programming language that is well-suited for building smart contracts due to its emphasis on safety, concurrency, and performance. It enforces strict ownership and borrowing rules to prevent data races and other common bugs.fn main() { println!(\"Hello, world!\");}Data Types​The Soroban Rust SDK supports a variety of Built-In Types which consist of both Primitive and Custom Types, such as:Primitive Data Types​32-bit Integers: signed (i32) and unsigned (u32)64-bit Integers: signed (i64) and unsigned (u64)128-bit Integers: signed (i128) and unsigned (u128)Bool (bool)Bytes, Strings (Bytes, BytesN): byte arrays and strings that can be passed to contracts and storesVec (Vec): sequential and indexable growable collection typeMap (Map): ordered key-value dictionaryAddress (Address): universal opaque identifier used in contractsString (String): a contiguous growable array type containing u8s and requires an env to be passed inSymbol:(Symbol::new): small efficient strings up to 32 characters in length and requires an env to be passed in(symbol_short!) small efficient strings up to 9 characters in lengthBoth are limited to the characters a-zA-Z0-9_ and are encoded into 64-bit integers.Custom Data Types​Structs (with Named Fields): A custom type consisting of named fields stored on the ledger as a map of key-value pairs.Structs (with Unnamed Fields): A custom type consisting of unnamed fields stored on the ledger as a vector of values.Enum (Unit and Tuple Variants): A custom type consisting of unit and tuple variants stored on the ledger as a two-element vector, with the first element being the name of the variant and the second being the value.Enum (Integer Variants): A custom type consisting of integer variants stored on the ledger as the u32 value.The following are examples of implementations for each data type:// Integer (signed and unsigned)let unsigned_32_bit: u32 = 42;let signed_32_bit: i32 = -42;let unsigned_64_bit: u64 = 42;let signed_64_bit: i64 = -42;let unsigned_128_bit: u128 = 42;let signed_128_bit: i128 = -42;// Booleanlet boolean: bool = true;// Stringlet msg: &str = \"Hello\";String::from_slice(&env, msg)// Symbols (short and new)let symbol_short = symbol_short!(\"Sample\"); // up to 9 chars// env is &Envlet symbol_new = Symbol::new(env, \"SampleSymbolExpression\");// Bytes (Bytes and BytesN)let bytes = Bytes::from_slice(&env, &[1; 32]);let bytes_n = BytesN::from_array(&env, &[0; 32]);// Veclet vec = vec![&env, 0, 1, 2, 3];// Maplet map = map![&env, (2, 20), (1, 10)];// Addresslet address = Address::new([0u8; 32]);// Struct (named fields)pub struct State { pub count: u32, pub last_incr: u32,}struct Tuple(u32, String);// Struct (unnamed fields)pub struct State(pub u32, pub u32);// Enum (unit and tuple variants)pub enum Enum { A, B(u32),}// Enum (integer variants)pub enum Enum { A = 0, B = 1,}A Brief Introduction to Modules, Macros, Structs, Traits, and Attribute Macros​In this section, we will provide a concise introduction to some fundamental concepts in Rust: Modules, Macros, Structs, Traits, and Attribute Macros.These concepts are essential for understanding and writing efficient Rust code, and they will assist you on your journey as a Soroban developer.1. Modules​Modules in Rust are used to organize and separate code into different namespaces. They enable better code organization, reusability, and encapsulation. To define a module, use the mod keyword followed by a block containing the module's contents.mod my_module { pub fn my_function() { println!(\"Hello from my_module!\"); }}2. Macros​Macros in Rust are powerful tools that allow you to do metaprogramming, enabling you to build chunks of reusable code at compile time.There are two basic types: declarative and procedural macros. The most common is the declarative macro, or plain \"macro\", which is defined with macro_rules!macro_rules! my_macro { () => { println!(\"Hello from my_macro!\"); };}fn main() { my_macro!();}3. Structs​Structs are custom data types in Rust that enable you to bundle data together. They provide a way to define and create more complex data structures.struct MyStruct { field1: i32, field2: String,}fn main() { let my_instance = MyStruct { field1: 42, field2: String::from(\"Hello\"), };}4. Traits​Traits in Rust define a shared set of behaviors that types can then either use as-is (default implementations) or implement themselves. They can be thought of as interfaces in other languages. Traits are defined with the trait keyword, and their methods can be implemented for different types using the impl keyword.trait MyTrait { fn my_method(&self);}struct MyStruct;impl MyTrait for MyStruct { fn my_method(&self) { println!(\"Hello from MyTrait's my_method!\"); }}5. Attribute Macros​Attribute macros in Rust are a form of procedural macros that enable you to define custom attributes for various language elements such as functions, structs, and enums. They can modify or generate code based on the annotated items.// To use an attribute macro, first import it with `use`use my_attribute_macro::my_attribute;// Then apply the attribute to an element in your code#[my_attribute]fn my_function() { println!(\"Hello from my_function!\");}During your Soroban developer journey, you will frequently encounter the attribute macro #[contractimpl] which exports publicly accessible functions to the Soroban environment.Functions that are publicly accessible in the implementation are invocable by other contracts, or directly by transactions, when deployed.#[contractimpl]impl HelloContract { pub fn hello(env: Env, to: Symbol) -> Vec<Symbol> { vec![&env, symbol_short!(\"Hello\"), to] }}Ownership Model​Rust enforces strict ownership rules to manage memory and resources:Each value has a single owner.When the owner goes out of scope, the value is automatically deallocated.Borrowing: Values can be borrowed as immutable or mutable references.Lifetimes: Used to ensure that references remain valid.Smart Contract Dialect​Contract development in Rust involves certain restrictions due to either unavailable features in the deployment environment or high runtime costs. Thus, the code written for contracts can be seen as a distinct dialect of Rust, focusing on deterministic behavior and minimized code size.To learn more about Rust's Contract Dialect, check out the Contract Rust Dialect Page.Writing and Interacting with Simple Smart Contracts​In this section, we'll learn how to write and interact with simple smart contracts in Solidity and Rust.Writing a Smart Counter in Solidity​Here's an example of a simple Solidity smart contract for a counter:// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;contract Counter { uint256 private _count; function getCount() public view returns (uint256) { return _count; } function increment() public { _count += 1; }}Let's break down the layout of the code line by line:// SPDX-License-Identifier: UNLICENSEDThis is a comment that identifies the license for the code. It's not required for the code to run, but it's good practice to include licensing information.pragma solidity ^0.8.0;This specifies the version of Solidity that this code was written for. In this case, it's version 0.8.0 or higher.contract Counter {}This defines a new Solidity contract called Counter.uint256 private _count;This is a private variable called _count of type uint256 (unsigned integer). This variable will be used to store the current value of the counter. It is marked as private, which means it can only be accessed from within the contract.function getCount() public view returns (uint256) { return _count;}This is a function called getCount() that returns the current value of the counter. The function is marked as public, which means it can be called from outside the contract. The view keyword indicates that this function doesn't modify the state of the contract. The returns keyword specifies the return type of the function.function increment() public { _count += 1;}This is a function called increment() that increments the counter by 1. It doesn't return anything, but it modifies the state of the contract. Like getCount(), it's marked as public, which means it can be called from both inside and outside the contract.Interacting with the Solidity Smart Counter​We can interact with the smart contract using the Remix IDE. To do so, follow these steps:Click the following link to open the Gist in Remix.Navigate to the Counter.sol file in the file explorer.Press Ctrl/Cmd + s to compile the contract.Navigate to the Deploy & Run Transactions tab and click the Deploy button.The contract should appear under the Deployed Contracts tab:Click the increment button to increment the counter.Click the getCount button to get the current count.Up to this point, we've covered the basics of writing, deploying to a sandbox EVM, and interacting with a simple smart contract using Solidity. In the following section, we will extend our knowledge by learning how to achieve the same outcomes using Rust.Writing a Smart Counter in Rust​In this section, we'll create a Rust program that simulates the functionality of the Counter smart contract. Here's an example of a simple counter in Rust:#![no_std]use soroban_sdk::{contractimpl, log, Env, Symbol};const COUNTER: Symbol = symbol_short!(\"COUNTER\");#[contract]pub struct IncrementContract;#[contractimpl]impl IncrementContract { /// Increment increments an internal counter, and returns the value. pub fn increment(env: Env) -> u32 { // Get the current count. let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0); // If no value set, assume 0. log!(&env, \"count: {}\", count); // Increment the count. count += 1; // Save the count. env.storage().instance().set(&COUNTER, &count); // Return the count to the caller. count } /// get_count returns the current value of the counter. pub fn get_count(env: Env) -> u32 { env.storage().instance().get(&COUNTER).unwrap_or(0) }}This code is an implementation of a smart contract written in Rust using the Soroban Rust SDK, a Rust-based smart contract development toolkit developed by the Stellar Development Foundation (SDF). The Soroban Rust SDK provides a powerful set of tools for writing smart contracts that run on the Soroban Virtual Machine.Here's a line-by-line explanation of what the code is doing:#![no_std]This is a Rust attribute that tells the Rust compiler not to link the Rust standard library. The standard library is extensive, and when deploying Soroban applications, we want to streamline the process as much as possible. By using no_std, we establish a leaner, \"barebones\" starting point for projects, encompassing only the Rust core and a few other essential components, rather than the full breadth of the standard library.use soroban_sdk::{contractimpl, log, Env, Symbol};This code imports necessary items from the Soroban Rust SDK for writing a smart contract. The contractimpl macro is used to implement the smart contract, while the log macro is used for logging messages. The Env struct represents the environment the contract is executing in, and the Symbol type is a small, efficient string type.const COUNTER: Symbol = symbol_short!(\"COUNTER\");This creates a new Symbol value with the string \"COUNTER\". The constant COUNTER is then used as a key to identify the count value stored in the contract storage.#[contract]pub struct IncrementContract;This defines a public struct, IncrementContract, which will contain the implementation of the smart contract.#[contractimpl]impl IncrementContract {}This is a macro that implements the IncrementContract struct as a smart contract.As previously noted, the #[contractimpl] attribute exports public functions to the Soroban environment. Meaning, these functions become accessible within the implementation and can be invoked by other contracts or directly by transactions upon deployment.pub fn increment(env: Env) -> u32 {}This is a public function called increment that takes an Env struct as an argument and returns a u32. Env is the environment the contract is executing in, and u32 is the type of value returned by the function.let mut count: u32 = env.storage().instance().get(&COUNTER).unwrap_or(0)); // If no value set, assume 0.In this line of code, a mutable variable named count of type unsigned 32-bit integer (u32) is being created. The storage environment is accessed using env.storage(), and the value associated with the key COUNTER is retrieved using the get method. If there is no value set for the key COUNTER, a default value of 0 is used.log!(&env, \"count: {}\", count);This logs the current count using the log macro provided by the Soroban Rust SDK.count += 1;This increments the count by 1.env.storage().instance().set(&COUNTER, &count);This saves the updated count back to the contract storage using the set method on the storage object.countThis returns the updated count to the caller of the function.pub fn get_count(env: Env) -> u32 {}This is a public function called get_count that takes an Env struct as an argument and returns a u32. Once more we see the Env which is the environment the contract is executing in, and u32 as the type of the value returned by the function.env.storage().instance().get(&COUNTER).unwrap_or(0)This is a repeat of the code we saw earlier, which retrieves the value associated with the key COUNTER from the contract storage. If there is no value set for the key COUNTER, a default value of 0 is used. Finally, the unwrap() method is called to extract the actual value from the Ok wrapper, which is then returned to the caller of the function.Now that we have written our smart contract, it's time to explore how we can interact with it using the Soroban-CLI, one of many robust Developer Tools available. This powerful command-line tool allows us to interact with the Soroban Virtual Machine from a local machine, providing us with an efficient and flexible way to manage our smart contract.Interacting with the Rust Smart Counter​To interact with the Rust counter, create a new Rust library using the cargo new command.cargo new --lib incrementOnce the project is created, replace the src/lib.rs file with the code example above.// Remember to replace your lib.rs file with the code example above.// This is just a reference to point you in the right direction.#[contractimpl]impl IncrementContract {...}Then, add the following dependencies to the Cargo.toml file:[package]name = \"increment\"version = \"0.1.0\"edition = \"2021\"[lib]crate-type = [\"cdylib\"][features]testutils = [\"soroban-sdk/testutils\"][dependencies]soroban-sdk = \"0.9.2\"[dev_dependencies]soroban-sdk = { version = \"0.9.2\", features = [\"testutils\"] }[profile.release]opt-level = \"z\"overflow-checks = truedebug = 0strip = \"symbols\"debug-assertions = falsepanic = \"abort\"codegen-units = 1lto = true[profile.release-with-logs]inherits = \"release\"debug-assertions = trueNote: For a detailed explanation of the Cargo.toml configuration used in this tutorial, check out the Hello World Example.Next, build the project using the soroban contract build command.cd incrementsoroban contract buildThe compiled contract will be located in the target/wasm32-unknown-unknown/release directory.To interact with the contract, we can use the soroban contract invoke command from the soroban-cli tool. Here's an example of invoking the increment function on a contract with ID 1:soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/increment.wasm \\ --id 1 \\ -- \\ incrementThe output should be the current value of the counter, which in this case is:1You can use the same soroban contract invoke command to increment the counter multiple times.To get the current value of the counter, you can use the following command:soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/increment.wasm \\ --id 1 \\ -- \\ get_countThe output should be the current value of the counter, assuming the counter has been incremented 3 times, the output will be:3And that's it! You've learned how to write and interact with simple smart contracts in Solidity and Rust. In the upcoming sections, we'll learn about advanced smart contract concepts, the similarities and differences between Solidity and Rust, and how to develop and deploy smart contracts with Soroban.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/migrating-from-evm/solidity-and-rust-basics","title":"Getting Started with Rust and Solidity","contentLength":2983}},{"pageContent":"Advanced Smart Contract Concepts with Solidity and RustIn this tutorial, we will cover advanced Solidity and Rust concepts such as inheritance, interfaces, libraries, and modifiers. Additionally, we will learn how to write safe and efficient Rust code for smart contracts. Finally, we will learn how to convert common Solidity concepts to Rust.Table of Contents​Advanced Solidity ConceptsAdvanced Rust ConceptsWriting Safe and Efficient Rust Code for Smart ContractsSolidity to Soroban: Common Concepts and Best PracticesAdvanced Solidity Concepts​Inheritance​In Solidity, smart contracts can inherit properties and functions from other contracts. This is achieved using the is keyword.Here is an example of a parent contract that defines a function called messageFromParent that returns a string:contract Parent { function messageFromParent() public pure returns (string memory) { return \"Hello from Parent\"; }}contract Child is Parent { function messageFromChild(string memory newMessage) public pure returns (string memory) { string memory messageFromParent = messageFromParent(); return string(abi.encodePacked(messageFromParent,', ', newMessage)); }}In this example, the Child contract inherits the messageFromParent function from the Parent contract. The Child contract can then call the messageFromParent function directly.Interfaces​Interfaces are similar to contracts, but they cannot have any function implementations. They only contain function signatures. Contracts can implement interfaces using the is keyword, similar to inheritance.Here is an example of an interface that defines a function called doSomething that returns a uint256:interface SomeInterface { function doSomething() external returns (uint256);}contract SomeContract is SomeInterface { uint256 private counter; function doSomething() external override returns (uint256) { counter += 1; return counter; }}In this example, the SomeContract contract implements the SomeInterface interface. Its implementation returns a u256 that is incremented each time the doSomething function is called.Libraries​Libraries are similar to contracts, but they cannot have any state variables. They are used to store reusable code that can be used by other contracts. Libraries are deployed once and can be used by multiple contracts. They are defined using the library keyword. They are invoked by using the using keyword.library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a, \"Addition overflow\"); return c; }}contract MyContract { using SafeMath for uint256; uint256 public value; function increment(uint256 amount) public { value = value.add(amount); }}In this example, the SafeMath library is used in the increment function. The increment function uses the add function from the SafeMath library to increment the value variable.Modifiers​Modifiers are used to change the behavior of functions in a declarative way. They are defined using the modifier keyword. Modifiers can be used to perform common checks such as validating inputs, checking permissions, and more.contract Ownable { address public owner; constructor() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner, \"Caller is not the owner\"); _; }}contract MyContract is Ownable { function doSomething() public onlyOwner { // This function can only be called by the owner of the contract }}In this example, the onlyOwner modifier is used to restrict access to the doSomething function. The doSomething function can only be called by the owner of the contract which was defined during deployment as msg.sender.Advanced Rust Concepts​Crates​A crate in Rust is a collection of precompiled programs, scripts, or routines that can be easily reused by programmers when writing code. This allows them to avoid reinventing the wheel by not having to implement the same logic or program multiple times. There are two types of crates in Rust: Binary crates and Library crates.Binary crates are crates that can be executed as standalone programs. Library crates are crates that are meant to be used by other programs. Library crates can be imported into other programs using the use keyword.Here is an example of a workflow that implements allocation (alloc) logic within a smart contract:First a user would include the alloc crate in their Cargo.toml file:[dependencies]soroban-sdk = { workspace = true, features = [\"alloc\"] }[dev_dependencies]soroban-sdk = { workspace = true, features = [\"testutils\", \"alloc\"] }Then they would import the alloc crate into their smart contract:// Imports#![no_std]use soroban_sdk::{contractimpl, Env};extern crate alloc;#[contract]pub struct AllocContract;#[contractimpl]impl AllocContract { /// Allocates a temporary vector holding values (0..count), then computes and returns their sum. pub fn sum(_env: Env, count: u32) -> u32 { let mut v1 = alloc::vec![]; (0..count).for_each(|i| v1.push(i)); let mut sum = 0; for i in v1 { sum += i; } sum }}In this example, the alloc crate is imported into the smart contract using the extern crate alloc; statement. The alloc crate is then used to create a temporary vector that holds values from 0 to count. The values in the vector are then summed and returned.For more details on how to use the alloc crate, including a hands-on practical exercise, visit the alloc section of the documentation.Inheriting Functionality from Other Crates​We can illustrate another example of inheritance by importing functionality into a crate from other crates in the same project in the following example:Below is a function from the event.rs file from our Token example.use soroban_sdk::{Address, Env, Symbol};...pub(crate) fn mint(e: &Env, admin: Address, to: Address, amount: i128) { let topics = (symbol_short!(\"mint\"), admin, to); e.events().publish(topics, amount);}This function will publish a mint event to the blockchain with the following output:Emit event with topics = [\"mint\", admin: Address, to: Address], data = [amount: i128]We'll also use a function from our admin.rs file.// Metering: covered by componentspub fn read_administrator(e: &Host) -> Result<Address, HostError> { let key = DataKey::Admin; let rv = e.get_contract_data(key.try_into_val(e)?)?; Ok(rv.try_into_val(e)?)}This function returns a Result object that contains the administrator's address.Lastly, we'll implement a function from our balance.rs file.pub fn receive_balance(e: &Env, addr: Address, amount: i128) { let balance = read_balance(e, addr.clone()); if !is_authorized(e, addr.clone()) { panic!(\"can't receive when deauthorized\"); } write_balance(e, addr, balance + amount);}This function writes an amount to an address' balance.The event.rs is imported into the contract.rs file which holds the logic for our token contract.//contract.rs//importsuse crate::event;use crate::admin::{read_administrator};use crate::balance::{receive_balance};// trait logicpub trait TokenTrait {fn mint(e: Env, to: Address, amount: i128);}// struct logic#[contract]pub struct Token;// impl logic#[contractimpl]impl TokenTrait for Token {fn mint(e: Env, to: Address, amount: i128) { check_nonnegative_amount(amount); let admin = read_administrator(&e); admin.require_auth(); receive_balance(&e, to.clone(), amount); event::mint(&e, admin, to, amount); }}As you can see, the event.rs, admin.rs, and balance.rs files are imported into the contract.rs file using the use keyword. This allows us to use the functions from those files in the mint function of our contract.rs file.Inheriting Functionality using contractimport!​The Soroban Rust SDK provides a powerful macro, contractimport, which allows a user to import a contract from its Wasm file, generating a client, types, and constant holding the contract file.Here is an example of how to use the contractimport macro taken from the token.rs file from our Liquidity Pool example:First, we see that the wasm file from the previously built token example is imported into the token.rs file using the contractimport macro://token.rssoroban_sdk::contractimport!( file = \"../token/target/wasm32-unknown-unknown/release/soroban_token_contract.wasm\");We see then that our token contract is imported into our lib.rs file and a Client is generated for us to access functionality from the token contract://lib.rsmod token;fn get_balance(e: &Env, contract_id: BytesN<32>) -> i128 { token::Client::new(e, &contract_id).balance(&e.current_contract_address())}fn transfer(e: &Env, contract_id: BytesN<32>, to: Address, amount: i128) { token::Client::new(e, &contract_id).transfer(&e.current_contract_address(), &to, &amount);}struct LiquidityPool;#[contractimpl]impl LiquidityPoolTrait for LiquidityPool { let token_a_client = token::Client::new(&e, &get_token_a(&e));}In the above example, we use contractimport to interact with the token file via a Client that was generated for the token module. This Client was created using a Contract trait that matches the interface of the contract, a ContractClient struct that contains functions for each function in the contract, and types for all contract types defined in the contract.A Note on Inheritance and Composability​While we've been using the term \"inheritance\" to help make the transition from Solidity smoother, let's clarify an important aspect of Rust: it does not support inheritance as we traditionally understand it. Instead, Rust practices \"composability\", meaning it uses functions from different crates, which are akin to packages, in a modular fashion. So, when we discuss contractimport!, we're actually observing composability in action, not \"inheritance\". Rust does not foster the \"is a\" relationship inherent in OOP languages. Instead, it enables us to reuse and assemble code effectively across different scopes. This is a technical truth that is important to understand; however, it's worth noting that this fact doesn't impact the practical usage of Soroban throughout this guide.Modules​In Rust, modules consist of a cohesive set of related functions and types that are often organized together for better organization and reusability. These modules can be reused across multiple projects by publishing them as crates.Here is an example of a module that implements SafeMath logic with an add function:#![no_std]mod safe_math// mod safe_math {// pub fn add(a: u32, b: u32) -> Result<u32, &'static str> {// a.checked_add(b).ok_or(\"Addition overflow\")// }// }// Importsuse soroban_sdk::{contractimpl, Env};use safe_math::add;pub trait MathContract { fn add(&self, env: Env, a: u32, b: u32) -> u32;}#[contract]pub struct Adder;impl MathContract for Adder { fn add(&self, _env: Env, a: u32, b: u32) -> u32 { add(a, b) }}#[contractimpl]impl Adder {}// test module#[cfg(test)]mod test;Notice that we use the checked_add function from the standard library to ensure that the addition does not overflow. This is important because if the addition overflows, it could lead to unexpected behavior in the contract.Even when Rust code is compiled with the #![no_std] flag, it is still possible to use some of the standard library's features, such as the checked_add function. This is because Rust provides the option to selectively import modules and functions from the standard library, allowing developers to use only the specific features they need.Traits​Rust does not have a built-in modifier system like Solidity. However, you can achieve similar functionality using traits and their implementations.In the example below, we will illustrate the inheritance of traits using the Ownable trait.#![no_std]// Importsuse soroban_sdk::{contracttype, Address};// Define the `Ownable` traittrait Ownable { fn is_owner(&self, owner: &Address) -> bool;}// Implement the `Ownable` trait for the `OwnableContract` structimpl Ownable for OwnableContract { fn is_owner(&self, owner: &Address) -> bool { self.owner == *owner }}// Define a modifier that requires the caller to be the owner of the contractfn only_owner(contract: &OwnableContract, owner: &Address) -> bool { contract.is_owner(owner)}// Implement the contract for the `OwnableContract` struct#[contracttype]// Define the `OwnableContract` structpub struct OwnableContract { owner: Address, number: u32,}impl OwnableContract { // Define a public method that requires the caller to be the owner of the contract pub fn change_number(&mut self, new_number: u32) { if only_owner(self, &self.owner) { self.number = new_number; } }}#[cfg(test)]mod test;Here's a breakdown of the code above:First, we define the Ownable trait, which defines a single method called is_owner. This method takes an Address as an argument and returns a boolean value indicating whether or not the address is the owner of the contract.Next, we implement the Ownable trait for the OwnableContract struct. This allows us to use the is_owner method on instances of the OwnableContract struct.Then, we define a \"modifier\" called only_owner that takes an instance of the OwnableContract struct and an Address as arguments. This \"modifier\" returns a boolean value indicating whether or not the address is the owner of the contract.Finally, we implement the contract for the OwnableContract struct. This allows only the owner of the contract to use the change_number method on instances of the OwnableContract struct.It's worth mentioning that the Soroban Rust SDK comes with several built-in requirements that developers can use, such as the require_auth method provided by the Address struct.Interfaces​Interfaces are an essential part of building smart contracts with Soroban.There are many types of smart contract interfaces, and each has a specific purpose. One example of an interface built with Soroban is the Token Interface. This interface ensures that tokens deployed on Soroban are interoperable with Soroban's built-in tokens (such as the Stellar Asset Contract). The Token Interface consists of three compatibility requirements:function interfaceauthorizationeventsFor more information on smart contract interfaces built with Soroban, including the Token Interface, visit the interfaces section of the documentation.Writing Safe and Efficient Rust Code for Smart Contracts​When writing Rust code for smart contracts, it's important to focus on safety and efficiency. Some tips include:Use the Result type to handle errors in a safe and predictable way. In smart contracts, it's important to avoid panicking, as this can lead to unpredictable behavior. Instead, Result can be used to handle errors and ensure that the contract behaves as expected.In the example below, the add function returns a Result type, which can either be Ok or Err. If the addition does not overflow, the function returns Ok, otherwise it returns Err.pub fn add(a: u32, b: u32) -> Result<u32, &'static str> { a.checked_add(b).ok_or(\"Addition overflow\")}Use the checked_ family of functions, such as checked_add, checked_sub, etc., to perform arithmetic operations in a safe and efficient manner. These functions check for overflows and underflows and return an error if one occurs.In the example below, the add function uses the checked_add function to perform the addition. If the addition overflows, the function returns an error.pub fn add(a: u32, b: u32) -> u32 { a.checked_add(b).expect(\"Addition overflow\")}Use cargo and clippy to enforce code quality, style, and efficiency in Rust. cargo is Rust's package manager and provides a number of tools for building and testing Rust code. clippy is a linter that can help identify potential issues in the code, such as unused variables or functions that could be optimized.To use clippy with cargo, you'll first need to install it. You can do this by running the following command in your terminal:cargo install clippyOnce clippy is installed, you can run it by running the following command in your terminal:cargo clippyThis will run clippy on your entire project, checking for potential issues and providing suggestions for improvement. Clippy will output any issues it finds, along with suggestions for how to fix them.Use cargo and rustfmt to enforce code style. rustfmt is a tool that can automatically format Rust code according to the Rust style guide. This can help ensure that the code is consistent and easy to read.To use rustfmt with cargo, you'll first need to install it. You can do this by running the following command in your terminal:cargo install rustfmtOnce rustfmt is installed, you can run it by running the following command in your terminal:cargo fmtBefore:fn main(){let x=5;if x==5 {println!(\"Hello, world!\");}}After:fn main() { let x = 5; if x == 5 { println!(\"Hello, world!\"); }}Solidity to Soroban: Common Concepts and Best Practices​In this section we will explore key Solidity concepts and provide their Soroban equivalents. We will discuss the following topics:Message PropertiesError HandlingAddress-related functionalityFunction visibility specifiersTime-based variablesMessage Properties​The Soroban Rust SDK and Solidity provide a number of message properties that can be used to access information about the current transaction. These properties include:Solidity​msg.sender: The address of the account that sent the transaction.msg.value: The amount of Ether sent with the transaction.msg.data: The data sent with the transaction.Here's a simple example of a smart contract that demonstrates the use of eachpragma solidity ^0.8.0;contract SimpleContract { address public sender; uint public value; bytes public data; // Caller must send Ether and data to this function. // This function will store the sender, value, and data. function sendData(bytes calldata _data) external payable { sender = msg.sender; value = msg.value; data = _data; }}These are a part of Solidity's global variables, which are accessible from any function in the contract.Soroban​In contrast to Solidity's global variables, Soroban relies on passing an Env argument to all functions which provides access to the environment the contract is executing within.The Env provides access to information about the currently executing contract, who invoked it, contract data, functions for signing, hashing, etc.For instance, you would use env.storage().persistent().get(key) to access a persistent target value from the contract's storage. Read more about the different storage types here.env.storage() is used to get a struct for accessing and updating contract data that has been stored.Used as env.storage().persistent().get() or env.persistent().storage().set().Additionally, we utilize the clone() method, a prevalent trait in Rust that allows for the explicit duplication of an object.See the example below for implementations of env.storage() and clone()env.storage().persistent().set()use soroban_sdk::{Env, Symbol}; pub fn set_storage(env: Env) { let key = symbol_short!(\"key\"); let value = symbol_short!(\"value\"); env.storage().persistent().set(&key, &value);}env.storage().persistent().get()use soroban_sdk::{Env}; pub fn get_storage(env: Env) -> value { env.storage().persistent().get(&key);}clone()use soroban_sdk::{Env, Address}; pub fn return_user(user: Address) -> Address { let user_address: Address = user.clone(); user_address}Error Handling​The Soroban Rust SDK and Solidity provide a number of ways to handle errors. These include:Solidity​Solidity provides a require function that can be used to check for certain conditions and revert the transaction if they are not met. For example, the following code sets a minimum value for the amount of Ether sent with the transaction:function deposit() public payable { require(msg.value >= 1 ether, \"Not enough Ether sent\"); // ...}Soroban​The panic! macro serves as Rust's error-handling mechanism, which closely resembles the require function in Solidity.pub fn simple_deposit(amount: u32) { if amount < 1_000_000 { panic!(\"amount too low\"); } // ... }Address-Related Functionality​Both Soroban and Solidity provide provide a number of functions for working with addresses. These functions include:Solidity​address(this): Returns the address of the current contract.address payable(this): Returns the address of the current contract as a payable address.address(address): Returns the address of the specified account.address payable(address): Returns the address of the specified account as a payable address.Below is an example of a smart contract that illustrates how contracts can be retrievedpragma solidity ^0.8.0;contract SimpleContract { address public contractAddress = address(this); address public randomAddress = 0x1234567890123456789012345678901234567890; address public payableAddress = payable(address(this)); address public payableRandomAddress = payable(0x1234567890123456789012345678901234567890);}There would be no difference in appearance between a regular address and a payable address in Solidity.Soroban​e.current_contract_address(): Returns the Address object corresponding to the current executing contract.The Env not only provides essential information about the currently executing contract and its invoker, but also offers access to contract data and functions for signing, hashing, and more. The construction or conversion of most types in Soroban requires access to an Env instance.Here is an example of a smart contract that illustrates how contracts can be retrieved:#![no_std]use soroban_sdk::{contractimpl, log, Address, Env, Symbol};#[contract]pub struct SimpleContract;#[contractimpl]impl SimpleContract { ///Example contract for returning a contract Address. pub fn return_address(env: Env) -> Address { let current_contract_address = env.current_contract_address(); current_contract_address }}Why Soroban Differs​Soroban has some differences from Solidity in terms of addresses and other functionalities. These differences arise due to the design principles and goals of Soroban.One significant difference is the use of the Env object in Soroban. The Env object encapsulates various functionalities related to contract execution, data access, and more. It provides a unified interface for interacting with the Soroban environment within the context of a contract. By utilizing the Env object, Soroban enables a more modular and flexible approach to contract development.To further explain, the Env type offers a gateway to the environment where the contract operates. It provides information about the ongoing contract, the entity invoking it, contract data, and functions for signing, hashing, and so forth. Most types demand access to an Env for their construction or conversion.Meanwhile, the Address object serves as a potent tool for authentication and authorization. For instance, it can be used to authorize token transfers, acting as a security gatekeeper within the system. This feature amplifies the functionality of addresses in Soroban, making them not just a means of identification or storage, but also a key player in verifying and authorizing transactions.Function Visibility Specifiers​The Soroban Rust SDK and Solidity provide a number of function visibility specifiers that can be used to control who can call a function. These specifiers include:Solidity​public: Anyone can call the function.external: Only other contracts can call the function.internal: Only the current contract and contracts that inherit from it can call the function.private: Only the current contract can call the function.Here is an example of a smart contract that illustrates how function visibility is used in Solidity:pragma solidity ^0.8.0;contract SimpleContract { function publicFunction() public {} function externalFunction() external {} function internalFunction() internal {} function privateFunction() private {}}Soroban​pub: The item (function, struct, etc.) is accessible from any module or scope.pub(crate): The item is accessible only within the current crate.pub(super): The item is accessible only within its parent module.pub(in path::to::module): The item is accessible only within the specified module path.private: The item is not marked as pub and is therefore private to its own module, meaning it can only be accessed within the same module and is not accessible from outside the module.Here is an example of a module that illustrates how function visibility is used in Soroban:#![no_std]use soroban_sdk::{contractimpl, Env};mod outer { pub struct PublicStruct { pub field: u32, } pub(crate) struct CrateStruct { pub(crate) field: u32, } // This struct is private because it is not marked as `pub`. struct PrivateStruct { field: u32, } mod inner { pub(super) struct SuperStruct { pub(super) field: u32, } } pub fn get_all_fields() -> u32 { let public_struct = PublicStruct { field: 1 }; let crate_struct = CrateStruct { field: 2 }; let private_struct = PrivateStruct { field: 3 }; let super_struct = inner::SuperStruct { field: 4 }; public_struct.field + crate_struct.field + private_struct.field + super_struct.field }}#[contract]pub struct NewContract; trait OuterTrait { fn get_all_fields() -> u32; fn get_public_fields() -> u32;}#[contractimpl]impl OuterTrait for NewContract { fn get_public_fields() -> u32 { let public_struct = outer::PublicStruct { field: 1 }; let crate_struct = outer::CrateStruct { field: 2 }; // private structs cannot be accessed from outside the crate public_struct.field + crate_struct.field } fn get_all_fields() -> u32 { outer::get_all_fields() }}Time-Based Variables​The Soroban Rust SDK and Solidity provide a number of time-based variables that can be used to access information about the current block(EVM) or ledger(Soroban). These variables include:Solidity​block.timestamp: The timestamp of the current block.block.number: The number of the current block.Here is an example of a smart contract that illustrates how time-based variables are used in Solidity:pragma solidity ^0.8.0;contract SimpleContract { function getTimestamp() public view returns (uint256) { return block.timestamp; } function getBlockNumber() public view returns (uint256) { return block.number; }}Soroban​env.ledger().timestamp(): Returns a unix timestamp for when the most recent ledger was closed.env.ledger().sequence(): Returns the sequence number of the most recently closed ledger.Here is an example of a smart contract that illustrates how time-based variables are used in Rust:#![no_std]use soroban_sdk::{contractimpl, Address, Env};#[contract]pub struct SimpleContract;#[contractimpl]impl SimpleContract { pub fn get_timestamp(env: Env) { let timestamp = env.ledger().timestamp(); let sequence = env.ledger().sequence(); }}Authorization​Soroban differs from Solidity in its approach to authorization and modifiers. While Solidity has a built-in modifier system, Sorotban does not. Instead, Soroban leverages traits, their implementations, and core features to achieve similar functionality.Solidity​In Solidity, the ERC20 token standard includes the approve function, which allows a token holder to authorize another address to spend a certain amount of tokens on their behalf. This function is commonly used in decentralized exchanges and other token transfer scenarios. Furthermore, we're ensuring that the spender is authorized to spend the amount of tokens requested by the token holder.Here's an example of how the approve function acts as an authorization mechanism in Solidity:pragma solidity ^0.8.0;contract ERC20Token { constructor() { address owner = msg.sender; ownerAddress = owner; } mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowances; mapping(address => bool) public isAuthorized; address public ownerAddress; function approve(address spender, uint256 amount) public returns (bool) { allowances[msg.sender][spender] = amount; return true; } function setAuthorization(address newAuth) public returns (bool) { require(msg.sender == ownerAddress); isAuthorized[newAuth] = true; return true; } function transfer(address to, uint256 amount) public returns (bool) { require(allowances[msg.sender][to] >= amount, \"Not enough allowance\"); require(isAuthorized[to] == true, \"Not authorized\"); balances[msg.sender] -= amount; balances[to] += amount; return true; }}The approve function allows the token holder to authorize spender to spend amount tokens on their behalf. The transfer function then checks if the spender is authorized to spend the amount of tokens requested by the token holder. If so, the transfer is executed.These Solidity examples illustrate some common authorization patterns used in Ethereum smart contracts. Soroban provides alternative approaches to achieve similar functionality, leveraging core functionality derived right from the soroban SDK.Soroban​Soroban's design principles prioritize flexibility, security, and testability, which have led to differences in how authorization is handled compared to Solidity.Soroban provides built-in functions such as require_auth and require_auth_for_args through the Address struct. These functions help enforce authorization rules within contracts. During on-chain execution, the Soroban host performs the necessary authentication, including verifying signatures and ensuring replay prevention. This alleviates the burden of authentication from the contracts themselves, promoting security and reducing potential vulnerabilities.Here is an example of a smart contract that illustrates how authorization is handled in Soroban:#![no_std]use soroban_sdk::{contractimpl, testutils::Address as _, Address, Symbol, Env, IntoVal};#[contract]pub struct Contract;#[contractimpl]impl Contract { pub fn transfer(env: Env, address: Address, amount: i128) { address.require_auth(); } pub fn transfer2(env: Env, address: Address, amount: i128) { address.require_auth_for_args((amount / 2,).into_val(&env)); }}In this example, we have a Soroban contract that includes two public functions: transfer and transfer2, both of which involve authorization checks.Inside the Transfer function, the require_auth method is invoked on the address object. This method ensures that the caller of the contract has the necessary authorization to execute the transfer.The transfer2 function follows a similar pattern but uses the require_auth_for_args method instead. It takes the same parameters as transfer but provides a tuple (amount / 2,) as the argument to require_auth_for_args. This method verifies that the caller has authorized the contract invocation with the specific arguments.By utilizing these authorization methods provided by the Address object from the Soroban Rust SDK, the contract enforces that only authorized callers can perform the transfers. This approach enhances the security of the contract by ensuring that sensitive operations can only be executed by authorized parties.Soroban's approach to authorization in this example offers several advantages over Solidity's model of ERC20 by eliminating the need for separate approval management. Instead, authorization checks can be directly incorporated into any Soroban function. This simplifies the contract codebase and reduces the complexity associated with managing separate approval states.Soroban authorization provides Contract-level Authorization, Account Abstraction Functionality, and more advanced Authorization checks. To learn more about these advantages, visit the Authorization section of the documentation.Summary​Overall the Soroban equivalents of Solidity concepts are very similar. However, there are notable differences worth highlighting. Soroban uses env instead of msg to access information about the entire contract execution environment, including the state of the contract, addresses involved, and more. Authorization is also handled differently in Soroban, as it is built into the core functionality of the SDK and is more robust than relying on smart contract code alone.For more information on Solidity concepts and their Soroban equivalents, it is recommended that one refer to both the Soroban Rust SDK documentation and the Solidity documentation.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/migrating-from-evm/solidity-and-rust-advanced-concepts","title":"Advanced Smart Contract Concepts with Solidity and Rust","contentLength":4682}},{"pageContent":"Smart Contract Development with Soroban and HardhatIn this tutorial, we will discover the similarities in smart contract deployment by examing workflows with Soroban and Hardhat. We will dive into the intricacies of each framework, learn to write secure and efficient smart contract code, and harness the power of Rust and Soroban to create customized contract logic.Table of Contents​Soroban and Hardhat ComparisonHardhat vs Soroban SDKsUsing Rust and Soroban for Smart Contract DevelopmentVault Contract Deployment and InteractionSoroban and Hardhat Comparison​Introduction​Soroban and Hardhat are both frameworks that enable developers to build, test, and deploy smart contracts. In this section, we will delve into the similarities and distinctions between these two frameworks.Soroban Framework​Soroban is a Rust-based framework tailored for developing smart contracts on the Stellar network. Designed as a lightweight framework, with tools to support developers, Soroban allows developers to develop smart contracts through a simple and intuitive workflow.Hardhat​Hardhat serves as a development environment for compiling, deploying, testing, and debugging smart contracts for the EVM. It assists developers in managing and automating recurring tasks inherent to building smart contracts.Similarities​Soroban and Hardhat are powerful frameworks designed to streamline the process of building, testing, and deploying smart contracts. Equipped with a comprehensive suite of tools, these frameworks facilitate the development of smart contracts and their deployment on their respective virtual machines.Differences​Soroban, with its lightweight design, offers developers an exceptional platform for writing Rust-based smart contracts and deploying them effortlessly on the Stellar network. In contrast, Hardhat serves primarily as a development environment tailored for the Ethereum Virtual Machine, providing a different focus and target audience.Hardhat vs. Soroban SDKs​Hardhat offers a streamlined workflow for deploying smart contracts on the Ethereum Virtual Machine, with key components such as ethers.js, scripts, and testing playing crucial roles.On the other hand, Soroban presents a compelling alternative, boasting powerful SDKs that facilitate smart contract development and deployment. In the upcoming section, we will delve into Soroban's SDKs, drawing comparisons with Hardhat components, and highlighting the unique advantages each platform brings to the table.Ethers.js​Ethers.js is a widely-used JavaScript library designed for seamless interaction with the EVM. It offers a user-friendly interface that simplifies connecting to Ethereum nodes, managing accounts, and sending transactions. Additionally, Ethers.js provides a robust API for efficient communication with smart contracts. This library is a core component of the Hardhat framework and can be imported into scripts to streamline the deployment of smart contracts.const { ethers } = require(\"hardhat\");async function main() { const [deployer] = await ethers.getSigners(); console.log(\"Deploying contracts with the account:\", deployer.address);}Soroban Client​Soroban offers a comparable library, js-soroban-client, that enables seamless interaction smart contracts deployed on the Stellar Network. This library supplies a comprehensive networking layer API for soroban-rpc methods, simplifying the process of building and signing transactions. Additionally, js-soroban-client streamlines communication with soroban-rpc instances and supports submitting transactions or querying network state with ease.Scripts​Hardhat scripts streamline the automation of routine tasks, such as deploying and managing smart contracts. Developers can create these scripts using either JavaScript or TypeScript, catering to their preferred programming style. They are stored in the scripts directory of a Hardhat project and can be executed using the npx hardhat run command.// scripts/deploy.jsasync function main() { // Compile and deploy the smart contract const MyContract = await ethers.getContractFactory(\"MyContract\"); const myContract = await MyContract.deploy(); console.log(\"MyContract deployed to:\", myContract.address);}main() .then(() => process.exit(0)) .catch((error) => { console.error(error); process.exit(1); });Soroban Scripts​Soroban offers an extensive collection of SDKs that include scripting capabilities, ensuring a smooth workflow for deploying and managing smart contracts. Developers can automate tasks such as compiling, deploying, and interacting with smart contracts using a variety of SDKs that support scripting in languages like JavaScript, TypeScript, Python, and others.# This example shows how to deploy a compiled contract to the Stellar network.# https://github.com/stellar/soroban-quest/blob/main/quests/6-asset-interop/py-scripts/deploy-contract.pyimport timefrom stellar_sdk import Network, Keypair, TransactionBuilderfrom stellar_sdk import xdr as stellar_xdrfrom stellar_sdk.soroban import SorobanServerfrom stellar_sdk.soroban.soroban_rpc import TransactionStatus# TODO: You need to replace the following parameters according to the actual situationsecret = \"SAAPYAPTTRZMCUZFPG3G66V4ZMHTK4TWA6NS7U4F7Z3IMUD52EK4DDEV\"rpc_server_url = \"http://127.0.0.1:8000/soroban/rpc\"network_passphrase = Network.FUTURENET_NETWORK_PASSPHRASEcontract_file_path = \"/path/to/compiled/soroban_contract.wasm\"kp = Keypair.from_secret(secret)soroban_server = SorobanServer(rpc_server_url)print(\"installing contract...\")source = soroban_server.load_account(kp.public_key)# with open(contract_file_path, \"rb\") as f:# contract_bin = f.read()tx = ( TransactionBuilder(source, network_passphrase) .set_timeout(300) .append_install_contract_code_op( contract=contract_file_path, # the path to the contract, or binary data source=kp.public_key, ) .build())...Testing​Hardhat provides a testing framework that allows developers to write tests for their smart contracts. These tests can be written in JavaScript or TypeScript and run using the npx hardhat test command.// test/my-contract.jsconst { expect } = require(\"chai\");describe(\"MyContract\", function () { it(\"Should return the correct name\", async function () { const MyContract = await ethers.getContractFactory(\"MyContract\"); const myContract = await MyContract.deploy(); await myContract.deployed(); expect(await myContract.name()).to.equal(\"MyContract\"); });});Soroban Testing​Soroban enables users to leverage the power of Rust's testing framework to write tests for their smart contracts. These tests can be written in Rust and run using the cargo test command.#![cfg(test)]use super::*;use soroban_sdk::{vec, Env, Symbol, symbol_short};#[test]fn test() { let env = Env::default(); let contract_id = env.register_contract(None, HelloContract); let client = HelloContractClient::new(&env, &contract_id); let words = client.hello(&symbol_short!(\"Dev\")); assert_eq!( words, vec![&env, symbol_short!(\"Hello\"), symbol_short!(\"Dev\"),] );}In summary, while Hardhat provides an excellent environment for deploying smart contracts on the EVM, Soroban's Rust-based framework offers significant advantages in terms of performance, making it an ideal choice for building secure and efficient smart contracts.Developing Smart Contracts with Rust and Soroban​Introduction​Now that we've examined the deployment workflow with Hardhat, let's explore developing and deploying smart contracts with Rust and Soroban. The key advantage of using Soroban is its ability to leverage Rust's safety features and performance, making it an excellent choice for developing secure and efficient smart contracts.We've learned that Smart contracts are self-executing contracts that can be programmed to automatically enforce the rules and regulations of a particular agreement. They are a core component of decentralized applications (dApps) and blockchain technology. In this section, we will learn how to use Rust and Soroban to develop and deploy custom smart contract logic.Setup​If you haven't already setup up the dev environment for Soroban, you can get started by following the steps on the Setup Page.This project requires using the soroban_token_contract.wasm file which you will need to import manually.First, you will need to clone the v0.9.2 tag of soroban-examples repository:git clone -b v0.9.2 https://github.com/stellar/soroban-examplesThen, navigate to the soroban-examples/token directorycd soroban-examples/tokenNext, build the Token contract using the following command:soroban contract buildThis will build the soroban_token_contract.wasm file which you will need to import into your project. The soroban_token_contract.wasm file is located in the soroban-examples/target/wasm32-unknown-unknown/release directory.soroban-examples├── target│ └── wasm32-unknown-unknown│ └── release│ └── soroban_token_contract.wasm└──Once we have the Token, let's create a new smart contract that uses it.Writing a Smart Contract​Let's start by writing a simple example of a vault contract that allows users to deposit funds and withdraw their funds with generated yield.Here is a breakdown of the contract mechanicsShares are minted when a user deposits.The DeFi protocol uses the users' deposits to generate yield.User burns shares to withdraw their tokens + yield.In a new terminal, let's create a new Rust project by running the following command:cargo new --lib vaultThis will create a new Rust project called vault.Now let's add the soroban_token_contract.wasm file to the vault project. To do this, we can drag and drop the file into the vault project directory.Next, we'll need to add the Soroban SDK as a dependency. To do this, open the Cargo.toml file in your project and ensure that it matches the following:[package]name = \"vault\"version = \"0.0.0\"edition = \"2021\"publish = false[lib]crate-type = [\"cdylib\"][dependencies]soroban-sdk = { version = \"0.9.2\" }num-integer = { version = \"0.1.45\", default-features = false, features = [\"i128\"] }[dev_dependencies]soroban-sdk = { version = \"0.9.2\", features = [\"testutils\"] }[profile.release]opt-level = \"z\"overflow-checks = truedebug = 0strip = \"symbols\"debug-assertions = falsepanic = \"abort\"codegen-units = 1lto = true[profile.release-with-logs]inherits = \"release\"debug-assertions = trueIn this project we will need to create 3 files:src/lib.rs - This is where we will write our vault smart contract logic.src/test.rs - This is where we will write our tests.src/token.rs - This is file inherits the token contact that we imported earlier. It's also where we will write our token creation logic.To interact with the token contract, we'll use a built in interface that you can find in the token_interface.rs tab. This interface includes the initialize and mint functions that we will use to create and mint tokens for us to use in our vault contract. If you want to see the full code of the token contract, you can check it out here.src/lib.rssrc/test.rssrc/token.rssrc/token_interface.rs#![no_std]mod test;mod token;use soroban_sdk::{ contract, contractimpl, contractmeta, Address, BytesN, ConversionError, Env, IntoVal, TryFromVal, Val,};use token::create_contract;#[derive(Clone, Copy)]#[repr(u32)]pub enum DataKey { Token = 0, TokenShare = 1, TotalShares = 2, Reserve = 3,}impl TryFromVal<Env, DataKey> for Val { type Error = ConversionError; fn try_from_val(_env: &Env, v: &DataKey) -> Result<Self, Self::Error> { Ok((*v as u32).into()) }}fn get_token(e: &Env) -> Address { e.storage().instance().get(&DataKey::Token).unwrap()}fn get_token_share(e: &Env) -> Address { e.storage().instance().get(&DataKey::TokenShare).unwrap()}fn get_total_shares(e: &Env) -> i128 { e.storage().instance().get(&DataKey::TotalShares).unwrap()}fn get_reserve(e: &Env) -> i128 { e.storage().instance().get(&DataKey::Reserve).unwrap()}fn get_balance(e: &Env, contract: Address) -> i128 { token::Client::new(e, &contract).balance(&e.current_contract_address())}fn get_token_balance(e: &Env) -> i128 { get_balance(e, get_token(e))}fn get_balance_shares(e: &Env) -> i128 { get_balance(e, get_token_share(e))}fn put_token(e: &Env, contract: Address) { e.storage().instance().set(&DataKey::Token, &contract);}fn put_token_share(e: &Env, contract: Address) { e.storage().instance().set(&DataKey::TokenShare, &contract);}fn put_total_shares(e: &Env, amount: i128) { e.storage().instance().set(&DataKey::TotalShares, &amount)}fn put_reserve(e: &Env, amount: i128) { e.storage().instance().set(&DataKey::Reserve, &amount)}fn burn_shares(e: &Env, amount: i128) { let total = get_total_shares(e); let share_contract_id = get_token_share(e); token::Client::new(e, &share_contract_id).burn(&e.current_contract_address(), &amount); put_total_shares(e, total - amount);}fn mint_shares(e: &Env, to: Address, amount: i128) { let total = get_total_shares(e); let share_contract_id = get_token_share(e); token::Client::new(e, &share_contract_id).mint(&to, &amount); put_total_shares(e, total + amount);}// Metadata that is added on to the Wasm custom sectioncontractmeta!( key = \"Description\", val = \"A Vault with a 1% return on investment per deposit.\");pub trait VaultTrait { // Sets the token contract addresses for this vault fn initialize(e: Env, token_wasm_hash: BytesN<32>, token: Address); // Returns the token contract address for the vault share token fn share_id(e: Env) -> Address; // Deposits token. Also mints vault shares for the `from` Identifier. The amount minted // is determined based on the difference between the reserves stored by this contract, and // the actual balance of token for this contract. fn deposit(e: Env, from: Address, amount: i128); // transfers `amount` of vault share tokens to this contract, burns all pools share tokens in this contracts, and sends the // corresponding amount of token to `to`. // Returns amount of token withdrawn fn withdraw(e: Env, to: Address, amount: i128) -> i128; fn get_rsrvs(e: Env) -> i128;}#[contract]struct Vault;#[contractimpl]impl VaultTrait for Vault { fn initialize(e: Env, token_wasm_hash: BytesN<32>, token: Address) { let share_contract_id = create_contract(&e, token_wasm_hash, &token); token::Client::new(&e, &share_contract_id).initialize( &e.current_contract_address(), &7u32, &\"Vault Share Token\".into_val(&e), &\"VST\".into_val(&e), ); put_token(&e, token); put_token_share(&e, share_contract_id.try_into().unwrap()); put_total_shares(&e, 0); put_reserve(&e, 0); } fn share_id(e: Env) -> Address { get_token_share(&e) } fn deposit(e: Env, from: Address, amount: i128) { // Depositor needs to authorize the deposit from.require_auth(); let token_client = token::Client::new(&e, &get_token(&e)); token_client.transfer(&from, &e.current_contract_address(), &amount); let balance = get_token_balance(&e); mint_shares(&e, from, amount); put_reserve(&e, balance); } fn withdraw(e: Env, to: Address, amount: i128) -> i128 { to.require_auth(); // First transfer the vault shares that need to be redeemed let share_token_client = token::Client::new(&e, &get_token_share(&e)); share_token_client.transfer(&to, &e.current_contract_address(), &amount); let token_client = token::Client::new(&e, &get_token(&e)); token_client.transfer( &e.current_contract_address(), &to, &(&amount + (&amount / &100)), ); let balance = get_token_balance(&e); let balance_shares = get_balance_shares(&e); burn_shares(&e, balance_shares); put_reserve(&e, balance - amount); amount } fn get_rsrvs(e: Env) -> i128 { get_reserve(&e) }}#![cfg(test)]extern crate std;use crate::{token, VaultClient};use soroban_sdk::{ symbol_short, testutils::{Address as _, AuthorizedFunction, AuthorizedInvocation}, Address, BytesN, Env, IntoVal,};fn create_token_contract<'a>(e: &Env, admin: &Address) -> token::Client<'a> { token::Client::new(e, &e.register_stellar_asset_contract(admin.clone()))}fn create_vault_contract<'a>( e: &Env, token_wasm_hash: &BytesN<32>, token: &Address,) -> VaultClient<'a> { let vault = VaultClient::new(e, &e.register_contract(None, crate::Vault {})); vault.initialize(token_wasm_hash, token); vault}fn install_token_wasm(e: &Env) -> BytesN<32> { soroban_sdk::contractimport!(file = \"./soroban_token_contract.wasm\"); e.deployer().upload_contract_wasm(WASM)}#[test]fn test() { let e = Env::default(); e.mock_all_auths(); let admin1 = Address::random(&e); let token = create_token_contract(&e, &admin1); let user1 = Address::random(&e); let vault = create_vault_contract(&e, &install_token_wasm(&e), &token.address); let contract_share = token::Client::new(&e, &vault.share_id()); let token_share = token::Client::new(&e, &contract_share.address); token.mint(&user1, &200); assert_eq!(token.balance(&user1), 200); token.mint(&vault.address, &100); assert_eq!(token.balance(&vault.address), 100); vault.deposit(&user1, &100); assert_eq!( e.auths(), std::vec![( user1.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( vault.address.clone(), symbol_short!(\"deposit\"), (&user1, 100_i128).into_val(&e) )), sub_invocations: std::vec![AuthorizedInvocation { function: AuthorizedFunction::Contract(( token.address.clone(), symbol_short!(\"transfer\"), (&user1, &vault.address, 100_i128).into_val(&e) )), sub_invocations: std::vec![] }] } )] ); assert_eq!(token_share.balance(&user1), 100); assert_eq!(token_share.balance(&vault.address), 0); assert_eq!(token.balance(&user1), 100); assert_eq!(token.balance(&vault.address), 200); e.budget().reset_unlimited(); vault.withdraw(&user1, &100); assert_eq!( e.auths(), std::vec![( user1.clone(), AuthorizedInvocation { function: AuthorizedFunction::Contract(( vault.address.clone(), symbol_short!(\"withdraw\"), (&user1, 100_i128).into_val(&e) )), sub_invocations: std::vec![AuthorizedInvocation { function: AuthorizedFunction::Contract(( token_share.address.clone(), symbol_short!(\"transfer\"), (&user1, &vault.address, 100_i128).into_val(&e) )), sub_invocations: std::vec![] }] } )] ); assert_eq!(token.balance(&user1), 201); assert_eq!(token_share.balance(&user1), 0); assert_eq!(token.balance(&vault.address), 99); assert_eq!(token_share.balance(&vault.address), 0);}#![allow(unused)]use soroban_sdk::{xdr::ToXdr, Address, Bytes, BytesN, Env};soroban_sdk::contractimport!(file = \"./soroban_token_contract.wasm\");pub fn create_contract(e: &Env, token_wasm_hash: BytesN<32>, token: &Address) -> Address { let mut salt = Bytes::new(e); salt.append(&token.to_xdr(e)); let salt = e.crypto().sha256(&salt); e.deployer() .with_current_contract(salt) .deploy(token_wasm_hash)}//! This contract demonstrates a sample implementation of the Soroban token//! interface.use crate::admin::{has_administrator, read_administrator, write_administrator};use crate::allowance::{read_allowance, spend_allowance, write_allowance};use crate::balance::{is_authorized, write_authorization};use crate::balance::{read_balance, receive_balance, spend_balance};use crate::event;use crate::metadata::{read_decimal, read_name, read_symbol, write_metadata};use crate::storage_types::INSTANCE_BUMP_AMOUNT;use soroban_sdk::{contract, contractimpl, Address, Env, String};use soroban_token_sdk::TokenMetadata;pub trait TokenTrait { fn initialize(e: Env, admin: Address, decimal: u32, name: String, symbol: String); fn allowance(e: Env, from: Address, spender: Address) -> i128; fn approve(e: Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32); fn balance(e: Env, id: Address) -> i128; fn spendable_balance(e: Env, id: Address) -> i128; fn authorized(e: Env, id: Address) -> bool; fn transfer(e: Env, from: Address, to: Address, amount: i128); fn transfer_from(e: Env, spender: Address, from: Address, to: Address, amount: i128); fn burn(e: Env, from: Address, amount: i128); fn burn_from(e: Env, spender: Address, from: Address, amount: i128); fn clawback(e: Env, from: Address, amount: i128); fn set_authorized(e: Env, id: Address, authorize: bool); fn mint(e: Env, to: Address, amount: i128); fn set_admin(e: Env, new_admin: Address); fn decimals(e: Env) -> u32; fn name(e: Env) -> String; fn symbol(e: Env) -> String;}fn check_nonnegative_amount(amount: i128) { if amount < 0 { panic!(\"negative amount is not allowed: {}\", amount) }}#[contract]pub struct Token;#[contractimpl]impl TokenTrait for Token { fn initialize(e: Env, admin: Address, decimal: u32, name: String, symbol: String) { if has_administrator(&e) { panic!(\"already initialized\") } write_administrator(&e, &admin); if decimal > u8::MAX.into() { panic!(\"Decimal must fit in a u8\"); } write_metadata( &e, TokenMetadata { decimal, name, symbol, }, ) } fn allowance(e: Env, from: Address, spender: Address) -> i128 { e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); read_allowance(&e, from, spender).amount } fn approve(e: Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32) { from.require_auth(); check_nonnegative_amount(amount); e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); write_allowance(&e, from.clone(), spender.clone(), amount, expiration_ledger); event::approve(&e, from, spender, amount, expiration_ledger); } fn balance(e: Env, id: Address) -> i128 { e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); read_balance(&e, id) } fn spendable_balance(e: Env, id: Address) -> i128 { e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); read_balance(&e, id) } fn authorized(e: Env, id: Address) -> bool { e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); is_authorized(&e, id) } fn transfer(e: Env, from: Address, to: Address, amount: i128) { from.require_auth(); check_nonnegative_amount(amount); e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); spend_balance(&e, from.clone(), amount); receive_balance(&e, to.clone(), amount); event::transfer(&e, from, to, amount); } fn transfer_from(e: Env, spender: Address, from: Address, to: Address, amount: i128) { spender.require_auth(); check_nonnegative_amount(amount); e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); spend_allowance(&e, from.clone(), spender, amount); spend_balance(&e, from.clone(), amount); receive_balance(&e, to.clone(), amount); event::transfer(&e, from, to, amount) } fn burn(e: Env, from: Address, amount: i128) { from.require_auth(); check_nonnegative_amount(amount); e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); spend_balance(&e, from.clone(), amount); event::burn(&e, from, amount); } fn burn_from(e: Env, spender: Address, from: Address, amount: i128) { spender.require_auth(); check_nonnegative_amount(amount); e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); spend_allowance(&e, from.clone(), spender, amount); spend_balance(&e, from.clone(), amount); event::burn(&e, from, amount) } fn clawback(e: Env, from: Address, amount: i128) { check_nonnegative_amount(amount); let admin = read_administrator(&e); admin.require_auth(); e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); spend_balance(&e, from.clone(), amount); event::clawback(&e, admin, from, amount); } fn set_authorized(e: Env, id: Address, authorize: bool) { let admin = read_administrator(&e); admin.require_auth(); e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); write_authorization(&e, id.clone(), authorize); event::set_authorized(&e, admin, id, authorize); } fn mint(e: Env, to: Address, amount: i128) { check_nonnegative_amount(amount); let admin = read_administrator(&e); admin.require_auth(); e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); receive_balance(&e, to.clone(), amount); event::mint(&e, admin, to, amount); } fn set_admin(e: Env, new_admin: Address) { let admin = read_administrator(&e); admin.require_auth(); e.storage().instance().bump(INSTANCE_BUMP_AMOUNT); write_administrator(&e, &new_admin); event::set_admin(&e, admin, new_admin); } fn decimals(e: Env) -> u32 { read_decimal(&e) } fn name(e: Env) -> String { read_name(&e) } fn symbol(e: Env) -> String { read_symbol(&e) }}Now that we've added these files to our project, let's break down what happens in the lib.rs file above and discover how \"yield\" is generated from our vault contractFirst, let's take a look at what happens when a user deposits tokens into the vault contract.fn deposit(e: Env, from: Address, amount: i128) { // Depositor needs to authorize the deposit from.require_auth(); let token = token::Client::new(&e, &get_token(&e)); token.transfer(&from, &e.current_contract_address(), &amount); // Now calculate how many new vault shares to mint let balance = get_token_balance(&e); let shares = amount; mint_shares(&e, from, shares); put_reserve(&e, balance + shares);}The deposit function is called by the depositor to deposit tokens into the vault contract.The transfer method of the token_client instance transfers tokens from the depositor to the vault contract.The current token balance and total shares issued by the vault contract are obtained using the get_token_balance and get_total_shares functions, respectively.mint_shares is called to issue new shares to the depositor and updates the total shares issued by the vault contract.put_reserve stores the current token balance in a reserved location.If the user were to call the deposit method with 100 tokens, the following would happen:100 tokens would be transferred from the depositor to the vault contract.The current token balance would be stored in a reserved location.The total shares issued by the vault contract would be updated to 100.100 shares would be issued to the depositor.Now let's see what happens when a user withdraws tokens from the vault.fn withdraw(e: Env, to: Address, amount: i128) -> i128 { to.require_auth(); // First transfer the vault shares that need to be redeemed let share_token_client = token::Client::new(&e, &get_token_share(&e)); share_token_client.transfer(&to, &e.current_contract_address(), &amount); let token_client = token::Client::new(&e, &get_token(&e)); token_client.transfer( &e.current_contract_address(), &to, &(&amount + (&amount / &100)), ); let balance = get_token_balance(&e); let balance_shares = get_balance_shares(&e); burn_shares(&e, balance_shares); put_reserve(&e, balance - amount); amount}The withdraw function is called by the withdrawer to withdraw tokens from the vault contract.The transfer method of the share_token_client instance transfers shares from the withdrawer to the vault contract.The transfer_token method of the token_client instance transfers tokens from the vault contract to the withdrawer.burn_shares is called to burn the shares that were transferred to the vault contract.put_reserve stores the current token balance in a reserved location.Note : In the withdrawal function, you'll notice that the transfer amount is defined as &(&amount + (&amount / &100)). This is a simple yield calculation that assumes the yield to be 1% of the amount being withdrawn. However, it's important to note that this is a very simplistic approach and may not be suitable for production-grade systems. In reality, yield calculations are more complex and involve various factors such as market conditions, risk management, and fees.If the user were to call the withdraw method with 100 shares, the following would happen:100 shares would be transferred from the withdrawer to the vault contract.The current token balance would be stored in a reserved location.100 shares would be burned.100 + (100/100) tokens would be transferred from the vault contract to the withdrawer.Testing​To test the vault contract, we will can simply run the following command in our terminal from our vault contract directory:#cd vaultcargo testThis will run the tests that we've written in the src/test.rs file.running 1 testtest test::test ... okVault Contract Deployment and Interaction​Now that we have a working vault contract, we can deploy it to a network and interact with it.This section requires you to have a funded Keypair to use with Stellar's Futurenet. You can create and fund one using the Stellar Laboratory.Below you will find a series of commands that will help you build, deploy and interact with the vault and token contracts. You can use them to follow along as we walk through the process of building, deploying, and interacting with the contracts. It may behoove you to keep these commands in a scripts directory in your project. This way, you can easily run them from your terminal.Note : If you decide to use scripts, be sure to double-check your import paths.build.shdeploy_token.shinitialize_token.shmint.shbalance.shinstall.shdeploy_vault.shinitialize_vault.shshare_id.shdeposit.shget_rsrv.shwithdraw.shsoroban contract buildsoroban contract deploy \\ --wasm soroban_token_contract.wasm \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022'soroban contract invoke \\ --wasm soroban_token_contract.wasm \\ --id <TOKEN_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ initialize \\ --admin <USER_ADDRESS> \\ --decimal 18 \\ --name <TOKEN_NAME> \\ --symbol <TOKEN_SYMBOL>soroban contract invoke \\ --wasm soroban_token_contract.wasm \\ --id <TOKEN_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ mint \\ --to <USER_OR_VAULT_ADDRESS> \\ --amount 100soroban contract invoke \\ --wasm soroban_token_contract.wasm \\ --id <TOKEN_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ balance \\ --id <USER_OR_VAULT_ADDRESS>soroban contract install --wasm soroban_token_contract.wasmsoroban contract deploy \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022'soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --id <VAULT_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ initialize \\ --token_wasm_hash 73593275ee3bcacc2aef8d641a1d5108618064bdfff84a826576b8caff395add \\ --token <TOKEN_CONTRACT_ADDRESS>soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --id <VAULT_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ share_idsoroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --id <VAULT_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ deposit \\ --from <USER_ADDRESS> \\ --amount 100soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --id <VAULT_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ get_rsrvssoroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --id <VAULT_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ withdraw \\ --to <USER_ADDRESS> \\ --amount 100First, we need to build the vault contract. We can do this by running the build.sh script from our vault directory.##cd vaultsoroban contract buildNext, we need to deploy the token contract. We can do this by running the deploy_token.sh script.soroban contract deploy \\ --wasm soroban_token_contract.wasm \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022'We should receive an output with the token contract ID. We will need this ID for the next step.42b50b954e868b1255e20c9180ab53fb2112f035fb3dcff15b47bdd18ef05284Next we need to initialize the token contract. We can do this by running the initialize_token.sh script.It's important to note that name and symbol must be Bytes values. You can achieve this by converting a given value into its corresponding hex-encoded byte values.Here are some examples:USDC: 55534443USD: 555344soroban contract invoke \\ --wasm soroban_token_contract.wasm \\ --id <TOKEN_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ initialize \\ --admin <USER_ADDRESS> \\ --decimal 18 \\ --name <TOKEN_NAME> \\ --symbol <TOKEN_SYMBOL>Next, we need to deploy the vault contract. We can do this by running the deploy_vault.sh script.soroban contract deploy \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022'We should receive an output with the vault contract ID. We will need this ID for the next step.07829f515df7d320101a8643b685c82d16e15d92bd11a49d2623a8b93b28bfd8Now we need to get the Wasm hash of the token contract. We can do this by running the get_token_wasm_hash.sh script.soroban contract install --wasm soroban_token_contract.wasmWe should receive the Wasm hash of the token contract.68f5c739b568664e3c4f4b7787958ce4ba527cc310fb0de0fea707dc1d6bd3c3Now we need to initialize the vault contract. We can do this by running the initialize_vault.sh script.It's important to note that the token contract id will need to change formats for the call to work. We can convert the token contract id to the correct format by leveraging the js-soroban-client.First, navigate to and clone the following runkit.Then, replace contractId with your own vault contract id.const StellarSdk = require(\"soroban-client\");function getContractKey(contractId) { const contractIdBytes = Buffer.from(contractId, \"hex\"); const contractKey = StellarSdk.StrKey.encodeContract(contractIdBytes); return contractKey;}const contractId = <TOKEN_CONTRACT_ID>( console.log(\"Contract Key: \" + getContractKey(contractId)));You should see an output similar to the following:\"Contract Key: CBBLKC4VJ2DIWESV4IGJDAFLKP5SCEXQGX5T3T7RLND33UMO6BJIJFMM\";soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --id <VAULT_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ initialize \\ --token_wasm_hash 73593275ee3bcacc2aef8d641a1d5108618064bdfff84a826576b8caff395add \\ --token <TOKEN_CONTRACT_ADDRESS>After recieving the transaction has been submitted, we will mint some tokens to both our User Account and Vault Contract addresses. We can do this by running the mint.sh script.Similar to changing the token contract id, the vault contract will need to change formats for the call to work. We can convert the vault contract id to the correct format by repeating the steps above to convert the token contract id but this time with the vault contract id.const StellarSdk = require(\"soroban-client\");function getContractKey(contractId) { const contractIdBytes = Buffer.from(contractId, \"hex\"); const contractKey = StellarSdk.StrKey.encodeContract(contractIdBytes); return contractKey;}const contractId = <VAULT_CONTRACT_ID>( console.log(\"Contract Key: \" + getContractKey(contractId)));Now we can run the mint.sh script with the correct vault contract address.soroban contract invoke \\ --wasm soroban_token_contract.wasm \\ --id <TOKEN_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ mint \\ --to <USER_OR_VAULT_ADDRESS> \\ --amount 100After submitting the transaction, we can check the balance of the account. We can do this by running the balance.sh script.soroban contract invoke \\ --wasm soroban_token_contract.wasm \\ --id <TOKEN_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ balance \\ --id <USER_ADDRESS>We should receive an output with the balance of the account.100Now we can deposit some tokens into our vault. We can do this by running the deposit.sh script.soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --id <VAULT_CONTRACT_ID> \\ --source <ACCOUNT_SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ deposit \\ --from <USER_ADDRESS> \\ --amount 100After submitting the transaction, we can check the reserves of the vault. We can do this by running the reserves.sh script.soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --id <VAULT_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ get_rsrvsWe should receive an output with the reserves of the vault.\"200\"100 from the deposit and 100 from the mint.Now we can withdraw some tokens from the vault. We can do this by running the withdraw.sh script.soroban contract invoke \\ --wasm target/wasm32-unknown-unknown/release/vault.wasm \\ --id <VAULT_CONTRACT_ID> \\ --source <SECRET_KEY> \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022' \\ -- \\ withdraw \\ --to <USER_ADDRESS> \\ --amount 100We should receive an output with the withdrawal amount.\"100\"Now is a good time to check our account balance again. We can do this by running the balance.sh script.We should see our balance has increased the amount we withdrew plus yield (amount/100) or %1 of our withdraw amount.101And finally, we can check the reserves of the vault again. We can do this by running the get_rsrv.sh script.We should see the reserves of the vault have decreased by the amount we withdrew + yield.\"99\"And there you have it! You have successfully deployed and interacted with the vault contract!Its important to note that this is not a production ready contract and is only meant to demonstrate the capabilities of the Soroban smart contract platform. We hope to see much more complex yield contracts deployed with Soroban in the future, and we hope you will be a part of it!","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/migrating-from-evm/smart-contract-deployment","title":"Smart Contract Development with Soroban and Hardhat","contentLength":5145}},{"pageContent":"Persisting DataLedger entries​Contracts can access ledger entries of type CONTRACT_DATA. Host functions are provided to probe, read, write, and delete CONTRACT_DATA ledger entries.Each CONTRACT_DATA ledger entry is keyed in the ledger by the contract ID that owns it, its storage type (Persistent, Temporary, Instance) as well as a single user-chosen value, of the standard value type. This means that the user-chosen key may be a simple value such as a symbol, number or binary blob, or it may be a more complex structured value like a vector or map with multiple sub-values.Each CONTRACT_DATA ledger entry also holds (in addition to its key) a single value associated with the key. Again, this value may be simple like a symbol or number, or may be complex like a vector or map with many sub-values.No serialization or deserialization is required in contract code when accessing CONTRACT_DATA ledger entries: the host automatically serializes and deserializes any ledger entries accessed, exchanging them with the contract as deserialized values. If a contract wishes to use a custom serialization format, it can store a binary-valued CONTRACT_DATA ledger entry and provide its own code to serialize and deserialize, but Soroban has been designed with the intent to minimize the need for contracts to ever do this.Access Control​Contracts are only allowed to read and write CONTRACT_DATA ledger entries owned by the contract: those keyed by the same contract ID as the contract performing the read or write. Attempting to access other CONTRACT_DATA ledger entries will cause a transaction to fail.There is no access control for lifetime bump operations. Any user may invoke BumpFootprintExpirationOp on any LedgerEntry.Granularity​A CONTRACT_DATA ledger entry is read or written from the ledger in its entirety; there is no way to read or write \"only a part\" of a CONTRACT_DATA ledger entry. There is also a fixed overhead cost to accessing any CONTRACT_DATA ledger entry. Contracts are therefore responsible for dividing logically \"large\" data structures into \"pieces\" with an appropriate size granularity, to use for reading and writing. If pieces are too large there may be unnecessary costs paid for reading and writing unused data, as well as unnecessary contention in parallel execution; but if pieces are too small there may be unnecessary costs paid for the fixed overhead of each entry.Footprints and parallel contention​Contracts are only allowed to access ledger entries specified in the footprint of their transaction. Transactions with overlapping footprints are said to contend, and will only execute sequentially with respect to one another, on a single thread. Transactions with non-overlapping footprints may execute in parallel. This means that a finer granularity of CONTRACT_DATA ledger entries may reduce artificial contention among transactions using a contract, and thereby increase parallelism.Contract Data Best Practices​Account State vs. Shared State​While there is no distinction between \"account\" state and \"shared\" state at the protocol level, it can be helpful to think of data in these terms when deciding what storage type and lifetime bump strategy to use for a given use case. As a guideline, account and shared state can be described as follows:Most contract state can either be associated with a specific account or shared between multiple stakeholders (“public good”)Account specific stateBalances, positions, allowances, etc.Shared stateAdmin entry, pool values, etc.There are two subcategories of shared state\"Global\" state shared by all contract usersContract instance, contract wasm, or a global adminState shared by only a specific subset of usersAMM pool values In an AMM monolith contract (Uniswap V4 style)Note: Sometimes account and shared state can merge when the contract scope is smallI.e. smart wallet or a single nft, where a new contract instance is generated for each accountOwned Contracts vs. Autonomous Contracts​In addition to the types of state, it is also helpful to consider the type of contract instance being used. Again, these types are not enforced at the protocol level, but can be helpful.Owned contractsContract instances that have a clear ownerA smart wallet or a single nft, where a new contract instance is generated for each accountCustom reserve backed assets (USDC, etc)Autonomous contractsContract instance that have not clear owner, or have a decentralized group of ownersMost DeFi protocols, especially non-upgradable onesBest Practices​Prefer Temporary over Persistent and Instance storageAnything that can have a timeout should be Temporary with expiration set to the timeout. Maximum timeout/expiration is currently 1 yearIdeally, Temporary entries should be associated with an absolute ledger boundary and thus never bumpedExample: Soroban Auth signatures have an absolute expiration ledger, so nonces can be stored in Temporary entries without security risksExample: SAC allowance that lives only until a given ledger (so that some old allowance signature can not be used in the future if not exhausted)All global state that cannot be Temporary should be in Instance storageThis guarantees that the lifetime of the contract instance and all relevant globals are tied togetherSince global state is used often, this ensures that global state will never need to be restored, leading to cheaper and more efficient contract invocationsAutonomous contracts should bump any shared state touched by an invocation via the bump() host functionGiven that these contracts have no owners, leaving lifetime bumps to benevolent clients might lead to a “tragedy of the commons” situationMost users do not bump the lifetime because it is not required, but still benefit from the benevolent client who does bump the lifetimeOwners of owned contracts should subsidize shared state lifetime extension fees by manually submitting bump operationsOwners should keep track of expiration ledgers for all shared stateThis could be implemented via something like a cron job where a BumpFootprintExpirationOp for all relevant shared state is submitted periodically (i.e. once a month)Alternatively, this could also be implemented via an admin smart contract function routinely called by the ownerClients (Wallets/Dapps) should identify the state that relates to their respective account, present expiration info to the users, and suggest lifetime bumps when necessaryLifetime extensions should never be relied on for functionality or safetyUnsafe example: An entry must be permanent, but instead of using Persistent storage, a contract uses Temporary storage but will continually bump the entry so it never expiresBecause there is no automatic lifetime extension interface, and every bump must come from either a smart contract invocation or BumpFootprintExpirationOp, it must be assumed that an entry can always expireLifetime extension fees are variable, and it may become too expensive to bump pseudo “persistent” Temporary entries if fees increase unexpectedlyIf the rent bump process is automated (i.e. a cron job) the account automatically sending BumpFootprintExpirationOps may run out of funds unexpectedly should lifetime extension fees increase, causing the Temporary entry to expire and be permanently deletedEntry expiration should never be relied on for functionality or safetyUnsafe example: a nonce should expire in 7 days, so a contract creates a Temporary entry and bumps the lifetime to 7 days with no other lifetime enforcement in place.Anyone can submit a rent bump operation on any entry without authorization, meaning that the nonce can have its lifetime extended indefinitely by any userIf an entry needs to be invalidated after a certain time period, this must be implemented manually by the contract","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/persisting-data","title":"Persisting Data","contentLength":1209}},{"pageContent":"State ExpirationContract data is made up of three different types: Persistent, Temporary, and Instance. In a contract, these are accessed with env.storage().persistent(), env.storage().temporary(), and env.storage().instance() respectively; see the storage() docs.All contract data has a \"lifetime\" that must be periodically bumped. If an entry's lifetime is not periodically bumped, the entry will eventually reach the end of its lifetime and \"expire\". Each type of storage functions similarly, but have different fees and expiration behavior:When a Temporary entry expires, it is deleted from the ledger and is permanently inaccessible.When a Persistent or Instance entry expires, it is inaccessible, but can be \"restored\" and used again via the RestoreFootprintOp.Contract Data Type Descriptions​The general usage and interface is identical for all storage types. They differ only in fees and expiration behavior as follows:Temporary​Cheapest fees.Permanently deleted on expiration, cannot be restored.Suitable for time bounded data (i.e. price oracles, signatures, etc.) and easily recreateable data.Unlimited amount of storage.Instance​Most expensive fees (same price as Persistent storage).Recoverable after expiration, can be restored using the RestoreFootprintOp operation.Shares the same lifetime as the contract instance. If the contract instance has not expired, instance data is guaranteed to be accessible and not expired.Limited amount of storage available.Suitable for \"shared\" contract state that cannot be Temporary (i.e. admin accounts, contract metadata, etc.).Persistent​Most expensive fees (same price as Instance storage).Recoverable after expiration, can be restored using the RestoreFootprintOp operation.Does not share the same lifetime as the contract instance. If the contract instance is not expired, Persistent data may be expired and need to be restored before invoking the contract.Unlimited amount of storage.Suitable for user data that cannot be Temporary (i.e. balances).Contract Data Best Practices​As a general rule, Temporary storage should only be used for data that can be easily recreated or is only valid for a period of time, where Persistent or Instance storage should be used for data that cannot be recreated and should be kept permanently, such as a user's token balance.Each storage type is in a separate key space. To demonstrate this, see the code snippet below:const EXAMPLE_KEY: Symbol = symbol_short!(\"KEY\");env.storage().persistent().set(&EXAMPLE_KEY, 1);env.storage().temporary().set(&EXAMPLE_KEY, 2);env.storage().persistent().get(&EXAMPLE_KEY); // Returns Ok(1)env.storage().temporary().get(&EXAMPLE_KEY); // Returns Ok(2)All Instance storage is stored in a single contract instance LedgerEntry and shares a single lifetime. This means that one call to Env.storage().instance().bump() will extend the lifetime of all Instance entries, as well as the contract instance itself. For Temporary and Persistent storage, each entry has its own lifetime and must be bumped individually. The interface is slightly different and takes the key of the entry being bumped as well as the new lifetime.A call to bump(N) ensures that the current lifetime of the contract instance entry is at least N ledgers. For example, if bump(100) is called and the contract instance entry has a current lifetime of 50 ledgers, the lifetime will be extended to 100 ledgers. If bump(100) is called and the contract instance entry has a current lifetime of 150 ledgers, the lifetime will not be extended and the bump() call is a no-op.In addition to contract defined lifetime extensions using the bump() function, a contract data entry's lifetime can be extended via the BumpFootprintExpirationOp operation.Terms and Semantics​Expiration Ledger​Each ContractData and ContractCode entry has an expirationLedger field stored in its LedgerEntry. The entry is considered expired when current_ledger > expirationLedger.Lifetime​An entry's lifetime is defined as how many ledgers remain until the entry expires. For example, if the current ledger is 5 and an entry's expiration ledger is 15, then the entry's lifetime is 10 ledgers.Minimum Lifetime​For each entry type, there is a minimum lifetime that the entry must have when being created or updated. This lifetime minimum is enforced automatically at the protocol level. This minimum is a network parameter and defaults to 16 ledgers for Temporary entries and 4,096 ledgers for Persistent and Instance entries.Maximum Lifetime​On any given ledger, an entry's lifetime can be extended up to the maximum lifetime. This is a network parameter and defaults to 1 year worth of ledgers. This maximum lifetime is not enforced based on when an entry was created, but based on the current ledger. For example, if an entry is created on January 1st, 2024, its lifetime could initially be bumped up to January 1st, 2025. After this initial lifetime bump, if the entry received another lifetime bump later on January 10th, 2024, the lifetime could be extended up to January 10th, 2025.Operations​BumpFootprintExpirationOp​Semantics​XDR:/* Threshold: med Result: BumpFootprintExpirationResult*/struct BumpFootprintExpirationOp{ ExtensionPoint ext; uint32 ledgersToExpire;};BumpFootprintExpirationOp is a Soroban operation that will bump the expiration ledger of the entries specified in the read-only set of the footprint. The read-write set must be empty. The bump will make sure that the entries will not expire before ledgersToExpire ledgers from now.Let's look at this example below.Ex. Last closed ledger (LCL) = 5, Current Ledger = 6, ledgersToExpire = 8entry1.expirationLedger = 10entry2.expirationLedger = 14entry3.expirationLedger = 10000entry1.expirationLedger will be updated to 14 so it will live for 8 more ledgersafter the current one closes and the entry can be accessed in ledgers [6, 14]. Note: This is going to be updated to countCurrent Ledger, so it'll become [6, 13].entry2 and entry3 will not be updated because they already have anexpirationLedger that is large enough.Transaction resources​BumpFootprintExpirationOp is a Soroban operation, and therefore must be the only operation in a transaction. The transaction also needs to populate SorobanTransactionData transaction extension explained here. To fill out SorobanResources, use preflight mentioned in the provided link, or make sure readBytes includes the key and entry size of every entry in the readOnly set and make sure extendedMetaDataSizeBytes is at least double of readBytes.RestoreFootprintOp​XDR:/* Threshold: med Result: RestoreFootprintOp*/struct RestoreFootprintOp{ ExtensionPoint ext;};RestoreFootprintOp is a Soroban operation that will restore expired entries specified in the read-write set of the footprint and make them accessible again. The read-only set of the footprint must be empty. An expired entry is one where its expirationLedger is less than the current ledger number.The restored entry will have its expiration ledger bumped to the minimums the network allows for newly created entries, which is 4096 + current ledger for persistent entries, and 16 + current ledger for temporary entries (Note that both will be updated soon to use 4096 + current ledger - 1 and 16 + current ledger - 1). The minimums linked are what the settings will be on release, but they can be updated in the future through a validator vote.Transaction resources​RestoreFootprintOp is a Soroban operation, and therefore must be the only operation in a transaction. The transaction also needs to populate SorobanTransactionData transaction extension explained here. To fill out SorobanResources, use preflight mentioned in the provided link, or make sure writeBytes includes the key and entry size of every entry in the readWrite set and make sure extendedMetaDataSizeBytes is at least double of writeBytes.","metadata":{"source":"https://soroban.stellar.org/docs/fundamentals-and-concepts/state-expiration","title":"State Expiration","contentLength":1214}},{"pageContent":"Soroban Rust SDKThe soroban-sdk Rust crate contains the Soroban Rust SDK.infoReport issues and share feedback about the soroban-sdk here.SDK Documentation​SDK documentation is available at: https://docs.rs/soroban-sdkSubscribe to Releases​Subscribe to releases on the GitHub repository: https://github.com/stellar/rs-soroban-sdkAdd soroban-sdk as a Dependency​Use crates.io to find the version of the most recent SDK release.Add the following sections to the Cargo.toml to import the soroban-sdk and replace $VERSION with the released version.[dependencies]soroban-sdk = $VERSION[dev_dependencies]soroban-sdk = { version = $VERSION, features = [\"testutils\"] }","metadata":{"source":"https://soroban.stellar.org/docs/reference/sdks/rust","title":"Soroban Rust SDK","contentLength":99}},{"pageContent":"JavaScript SDKjs-soroban-client is a Javascript library for communicating with a Soroban RPC server. It is used for building Stellar apps either on Node.js or in the browser.It provides:a networking layer API for soroban-rpc methods.facilities for building and signing transactions, for communicating with a soroban-rpc instance, and for submitting transactions or querying network state.JavaScript SDK​SDK is available at: https://github.com/stellar/js-soroban-client","metadata":{"source":"https://soroban.stellar.org/docs/reference/sdks/js","title":"JavaScript SDK","contentLength":74}},{"pageContent":"Python SDKpy-stellar-base is a Python library for communicating with a Stellar Horizon server. It is used for building Stellar apps on Python. It supports Python 3.7+ as well as PyPy 3.7+.This SDK is maintained by a dedicated community developer.It provides:a networking layer API for Horizon endpoints.facilities for building and signing transactions, for communicating with a Stellar Horizon instance, and for submitting transactions or querying network history.Python SDK​The Python SDK is available at: https://github.com/StellarCN/py-stellar-base/tree/soroban","metadata":{"source":"https://soroban.stellar.org/docs/reference/sdks/python","title":"Python SDK","contentLength":91}},{"pageContent":"AssemblyScript SDKThe as-soroban-sdk is an open source SDK that supports writing programs for the Soroban smart contract platform by using the AssemblyScript programming language.The AssemblyScript Soroban SDK is maintained by dedicated community developer, Soneso.infoReport issues and share feedback about the AssemblyScript Soroban SDK here.SDK Documentation​SDK documentation is available at: https://github.com/Soneso/as-soroban-sdkExamples​Many examples are available at: https://github.com/Soneso/as-soroban-examplesSubscribe to Releases​Subscribe to releases on the GitHub repository: https://github.com/Soneso/as-soroban-sdkAdd as-soroban-sdk as a Dependency​npm install as-soroban-sdk","metadata":{"source":"https://soroban.stellar.org/docs/reference/sdks/assemblyscript-sdk","title":"AssemblyScript SDK","contentLength":101}},{"pageContent":"iOS SDKThe stellar-ios-mac-sdk is an open source Stellar SDK for iOS & Mac. It provides APIs to build transactions and connect to Horizon.It also provides functionality to deploy and invoke Soroban smart contracts and communicates with the Soroban RPC Server.The iOS Stellar SDK is maintained by dedicated community developer, Soneso.SDK Documentation for Soroban​The SDK documentation for Soroban features is available here.","metadata":{"source":"https://soroban.stellar.org/docs/reference/sdks/ios-sdk","title":"iOS SDK","contentLength":67}},{"pageContent":"Flutter SDKThe stellar-flutter-sdk is an open source Stellar SDK for Flutter developers. It provides APIs to build transactions and connect to Horizon.It also provides functionality to deploy and invoke Soroban smart contracts and communicates with the Soroban RPC Server.The Flutter Stellar SDK is maintained by dedicated community developer, Soneso.SDK Documentation for Soroban​The SDK documentation for Soroban features is available here.","metadata":{"source":"https://soroban.stellar.org/docs/reference/sdks/flutter-sdk","title":"Flutter SDK","contentLength":66}},{"pageContent":"PHP SDKThe stellar-php-sdk is an open source Stellar SDK for PHP developers. It provides APIs to build transactions and connect to Horizon.It also provides functionality to deploy and invoke Soroban smart contracts and communicates with the Soroban RPC Server.The PHP Stellar SDK is maintained by dedicated community developer, Soneso.SDK Documentation for Soroban​The SDK documentation for Soroban features is available here.","metadata":{"source":"https://soroban.stellar.org/docs/reference/sdks/php-sdk","title":"PHP SDK","contentLength":66}},{"pageContent":"Elixir SDKSoroban.ex is an open source library for Elixir to interact with the Soroban-RPC server, and facilitate the deployment and invocation of Soroban smart contracts.The Elixir SDK (Soroban.ex) can be found on GitHub at https://github.com/kommitters/soroban.ex.This SDK is maintained by dedicated community developers, kommitters Open Source.Documentation​Documentation is available at https://github.com/kommitters/soroban.ex#documentation.","metadata":{"source":"https://soroban.stellar.org/docs/reference/sdks/elixir","title":"Elixir SDK","contentLength":67}},{"pageContent":"Build Your Own SDKSoroban currently has one SDK for writing contracts in Rust, which can be found here.To build SDKs for other languages a few things need to be included in the SDK to provide contracts with the foundation they need to accept inputs, decode them, store data, call other contracts, etc.Below is a list of functionality a Soroban SDK needs to support those things, as well as some details on what an SDK can provide in regards to testing capabilities.cautionThe Soroban environment is under active development and no API compatibility guarantee exists at this time.Functionality​Value Conversions​RawVal encode/decodeObject encode/decodeSymbol encode/decodeStatus encode/decodeHost Functions​The host functions defined in env.json are functions callable from within the Wasm Guest environment. These need to be available to contracts to call, in some form, ideally wrapped so that contracts have a nicer interface.Host functions have friendly names in the file above, such as get_ledger_version, however in the Wasm they are only importable via short names, such as x.4. The letter proceeding the dot is the module, and the value after the dot is the function name. The mappins are available in env.rs.SDK Types​All the types in soroban-sdk should be supported. Notably:MapVecBytesUser Defined Types​Contracts should be able to create user defined types, such as structs, unions, or enums, and have them be transmitted to the host for storing and transmitted back for loading.SDKs do this by converting objects to and from a Val. In the soroban-sdk this is referred to as a RawVal.Structs​Structs with named fields should be translated into a Map with keys as Symbols and the values as the field value, i.e. Map<Symbol, V>.Structs with unnamed fields should be translated into a Vec with the values as the elements. i.e. Vec<V>.Unions​Unions (or enums in some languages) with named variants and unit or tuple values should be translated into a Vec with the first element as a Symbol of the name of the variant, and zero or more additional elements representing a value stored with the variant.Enums​Enums with integer values should be translated into a u32.User Defined Errors​Errors are u32 values that are translated into a Status.Environment Meta Generation​Contracts must contain a Wasm custom section with name contractenvmetav0 and containing a serialized SCEnvMetaEntry. The interface version stored within should match the version of the host functions supported.Contract Spec Generation​Contracts should contain a Wasm custom section with name contractspecv0 and containing a serialized stream of SCSpecEntry. There should be a SCSpecEntry for every function, struct, and union exported by the contract.Contract Meta Generation​Contracts may optionally contain a Wasm custom section with name contractmetav0 and containing a serialized SCMetaEntry. Contracts may store any metadata in the entries that can be used by applications and tooling off-network.Testing​Any Soroban SDK ideally provides a test environment for executing contract functions in the context of a Soroban runtime environment. The soroban-sdk does this by embedding the Soroban environment Rust library, soroban-env-host.The test environment should include:Invoking contract functions.Integration testing across multiple contracts.","metadata":{"source":"https://soroban.stellar.org/docs/reference/sdks/build-your-own-sdk","title":"Build Your Own SDK","contentLength":539}},{"pageContent":"Token InterfaceToken contracts, including the Stellar Asset Contract and example token implementations expose the following common interface.Tokens deployed on Soroban can implement any interface they choose, however, they should satisfy the following interface to be interoperable with contracts built to support Soroban's built-in tokens.Note, that in the specific cases the interface doesn't have to be fully implemented. For example, the custom token may not implement the administrative interface compatible with the Stellar Asset Contract - it won't stop it from being usable in the contracts that only perform the regular user operations (transfers, allowances, balances etc.).Compatibility Requirements​For any given contract function, there are 3 requirements that should be consistent with the interface described here:Function interface (name and arguments) - if not consistent, then the users simply won't be able to use the function at all. This is the hard requirement.Authorization - the users have to authorize the token function calls with all the arguments of the invocation (see the interface comments). If this is inconsistent, then the custom token may have issues with getting the correct signatures from the users and may also confuse the wallet software.Events - the token has to emit the events in the specified format. If inconsistent, then the token may not be handled correctly by the downstream systems such as block explorers.Code​The interface below uses the Rust soroban-sdk.pub trait Contract { // -------------------------------------------------------------------------------- // Admin interface – privileged functions. // -------------------------------------------------------------------------------- // // All the admin functions have to be authorized by the admin with all input // arguments, i.e. they have to call `admin.require_auth()`. /// Clawback \"amount\" from \"from\" account. \"amount\" is burned. /// Emit event with topics = [\"clawback\", admin: Address, to: Address], data = [amount: i128] fn clawback( env: soroban_sdk::Env, from: Address, amount: i128, ); /// Mints \"amount\" to \"to\". /// Emit event with topics = [\"mint\", admin: Address, to: Address], data = [amount: i128] fn mint( env: soroban_sdk::Env, to: Address, amount: i128, ); /// Sets the administrator to the specified address \"new_admin\". /// Emit event with topics = [\"set_admin\", admin: Address], data = [new_admin: Address] fn set_admin( env: soroban_sdk::Env, new_admin: Address, ); /// Sets whether the account is authorized to use its balance. /// If \"authorized\" is true, \"id\" should be able to use its balance. /// Emit event with topics = [\"set_authorized\", id: Address], data = [authorize: bool] fn set_authorized( env: soroban_sdk::Env, id: Address, authorized: bool, ); // -------------------------------------------------------------------------------- // Token interface // -------------------------------------------------------------------------------- // // All the functions here have to be authorized by the token spender // (usually named `from` here) using all the input arguments, i.e. they have // to call `from.require_auth()`. /// Set the allowance by \"amount\" for \"spender\" to transfer/burn from \"from\". /// \"expiration_ledger\" is the ledger number where this allowance expires. It cannot /// be less than the current ledger number unless the amount is being set to 0. /// An expired entry (where \"expiration_ledger\" < the current ledger number) /// should be treated as a 0 amount allowance. /// Emit event with topics = [\"approve\", from: Address, spender: Address], data = [amount: i128, expiration_ledger: u32] fn approve( env: soroban_sdk::Env, from: Address, spender: Address, amount: i128, expiration_ledger: u32, ); /// Transfer \"amount\" from \"from\" to \"to\". /// Emit event with topics = [\"transfer\", from: Address, to: Address], data = [amount: i128] fn transfer( env: soroban_sdk::Env, from: Address, to: Address, amount: i128, ); /// Transfer \"amount\" from \"from\" to \"to\", consuming the allowance of \"spender\". /// Authorized by spender (`spender.require_auth()`). /// Emit event with topics = [\"transfer\", from: Address, to: Address], data = [amount: i128] fn transfer_from( env: soroban_sdk::Env, spender: Address, from: Address, to: Address, amount: i128, ); /// Burn \"amount\" from \"from\". /// Emit event with topics = [\"burn\", from: Address], data = [amount: i128] fn burn( env: soroban_sdk::Env, from: Address, amount: i128, ); /// Burn \"amount\" from \"from\", consuming the allowance of \"spender\". /// Emit event with topics = [\"burn\", from: Address], data = [amount: i128] fn burn_from( env: soroban_sdk::Env, spender: Address, from: Address, amount: i128, ); // -------------------------------------------------------------------------------- // Read-only Token interface // -------------------------------------------------------------------------------- // // The functions here don't need any authorization and don't emit any // events. /// Get the balance of \"id\". fn balance(env: soroban_sdk::Env, id: Address) -> i128; /// Get the spendable balance of \"id\". This will return the same value as balance() /// unless this is called on the Stellar Asset Contract, in which case this can /// be less due to reserves/liabilities. fn spendable_balance(env: soroban_sdk::Env id: Address) -> i128; // Returns true if \"id\" is authorized to use its balance. fn authorized(env: soroban_sdk::Env, id: Address) -> bool; /// Get the allowance for \"spender\" to transfer from \"from\". fn allowance( env: soroban_sdk::Env, from: Address, spender: Address, ) -> i128; // -------------------------------------------------------------------------------- // Descriptive Interface // -------------------------------------------------------------------------------- // Get the number of decimals used to represent amounts of this token. fn decimals(env: soroban_sdk::Env) -> u32; // Get the name for this token. fn name(env: soroban_sdk::Env) -> soroban_sdk::Bytes; // Get the symbol for this token. fn symbol(env: soroban_sdk::Env) -> soroban_sdk::Bytes;}CAUTION WHEN MODIFYING ALLOWANCESThe approve function overwrites the previous value with amount, so it is possible for the previous allowance to be spent in an earlier transaction before amount is written in a later transaction. The result of this is that spender can spend more than intended. This issue can be avoided by first setting the allowance to 0, verifying that the spender didn't spend any portion of the previous allowance, and then setting the allowance to the new desired amount. You can read more about this issue here - https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729.Metadata​Another requirement for complying with the token interface is to write the standard metadata (decimal, name, and symbol) for the token in a specific format. This format allows users to directly read constant data from the ledger instead of invoking a Wasm function. The token example demonstrates how to use the Rust soroban-token-sdk to write the metadata, and we strongly encourage token implementations to follow this approach.Handling Failure Conditions​In the token interface, there are several instances where function calls can fail due to various reasons such as lack of proper authorization, insufficient allowance or balance, etc. To handle these failure conditions, it is important to specify the expected behavior when such situations arise.Its important to note the that the token interface not only incorporates the authorization concept for matching asset authorization in Stellar Classic, but it also utilizes the Soroban authorization mechanism. So, if you try to make a token call and it fails, it could be because of either token authorization processes.To provide more context, when you use the token interface, there is a function called authorized that returns \"true\" if an address has token authorization.More details on Authorization can be found here.For the functions in the token interface, trapping should be used as the standard way to handle failure conditions since the interface is not designed to return error codes. This means that when a function encounters an error, it will halt execution and revert any state changes that occurred during the function call.Failure Conditions​Here is a list of basic failure conditions and their expected behavior for functions in the token interface:Admin functions:​If the admin did not authorize the call, the function should trap.If the admin attempts to perform an invalid action (e.g., minting a negative amount), the function should trap.Token functions:​If the caller is not authorized to perform the action (e.g., transferring tokens without proper authorization), the function should trap.If the action would result in an invalid state (e.g., transferring more tokens than available in the balance or allowance), the function should trap.Example: Handling Insufficient Allowance in burn_from function​In the burn_from function, the token contract should check whether the spender has enough allowance to burn the specified amount of tokens from the from address. If the allowance is insufficient, the function should trap, halting execution and reverting any state changes.Here's an example of how the burn_from function can be modified to handle this failure condition:fn burn_from( env: soroban_sdk::Env, spender: Address, from: Address, amount: i128,) { // Check if the spender has enough allowance let current_allowance = allowance(env, from, spender); if current_allowance < amount { // Trap if the allowance is insufficient panic!(\"Insufficient allowance\"); } // Proceed with burning tokens // ...}By clearly outlining how to handle failures and incorporating the right error management techniques in the token interface, we can make token contracts stronger and safer.","metadata":{"source":"https://soroban.stellar.org/docs/reference/interfaces/token-interface","title":"Token Interface","contentLength":1363}},{"pageContent":"FuturenetFuturenet is available as the first shared test network to enable developers to learn, tinker and build applications on Soroban while being able to interact with other participants.FuturenetNetwork PassphraseTest SDF Future Network ; October 2022Horizon APIhttps://horizon-futurenet.stellar.orgFriendbot APIhttps://friendbot-futurenet.stellar.orgValidatorcore-live-futurenet.stellar.orgHistory Archivehttps://history-futurenet.stellar.orgcautionFuturenet can be reset at any time. A reset erases all accounts, contract data, and contract deployments from the network.cautionAll components deployed to Futurenet and releases supporting Futurenet, such as the Soroban RPC Server, are in active development and will be unstable at times. They should be treated as development releases with no production capabilities, API or backward compatibility guarantees.","metadata":{"source":"https://soroban.stellar.org/docs/reference/futurenet","title":"Futurenet","contentLength":114}},{"pageContent":"ReleasesThe following Soroban releases are preview releases.We’re releasing early versions of Soroban because we believe it’s important to share the development process, and we want Stellar ecosystem developers and smart contract developers from other ecosystems to have a chance to experiment and provide feedback.cautionPreview releases are software releases that are also released to the Futurenet test network. Software releases may occur between Futurenet releases. If you're interacting with Futurenet the recommended software versions to use in development are below. Releases to Futurenet may include network resets and network passphrase changes.Preview 10 (July 13, 2023)​Software​SoftwareVersionXDRe372df9f677961aac04c5a4cc80a3667f310b29fSoroban Environmentv0.0.17Soroban Interface Version51Stellar Core19.12.1-1406.b7d3a8f8d.focal~sorobanSoroban Rust SDKv0.9.2Soroban CLIv0.9.1Soroban RPCv0.9.2Stellar Horizonstellar-horizon:2.26.1~soroban-373Stellar Friendbotsoroban-v0.0.2-alphaStellar Quickstartstellar/quickstart:[email protected]:8a99332f834ca82e3ac1418143736af59b5288e792d1c4278d6c547c6ed8da3bStellar JS Stellar Base10.0.0-soroban.3Stellar JS Soroban Client0.9.2Freighter5.2.3Laboratory2.11.0Soroban React Payment dapp1.1.0Soroban Mint Token dapp1.1.0Futurenet Network PassphraseTest SDF Future Network ; October 2022Changelog​XDR​Remove TransactionResultV2Regenerate for overhaul of error codesBump xdrBump XDRUpdate for state-expiration XDR changesUpdate rust-versionBump XDRRegenerate for new crypto cost typesBump XDRBump opGenerate for storage type removalDrop ContractCostType::VerifyEcdsaSecp256k1SigUpdate next to pickup int256 cost typesRegenerate renameRegenerate for typoBump xdr with contract instance storage changesRegenerate for removal of ScVal::StorageTypeRegenerate for RestoreFootprintOpGenerate renameUpdate crate-git-revisionSoroban Environment​Move a bunch of code out of host, reorg modules slightly.Remove temp storage, fixes #758Bump xdrAnti featuresErr reformSome further cleanups to diagnostic eventsBump xdrEnforce AUTH_REVOCABLE on contract balancesImplement PRNG subsystem (round 2)Remove incorrect debug_assert from ed25519_pub_key_from_bytesSupport Auth Next for host fnsBump xdrUpdate rust-versionSwitch to wasmi native fuel meteringFix get_authenticated_authorizations test utility.Change authentication contract errors to be auth errors.Improve VmInstantiation calibrationUpdate storage interface for state expirationUpdate README.mdImplement contract expiration bumpsCalibrate wasmi fuel and tiered wasm instructionsBump env XDRImplement TryFrom<&Error> for ScValProvide host function for authorizing deep contract calls from current contractSwitch auth from autoincrement nonces to temporary random values.Fix metering for internal eventsReturn strings for name/symbol and use strkey for issuer.Remove Mergeable and rename Exclusive to PersistentAdd secp256k1 and keccak256 host functionsAdd host functions for returning contract idsFix comparisonsRename rawval to valEnforce readonly footprint on bumpAdd host functions for {u,i}256 arithmeticsMore raw to valSupport Timepoint, DurationBump xdrCheck map order when rebuilding from exact iterUpdates for contract instance related XDR changes.Change StorageType to Just Be An EnumBump xdr for RestoreFootprintOpBump xdr for renameAdd host function for bumping contract instanceImplement contract instance storage in Soroban host.Change [IU]256 arithmetic host functions to take Val not Object.Replace increase and decrease functions with approveExpose bumpsFix calibration testsChange [IU]256 [from,to]_bytes functions to work with ValBump wasmi versionSoroban Rust SDK​Fix storage commentNoop in instance bump for testsSoroban RPC​Update js-soroban-client dependency from 0.9.0 to 0.9.1Soroban CLI​Update js-soroban-client dependency from 0.9.0 to 0.9.1Preview 9 (May 24th, 2023)​Software​SoftwareVersionXDR2f16687fdf6f4bcfb56805e2035f69997f4b34c4Soroban Environmentv0.0.16Soroban Interface Version37Stellar Core19.10.1-1310.6649f5173.focal~sorobanSoroban Rust SDKv0.8.4Soroban CLIv0.8.0Soroban RPCv0.8.0Stellar Horizonstellar-horizon:2.25.1~soroban-346Stellar Friendbotsoroban-v0.0.2-alphaStellar Quickstartstellar/quickstart:[email protected]:57e8ab498bfa14c65595fbb01cb94b1cdee9637ef2e6634e59d54f6958c05bdbStellar JS Stellar Base9.0.0-soroban.1Stellar JS Soroban Client0.7.0Freighter5.0.1Laboratory2.10.0Futurenet Network PassphraseTest SDF Future Network ; October 2022Changelog​XDR​See https://github.com/stellar/rs-stellar-xdr/releases v0.0.16 for more details.Soroban Environment​See https://github.com/stellar/rs-soroban-env/releases v0.0.16 for more details.Soroban Rust SDK​See https://github.com/stellar/rs-soroban-sdk/releases v0.8.4 for more details.Soroban RPC​See https://github.com/stellar/soroban-tools/releases v0.8.0 for more details.Soroban CLI​See https://github.com/stellar/soroban-tools/releases v0.8.0 for more details.Preview 8 (April 4th, 2023)​Software​SoftwareVersionXDR7356dc237ee0db5626561c129fb3fa4beaabbac6Soroban Environmentv0.0.15Soroban Interface Version32Stellar Core19.8.1-1246.064a2787a.focal~sorobanSoroban Rust SDKv0.7.0Soroban CLIv0.7.0Soroban RPCv0.7.0Stellar Horizonstellar-horizon:2.24.62~soroban-338Stellar Friendbotsoroban-v0.0.2-alphaStellar Quickstartstellar/quickstart:[email protected]:a057ec6f06c6702c005693f8265ed1261e901b153a754e97cf18b0962257e872Stellar JS Stellar Base8.2.2-soroban.12Stellar JS Soroban Clientv0.5.0Freighterv2.12.2Laboratoryv2.8.0Futurenet Network PassphraseTest SDF Future Network ; October 2022Breaking changes note​This release includes a major overhaul of the value representation at the XDR level, which potentially breaks contracts that rely on the old type definitions, here is a summary of the changes:Removed the object/value split at the XDR levelExpanded size of value tag from 8 to 128 casesRemoved types: U63, Static, BitsetAdded U256, I256 and special case u64 subtypes Timepoint and DurationAdded String which is a Bytes-like object but displays as textEnhanced Symbol to have a maximum size of 32 bytes (no more 10-char limit)SDK support has also been added/updated for these types. See xdr, env and sdk changes for more details.Changelog​XDR​Make types wrapping Strings no longer aliasesValue representation overhaulDiagnostic eventsSee https://github.com/stellar/rs-stellar-xdr/releases v0.0.15 for more details.Soroban Environment​Remove the unnecessary error events that appeared in non-error scenarios.Reform metering for value cloning and memory allocation.Provide more test coverage for Auth Next.Check issuer clawback flag when new contract balance is created.Add a test that covers out-of-order require_auth calls.Token name in events.Adapt Storage and SnapshotSource to use Rc only.Add host functions to convert addresses to/from account/contract ids.Value and object representation overhaul.Move InvokerType from common env to internal host implementation.fix thinko in vec_new_from_linear_memory.Improve safety of custom account contracts.Split out DeclaredSizeForMetering from MeteredClone and use it for Compare.Structured debug events.Fix an i128 conversion bug.Use new bulk memory ops for tuples.Host budget metering, cost model, calibration changes.Increase memory budget to 50MB.See https://github.com/stellar/rs-soroban-env/releases v0.0.15 for more details.Soroban Rust SDK​Add docs in specs for types.Rename Serialize/Deserialize to To/FromXdr.Use the updated source_account() interface.Update storage docs.Expose reset budget functions to testutils.Adapt storage and snapshot interface to env changes.Add utils for converting from/to contract/account ids.Value and object representation overhaul.Add a getter for address of a generated contract client.Use String for log_fmt_values.Add a utility to call __check_auth in tests.Add more support for the new types in soroban-spec.Use vector bulk-init in Vec.Bump env and update for event changes.fix(macro): add new XDR types to parser.Update budget test.bump env and update budget print.See https://github.com/stellar/rs-soroban-sdk/releases v0.7.0 for more details.Soroban RPC​Set a maximum ledger latency in /health method.Add resultMetaXdr and envelopeXdr back to getTransaction() response.Support for new diagnostic contract events.soroban-rpc: Add filtering support for diagnostic events.soroban-rpc: Ingest diagnostic events.Remove 'soroban serve' subcommand.Limit preflight-computation concurrency through a worker pool.Miscellaneous fixes.General improvements to compilation and testing.Add contract events to simulateTransaction's response.See https://github.com/stellar/soroban-tools/releases v0.7.0 for more details.Soroban CLI​Improved documentation, and --help textfeat: auto-generate comprehensive CLI docs.When using invoke, contract function names now come after the --, like soroban invoke --id <contract_id> -- hello --to \"world\"Improvements to identity managementfix: allow using ENV to add identity and pass secret.Replaced --identity, --secret-key, and --account flags. Replace with single --source, which understands identities, and secret keys.feat: add better docs for UDT and add examples for each arg.Added soroban --versionBetter errors, replacing UnknownRefactor, so that the cli can be imported via the new soroban-test crate. This makes testing and using soroban-cli as a library easier.feat: reorg into a proper library.feat: add new soroban-test crate.Update to Clap v4.fix(CLI): string/u/i256 XDR parsing.Support for new diagnostic type eventsSee https://github.com/stellar/soroban-tools/releases v0.7.0 for more details.Preview 7 (February 16th, 2023)​Software​SoftwareVersionXDRdf18148747e807618acf4639db41c4fd6f0be9fcSoroban Environmentv0.0.14Soroban Interface Version29Stellar Core19.7.1-1204.871accefc.focal~sorobanSoroban Rust SDKv0.6.0Soroban CLIv0.6.0Soroban RPC0.6.1-13Stellar Horizonstellar-horizon:2.24.61~soroban-335Stellar Friendbotsoroban-v0.0.2-alphaStellar Quickstartstellar/quickstart:[email protected]:81c23da078c90d0ba220f8fc93414d0ea44608adc616988930529c58df278739Stellar JS Stellar Base8.2.2-soroban.11Stellar JS Soroban Clientv0.4.0Freighterv2.10.0Laboratoryv2.7.0Futurenet Network PassphraseTest SDF Future Network ; October 2022Breaking changes note​This release comes with a revamp of authorization approach that is breaking for most of the contracts that did any sort of auth logic or used tokens. example and authorization overview for more details.Changelog​XDR​Update Rust XDR for Auth Next.See https://github.com/stellar/rs-stellar-xdr/releases v0.0.13 and v0.0.14 for more details.Soroban Environment​Allow for a custom budget outside testsRestructure Event to be cheap to clone and allow it to be rolled backAdd auth_required support for non-account balancesReform TryFromVal to reduce number of implsFix override of panic hook during cross-contract testingAdd EnvBase::Error, remove CheckedEnv, make Env methods return ErrorInitial Auth Next implementation in Soroban HostAdd 13-tuple conversionsDo not include Status as the first arg of a DebugEventAdd a simpler version of require_authUse auth specific errorsEmulate classic account authentication in recording auth mode.Change the interface for the auth testing utility.See https://github.com/stellar/rs-soroban-env/releases v0.0.13 and v0.0.14 for more details.Soroban Rust SDK​Support variants with multiple fields in UDTsError on UDT enums with 0-element tuple variantsAllow xlm balance updatesFix vec insertAdapt SDK to changes to {Try,}{From,Into}Val in env cratesFix vec pop_frontUse better storage error in testsAdapt to introduction of Env::ErrorImprove compiler errors for UDTsAllow same named types and functionsMake soroban_token_spec::spec_xdr easier to keep updatedRemove build-optimized makefile targetAuth Next changes in SDKAdd docs to contract spec entriesSDK support for simplified require_authSee https://github.com/stellar/rs-soroban-sdk/releases v0.5.0 and v0.6.0 for more details.Soroban RPC​Configure default limit, update cursor / startLedger validation, and include latest ledger for getEventsAdd support for AuthNextFix rollback error in logsAdd getNetwork commandImplement event storageImplement ledger entry storageRefactor db and ingestion packages, add ingestion of LedgerCloseMetaImplement simulateTransaction using rust instead of preflightSimplify topic matching for events searchSee https://github.com/stellar/soroban-tools/releases v0.5.0 v0.6.0 for more details.Soroban CLI​Add option for running contract with unlimited budgetAdd support for AuthNextAdd config commandAdd getNetwork supportReorganize CLI commandsSee https://github.com/stellar/soroban-tools/releases v0.5.0 v0.6.0 for more details.Preview 6 (January 9th, 2023)​Software​SoftwareVersionXDR026c9cd074bdb28ddde8ee52f2a4502d9e518a09Soroban Environmentv0.0.12Soroban Interface Version27Stellar Core19.6.1-1158.c0ad35aa1.focal~sorobanSoroban Rust SDKv0.4.2Soroban CLIv0.5.0Soroban RPC0.4.0-10Stellar Horizonstellar-horizon:2.22.0~soroban-323Stellar Friendbotsoroban-v0.0.2-alphaStellar Quickstart (amd64)stellar/quickstart:[email protected]:c4429def497ed78ca99ae40c8e2522ec932081b4428df992900b5bc8d53bd642Stellar Quickstart (arm64)stellar/quickstart:[email protected]:37205510329845f5fe533bb7c4c182d8f35b3a3515f0a6729889067663e1ec97Stellar JS Stellar Base8.0.1-soroban.6Stellar JS Soroban Clientv0.3.0Futurenet Network PassphraseTest SDF Future Network ; October 2022Changelog​Soroban Environment​Wasm instruction level calibrationReplace im containers with VecRemove EnvValFix first/last_index_of functions to use deep object comparisonExport type aliases for Storage and FootprintAdd env.jsonRemove built-in soroban tokenUpdate rust-versionUse single balances in the Stellar Asset ContractRemove unnecessary i128 cloneSee https://github.com/stellar/rs-soroban-env/releases v0.0.12 for more details.Soroban Rust SDK​Fix contractimpl for empty impl blocksbump env and fix token interfaceRemove init from the token interfaceUpdate rust-versionRequire only a borrow of Host when updating ledger snapshotFix doc comments and clippy warnings on ledger snapshotAdd LedgerSnapshot::update(Host)undo token deploy revertRevert deploy and update envRemove token deploy in anticipation of removal of the soroban only built-in tokenMake ledger snapshot write file create dir pathMake errors explicit in ledger snapshot functionsUpdate env to include delete-im, remove-EnvVal changesSee https://github.com/stellar/rs-soroban-sdk/releases v0.4.0, v0.4.1, v0.4.2 for more details.Soroban RPC​Add GitHub linting for GO codeSee https://github.com/stellar/soroban-tools/releases v0.4.0 for more details.Soroban CLI​Update rust versionStrValError --> Error and implemented using thiserrorUse soroban-ledger-snapshot for managing ledger.jsonUse LedgerSnapshot::update to update snapshot instead of unpacking the host and updating ledger info and entries separately.Add events subcommand for local and remote event viewingDeprecate token create commandSee https://github.com/stellar/soroban-tools/releases v0.4.0 for more details.Preview 5 (December 8th, 2022)​Software​SoftwareVersionXDR026c9cd074bdb28ddde8ee52f2a4502d9e518a09Soroban Environmentv0.0.11Soroban Interface Version26Stellar Corestellar-core_19.5.1-1137.b3a6bc281.focal~sorobanSoroban Rust SDKv0.3.2Soroban CLIv0.3.3Soroban RPC0.3.1-32Stellar Horizonstellar-horizon:2.22.0~soroban-318Stellar Friendbotsoroban-v0.0.2-alphaStellar Quickstartstellar/quickstart:[email protected]:8046391718f8e58b2b88b9c379abda3587bb874689fa09b2ed4871a764ebda27Stellar JS Stellar Base8.0.1-soroban.5Stellar JS Soroban Clientv0.2.0Futurenet Network PassphraseTest SDF Future Network ; October 2022Changelog​XDR​Remove BigInt from ScValAdd u128 and i128 to ScValChange the structure of events in metaChange transaction operation structure for Soroban contract deployments and invocationsSee https://github.com/stellar/stellar-xdr/compare/48d5e17ae63bba0aa9725cd9d18d7438f44c07b1...026c9cd074bdb28ddde8ee52f2a4502d9e518a09 for more details.Soroban Environment​Upgrade crate-git-revision to 0.0.4 (contribution by @brson)Add Host::with_artificial_test_contract_frameRestructure benchmark framework, add calibration code for all CostTypesDisable budget costs for object cmpEnv changes to decouple contract instance from sourceRemove BigInt, switch everything to u128 and i128See https://github.com/stellar/rs-soroban-env/releases v0.0.10, v0.0.11 for more details.Soroban Rust SDK​Rename data to storage by @leighmcculloch in #786Add ability to get current Budget from env in tests by @leighmcculloch in #789Add Env::as_contract for testutils by @leighmcculloch in #761Update contract deployment to match the Env changes by @dmkozh in #766Make contract_id public in contract clients. by @dmkozh in #768Remove BigInt by @sisuresh in #770Add soroban-ledger-snapshotChange gen JSON output from stream to array (contribution by @vinamogit)Contributions from @vinamogitSee https://github.com/stellar/rs-soroban-sdk/releases v0.3.0, v0.3.1, v0.3.2 for more details.Soroban RPC​Add soroban-rpc version subcommandAdd a new getLedgerEntry jsonrpc method, deprecating and replacing getContractData allowing an application to fetch any ledger entryAdded new getEvents method currently backed by horizonSee https://github.com/stellar/soroban-tools/releases v0.3.0, v0.3.1 for more details.Soroban CLI​Fix apt-get install in publish workflowAdded type description to errors when using --arg (contribution by @waldmatias)Additional CLI support for the contract deployment changesAdds support for soroban contract deploy --wasm-hash, as well as soroban contract install --wasmAdd xdr and env version to version subcommand outputFix that the footpoint was not set correctly when deploying the wrapped token contract (contribution by @overcat)Contributions from @waldmatias, @willemneal, @overcat, @brsonSee https://github.com/stellar/soroban-tools/releases v0.3.0, v0.3.1, 0.3.3 for more details.Preview 4 (November 15th, 2022)​Software​SoftwareVersionXDRhttps://github.com/stellar/stellar-xdr-next/tree/48d5e17ae63bba0aa9725cd9d18d7438f44c07b1Soroban Environmentv0.0.9Soroban Interface Version23Stellar Core19.5.1-1111.eba1d3de9.focal~sorobanSoroban Rust SDKv0.2.1Soroban CLIv0.2.1Soroban RPC0.3.1-32Stellar Horizon2.22.0~soroban-304Stellar Quickstartstellar/quickstart:[email protected]:0993d3350148af6ffeab5dc8f0b835236b28dade6dcae77ff8a09317162f768dFuturenet Network PassphraseTest SDF Future Network ; October 2022Changelog​XDR​Trivial whitespace changesSoroban Environment​Vm tuningAdd token eventsCatch panics from native contracts in try_callImproved built-in token error reportingAdd missing conversion from Status->ScStatus for the ContractError variantCapture user panic-strings in native builds, avoid spurious NoContractRunning errorFew small fixes to error debug eventsSee https://github.com/stellar/rs-soroban-env/releases v0.0.7, v0.0.8, v0.0.9 for more details.Soroban Rust SDK​Add Logger::print in testutilsAdd conversion from Address to IdentifierRemove deprecated functionsRemove panic-catching and fix tests that use newly-working native try_callReintroduce an optimized aborting unwrapAdd assert_with_error! macroRename panic_error! to panic_with_error!See https://github.com/stellar/rs-soroban-sdk/releases v0.2.0, v0.2.1 for more details.Soroban RPC​Initial ReleaseSoroban CLI​Strings and symbols are rendered as text in JSON outputBytes are rendered as hex in JSON outputAccounts in invocations are created in sandboxAdd optimize sub-command that optimizes contractsFix the bin name in the completion commandFix jsonrpc compliance issueSee https://github.com/stellar/soroban-cli/releases v0.2.0, v0.2.1 for more details.Preview 3 (October 11th, 2022)​Software​SoftwareVersionXDRhttps://github.com/stellar/stellar-xdr-next/tree/161e2e5b64425a49f9ccfef7f732ae742ed5eec4Soroban Environmentv0.0.6Soroban Interface Version23Stellar Core19.4.1-1097.4e813f20e.focal~sorobanSoroban Rust SDKv0.1.1Soroban CLIv0.1.2Soroban RPC???Stellar Horizon2.22.0~soroban-304Stellar Quickstartstellar/quickstart:[email protected]:e58d83f92a61f43406087f488dd1cba110a92646dca85f14b3a416163609e853Futurenet Network PassphraseTest SDF Future Network ; October 2022Changelog​See https://www.stellar.org/blog/soroban-a-new-smart-contract-standard.Preview 2 (September 13th, 2022)​See https://www.stellar.org/developers-blog/soroban-preview-release-2.Preview 1 (August 1st, 2022)​See https://www.stellar.org/blog/project-jump-cannon-soroban-preview-release.","metadata":{"source":"https://soroban.stellar.org/docs/reference/releases","title":"Releases","contentLength":2832}},{"pageContent":"Soroban CLISoroban CLI is the command line interface to Soroban. It allows you to build, deploy, and interact with smart contracts; configure identities; generate key pairs; manage networks; and more.Install Soroban CLI as explained in Setup.Auto-generated comprehensive reference documentation is available at: https://github.com/stellar/soroban-tools/blob/v0.8.0/docs/soroban-cli-full-docs.mdSubscribe to releases on the GitHub repository: https://github.com/stellar/soroban-toolsinfoReport issues and share feedback about Soroban CLI here: https://github.com/stellar/soroban-tools/issues/new/choose","metadata":{"source":"https://soroban.stellar.org/docs/reference/soroban-cli","title":"Soroban CLI","contentLength":90}},{"pageContent":"RPCThe RPC service allows you to communicate directly with Soroban via a JSON RPC interface.For example, you can build an application and have it send a transaction, get ledger and event data or simulate transactions.Alternatively, you can use one of Soroban's client SDKs such as the js-soroban-client, which will need to communicate with an RPC instance to access the network.Run Your Own Instance​Download and run a local instance via Docker Quickstart and run a standalone network or communicate with a live development Futurenet (and soon to come, Testnet and Mainnet).For local development, an RPC service can run on a standard laptop with 16GB of RAM and has minimal storage and CPU requirements.The Quickstart image is a single container that runs everything you need to test against a fully featured network. It contains:Stellar Core – Node software that runs the network, coordinates consensus, and finalizes ledgers.Soroban RPC server – JSON RPC server for interacting with Soroban contracts.Horizon server – HTTP API for access ledger state and historical transactions.Friendbot server – HTTP API for creating and funding new accounts on test networks.infoIt's also possible to run a contract in the local sandbox environment without a network using just Soroban CLI. See Run on Sandbox for more details.Standalone​To run a local standalone network with the Stellar Quickstart Docker image, run the following command, double-checking that the sha256 matches the latest on the Releases page:docker run --rm -it \\ -p 8000:8000 \\ --name stellar \\ stellar/quickstart:[email protected]:a6b03cf6b0433c99f2f799b719f0faadbb79684b1b763e7674ba749fb0f648ee \\ --standalone \\ --enable-soroban-rpcOnce the image is started you can check its status by querying the Horizon API:curl \"http://localhost:8000\"You can interact with this local node using Soroban CLI. First, add it as a configured network:soroban config network add standalone \\ --rpc-url \"http://localhost:8000/soroban/rpc\" \\ --network-passphrase \"Standalone Network ; February 2017\"Then generate a unique identity (public/private keypair) to use with it:soroban config identity generate aliceTest-only IdentitiesIt's a good practice to never use the same keys for testing and development that you use do for the public Stellar network. Generate new keys for testing and development and avoid ever using them for other purposes.Finally, fund your new account on the local sandbox environment by making a request to the local Friendbot:curl \"http://localhost:8000/friendbot?addr=$(soroban config identity address alice)\"Command Expansion $(…)This uses command expansion, which only works with bash-compatible shells. If you are using Windows or some other shell, you will need to copy the output of soroban config… and paste it into the curl command, or figure out how command expansion works in your shell.Now that you have a configured network and a funded identity, you can use these within other Soroban CLI commands. For example, deploying a contract:soroban contract deploy \\ --wasm target/wasm32-unknown-unknown/release/[project_name].wasm \\ --source alice \\ --network standaloneOr invoking a contract:soroban contract invoke \\ --id C… \\ --source alice \\ --network standalone \\ -- \\ hello \\ --to friendWhen you're done with your Standalone node, you can close it with ctrlc (not cmd). This will fully remove the container (that's what the --rm option to the docker command does), which means you will need to re-deploy your contract and re-fund your identity next time you start it. If you work with local nodes often, you may want to create scripts to make these initialization steps easier. For example, see the example dapp's initialize.sh.Futurenet​Running your own Futurenet node works much the same way as running a Quickstart node, described above. You will need minor modifications for a few commands. First, you need --futurenet for the docker instance, rather than --standalone:docker run --rm -it \\ -p 8000:8000 \\ --name stellar \\ stellar/quickstart:[email protected]:ed57f7a7683e3568ae401f5c6e93341a9f77d8ad41191bf752944d7898981e0c \\ --futurenet \\ --enable-soroban-rpcAnd you'll want to configure it for use with the --network flag in Soroban CLI:soroban config network add futurenet \\ --rpc-url \"http://localhost:8000/soroban/rpc\" \\ --network-passphrase \"Test SDF Future Network ; October 2022\"Replace futurenet in that command with the name of your choice, if you want to leave the name futurenet available for use with a public RPC provider (see below). Or make clever use of --global configs for public providers and local configs (made with the undecorated network add command above) for local nodes.The alice identity suggested for your Standalone network will still work here, since it's just a public/private keypair, but you'll need to remember to fund it:curl \"http://localhost:8000/friendbot?addr=$(soroban config identity address alice)\"Now you can replace --network standalone with --network futurenet (or whatever you named it) in all your commands that need a network, like the deploy and invoke shown above.Public RPC Providers​These providers host an publicly available RPC endpoint that you can connect to. The following currently support Futurenet (with more to come).ProviderEndpointFriendbotSDFhttps://rpc-futurenet.stellar.orghttps://friendbot-futurenet.stellar.orgYou can configure Soroban CLI to use this RPC endpoint:soroban config network add --global futurenet \\ --rpc-url https://rpc-futurenet.stellar.org:443 \\ --network-passphrase 'Test SDF Future Network ; October 2022'And fund your accounts/identities with the publicly hosted Friendbot:curl \"https://friendbot-futurenet.stellar.org/?addr=$(soroban config identity address alice)\"See the tip above about command expansion (the $(…) stuff) if you're not using a bash-based shell.cautionWhen interacting with the network in production you should run your own soroban-rpc or use a third party infrastructure provider.","metadata":{"source":"https://soroban.stellar.org/docs/reference/rpc","title":"RPC","contentLength":925}},{"pageContent":"Freighter WalletFreighter is a browser extension wallet provided by the Stellar Development Foundation. It provides users a way to interact with Soroban tokens directly from the web browser.Setup​Install the Freighter browser extension.Create a keypair or import an existing account using a mnemonic phrase to complete setup.Next, switch to Experimental Mode to enable the Soroban SDK. In the extension, click the gear in the lower right corner and then navigate to Preferences. Toggle on Experimental Mode.After switching to Experimental Mode, you should automatically be switched to the Futurenet network. Fund your account on Futurenet using Friendbot. For convenience, you can do so in the Stellar Laboratory.Enable Soroban Tokens​With a funded Futurenet account and Experimental Mode enabled, you can now add Soroban tokens to your Freighter wallet.On the Freighter account screen, click this Manage Assets button at the bottom of the screen.You will now see a button to Add Soroban token at the bottom of the screen. Click this Add Soroban token button.On the next screen, enter the Token ID of the token you want to add to Freighter and click Add New Token.You will now see your token's balance on Freighter's account page. Clicking on the balance will show a history of payments sent using this token.Send Token Payments​Once you have added a Soroban token to your Freighter wallet, you can now send a payment of that token directly from Freighter.On the Freighter account screen, click the Send Payment icon in the upper right of the screen.Enter a recipient public key. Click Continue.Select your token from the asset dropdown at the bottom of the screen and enter a token amount. Click Continue.Enter a memo (optional). Click Review Send.Review the details of your payment. Click Send.Sign Soroban XDRs​With a funded Futurenet account and Experimental Mode enabled, you can now sign Soroban XDRs using dApps that are integrated with Freighter. An example of an integrated dApp is Stellar's Laboratory.On the Lab's transaction signer, enter a Soroban XDR into the form field.Click Sign with Freighter.Freighter will open with the details of the XDR. Click Approve to sign or Reject to dismiss without a signature.If approved, Freighter will transmit a signed XDR back to the Lab.As a dApp Provider, Prompt Freighter to Sign Transactions (Advanced)​If you're building a JS dApp, easily sign Soroban transactions using the Freighter browser extension and its corresponding client library @stellar/freighter-api:Follow the setup instructions above.Now, you can use the signTransaction method from @stellar/freighter-api in your dApp to sign Soroban XDRs using the account in Freighter.Upon calling signTransaction, Freighter will open and prompt the user to sign the transaction. Approving the transaction will return the signed XDR to the requesting dApp.","metadata":{"source":"https://soroban.stellar.org/docs/reference/freighter","title":"Freighter Wallet","contentLength":477}},{"pageContent":"Developer ToolsinfoAll tools currently listed are built and maintained by dedicated community members.Soroban Dev​A web developer’s guide to Soroban. Contains guides for learning Soroban and Rust, developer tools, example applications, and more.Use Soroban​A web GUI for building, deploying, and testing contracts.Soroban Copilot​A collection of no_std Rust packages focused on making Soroban development easier.Soroban React​A simple, powerful framework for building modern Soroban dApps using React.Sorobix​An IDE where you can write, deploy, and invoke contracts on the Stellar network using Soroban.","metadata":{"source":"https://soroban.stellar.org/docs/developer-tools","title":"Developer Tools","contentLength":90}}]